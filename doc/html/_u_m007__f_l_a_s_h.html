<!-- HTML header for doxygen 1.8.14-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BT AUDIO SDK: $title</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="customdoxygen.css" rel="stylesheet" type="text/css" />
<link href="my_customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="bbpro-h55px.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">BT AUDIO SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,true,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="contents">
<div class="textblock"><p><br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
 </p>
<h1><a class="anchor" id="FLASH"></a>
Flash User Guide    </h1>
<p><br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
 </p><center><b>V1.5</b></center><p><br />
 </p><center><b>2023/07/14</b></center><div style="page-break-after: always;"></div><h2><a class="anchor" id="FLASH_REV"></a>
Revision History</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Version  </th><th class="markdownTableHeadCenter">Date  </th><th class="markdownTableHeadCenter">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">V1.0.0.0  </td><td class="markdownTableBodyCenter">2022/10/26  </td><td class="markdownTableBodyCenter">Stable release   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">V1.0.0.1  </td><td class="markdownTableBodyCenter">2023/03/28  </td><td class="markdownTableBodyCenter">Update the document content   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">V1.0.0.2  </td><td class="markdownTableBodyCenter">2023/04/24  </td><td class="markdownTableBodyCenter">Update picture size   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">V1.0.0.3  </td><td class="markdownTableBodyCenter">2023/04/25  </td><td class="markdownTableBodyCenter">Update Bring New Flash Layout into Effect   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">V1.4  </td><td class="markdownTableBodyCenter">2023/05/31  </td><td class="markdownTableBodyCenter">Change version number to 2 digits   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">V1.5  </td><td class="markdownTableBodyCenter">2023/07/14  </td><td class="markdownTableBodyCenter">Support to update address of vp data   </td></tr>
</table>
<div style="page-break-after: always;"></div><h2>Contents</h2>
<ul>
<li><a class="el" href="_u_m007__f_l_a_s_h.html#FLASH_REV">Revision History</a></li>
<li><a class="el" href="_u_m007__f_l_a_s_h.html#FLASH_Table_List">Table List</a></li>
<li><a class="el" href="_u_m007__f_l_a_s_h.html#FLASH_Figure_List">Figure List</a></li>
<li><a class="el" href="_u_m007__f_l_a_s_h.html#FLASH_Glossary">Glossary</a></li>
<li><a class="el" href="_u_m007__f_l_a_s_h.html#FLASH_Intro">1 Introduction</a></li>
<li><a class="el" href="_u_m007__f_l_a_s_h.html#FLASH_Basic_Func">2 Basic Operations</a></li>
<li><a class="el" href="_u_m007__f_l_a_s_h.html#FLASH_Layout">3 Flash Layout</a><ul>
<li><a class="el" href="_u_m007__f_l_a_s_h.html#FLASH_Layout_RTL87X3E">3.1 RTL87X3E Flash Layout</a></li>
<li><a class="el" href="_u_m007__f_l_a_s_h.html#FLASH_Layout_RTL87X3D">3.2 RTL87X3D Flash Layout</a></li>
<li><a class="el" href="_u_m007__f_l_a_s_h.html#FLASH_Layout_Tool">3.3 How to configure flash layout</a></li>
<li><a class="el" href="_u_m007__f_l_a_s_h.html#FLASH_Layout_validate_new">3.4 Bring New Flash Layout into Effect</a><ul>
<li><a class="el" href="_u_m007__f_l_a_s_h.html#FLASH_Layout_Contraints">3.4.1 Constraints and restrictions brief</a></li>
<li><a class="el" href="_u_m007__f_l_a_s_h.html#FLASH_Layout_Update_System_Config">3.4.2 update system config image</a></li>
<li><a class="el" href="_u_m007__f_l_a_s_h.html#FLASH_Layout_Update_OTA_HEADER">3.4.3 update OTA header image</a></li>
<li><a class="el" href="_u_m007__f_l_a_s_h.html#FLASH_Layout_Update_Patch_Content">3.4.4 update image content by flash map</a></li>
<li><a class="el" href="_u_m007__f_l_a_s_h.html#FLASH_Layout_Update_APP">3.4.5 recompile app image</a></li>
<li><a class="el" href="_u_m007__f_l_a_s_h.html#FLASH_Layout_Download_Images">3.4.6 download images with new flash layout</a></li>
</ul>
</li>
<li><a class="el" href="_u_m007__f_l_a_s_h.html#FLASH_Layout_Generate">3.5 Generate ext image command line</a></li>
</ul>
</li>
<li><a class="el" href="_u_m007__f_l_a_s_h.html#Flash_Section">4 Section Usage</a></li>
<li><a class="el" href="_u_m007__f_l_a_s_h.html#FTL">5 Flash Transport Layer</a><ul>
<li><a class="el" href="_u_m007__f_l_a_s_h.html#FTL_DEFAULT_MODULE">5.1 Default FTL Module</a></li>
<li><a class="el" href="_u_m007__f_l_a_s_h.html#FTL_DEFAULT_API">5.2 FTL APIs of default FTL module</a></li>
<li><a class="el" href="_u_m007__f_l_a_s_h.html#FTL_MODULE">5.3 How to add a FTL module</a></li>
<li><a class="el" href="_u_m007__f_l_a_s_h.html#FTL_POOL">5.4 FTL POOL</a><ul>
<li><a class="el" href="_u_m007__f_l_a_s_h.html#FTL_SIZE_CHANGE">5.4.1 How to estimate the min flash size of FTL POOL</a></li>
</ul>
</li>
<li><a class="el" href="_u_m007__f_l_a_s_h.html#FTL_CACHE">5.5 FTL cache</a></li>
</ul>
</li>
<li><a class="el" href="_u_m007__f_l_a_s_h.html#FLASH_External">6 External Flash</a><ul>
<li><a class="el" href="_u_m007__f_l_a_s_h.html#EXT_FLASH_System_Arch">6.1 System Arch</a></li>
<li><a class="el" href="_u_m007__f_l_a_s_h.html#EXT_FLASH_SPIC">6.2 SPIC</a></li>
<li><a class="el" href="_u_m007__f_l_a_s_h.html#EXT_FLASH_pinmux">6.3 Pinmux</a></li>
<li><a class="el" href="_u_m007__f_l_a_s_h.html#FLASH_ADDR">6.4 Flash Address</a></li>
<li><a class="el" href="_u_m007__f_l_a_s_h.html#EXT_FLASH_Conclusion">6.5 Conclusion</a></li>
</ul>
</li>
</ul>
<div style="page-break-after: always;"></div><h2><a class="anchor" id="FLASH_Table_List"></a>
Table List</h2>
<ul>
<li><a href="#table_3_1">Table 3-1 The BinID of ext image type</a></li>
<li><a href="#table_6_1">Table 6-1 Pinmux for external flash</a></li>
</ul>
<div style="page-break-after: always;"></div><h2><a class="anchor" id="FLASH_Figure_List"></a>
Figure List</h2>
<ul>
<li><a href="#figure_3_1">Figure 3-1 RTL87X3E High Layer Illustration of Flash Layout</a></li>
<li><a href="#figure_3_2">Figure 3-2 RTL87X3E Flash Layout Config Sample</a></li>
<li><a href="#figure_3_3">Figure 3-3 RTL87X3D High Layer Illustration of Flash Layout</a></li>
<li><a href="#figure_3_4">Figure 3-4 RTL87X3D Flash Layout Config Sample</a></li>
<li><a href="#figure_3_5">Figure 3-5 Flash Map Generator</a></li>
<li><a href="#figure_3_6">Figure 3-6 RTL87X3E Configure Flash Map</a></li>
<li><a href="#figure_3_7">Figure 3-7 RTL87X3D Configure Flash Map</a></li>
<li><a href="#figure_3_8">Figure 3-8 Change Flash Map in System Config</a></li>
<li><a href="#figure_3_9">Figure 3-9 Change Flash Map in OTA Header</a></li>
<li><a href="#figure_3_10">Figure 3-10 update bank0 images under the directory by flash map</a></li>
<li><a href="#figure_3_11">Figure 3-11 update bank0 single image by flash map</a></li>
<li><a href="#figure_3_12">Figure 3-12 update bank1 images under the directory by flash map</a></li>
<li><a href="#figure_3_13">Figure 3-13 update bank1 single image by flash map</a></li>
<li><a href="#figure_5_1">Figure 5-1 Default FTL module Layout</a></li>
<li><a href="#figure_6_1">Figure 6-1 System Arch of RTL87X3D</a></li>
</ul>
<div style="page-break-after: always;"></div><h2><a class="anchor" id="FLASH_Glossary"></a>
Glossary</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Terms  </th><th class="markdownTableHeadCenter">Definitions   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">FTL  </td><td class="markdownTableBodyCenter">Flash Transport Layer   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">GC  </td><td class="markdownTableBodyCenter">Garbage Collection   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">SPIC  </td><td class="markdownTableBodyCenter">SPI Flash Controller   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">MCM  </td><td class="markdownTableBodyCenter">Mutli-Chip Module   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">SoC  </td><td class="markdownTableBodyCenter">System on Chip   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">BP  </td><td class="markdownTableBodyCenter">Block Protect   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">PI  </td><td class="markdownTableBodyCenter">Position Independent   </td></tr>
</table>
<div style="page-break-after: always;"></div><h2><a class="anchor" id="FLASH_Intro"></a>
1 Introduction</h2>
<p>Flash is non-volatile storage. Compare to RAM, which could be written or read directly, flash must be empty or erased before being written. Flash supports at least 100K Program-Erase cycles. And flash can develop bad blocks when the same blocks are erased frequently.</p>
<p>This document shows you how to use Flash with the following topics:</p><ul>
<li>Flash basic operations<ul>
<li>Introduce flash APIs.</li>
</ul>
</li>
<li>Flash Layout<ul>
<li>Introduce the layout in flash, which could prevent misuse.</li>
<li>Introduce how to adjust the flash layout.</li>
</ul>
</li>
<li>Flash section<ul>
<li>Help user to place data/functions in the different areas.</li>
</ul>
</li>
<li>Flash translation layer<ul>
<li>Introduce how to use the FTL, which is designed for lightweight dynamical parameter storage.</li>
</ul>
</li>
<li>External Flash<ul>
<li>Introduce the external Flash from the architecture perspective to the application level.</li>
</ul>
</li>
</ul>
<p>It is recommended to use flash translation layer(FTL) rather than flash driver for user data storage. If you really need to operate flash directly, APIs with the "fmc_" prefix can be used.</p>
<p>External flash is supported. Multiple choices are available for basic functions like single-mode read, write and erase. However, the flash driver also provides some advanced functions. For example, quad mode, deep power-down, and flash block protection. These functions aren't supported for all flash, therefore, Realtek can provide the Approved Vendor List if needed.</p>
<div style="page-break-after: always;"></div><h2><a class="anchor" id="FLASH_Basic_Func"></a>
2  Basic Operations</h2>
<p>There are three basic operations for flash - read, write, and erase. Flash export these functions with task-safe. This means that all flash basic operations can not be executed at the same time. That's because there is only one resource (flash) and only one path (flash controller) to access it. This helps prevent multiple tasks or interrupts from destroying the atomicity of the SPIC command sequence.</p>
<ul>
<li><b>bool <a class="el" href="group__x3e___f_m_c___exported___flash___functions.html#ga3374cd4db74d705f4fa380cbb199ea4b" title="Task-safe NOR flash read. ">fmc_flash_nor_read(uint32_t addr, void *data, uint32_t len)</a>;</b><ul>
<li>Reads data from flash through user mode. Users could specify the data length to be read out.</li>
</ul>
</li>
<li><b>bool <a class="el" href="group__x3e___f_m_c___exported___flash___functions.html#gae80bbb5a0d602b03163b62154e7007b7" title="Task-safe NOR flash auto DMA read. ">fmc_flash_nor_auto_dma_read(uint32_t src, uint32_t dst, uint32_t len, FMC_FLASH_NOR_ASYNC_CB cb)</a>;</b><ul>
<li>If user needs to read a large amount of data(like 1k Bytes), This API is recommended. Because DMA read is faster than <a class="el" href="group__x3d___f_m_c___exported___flash___functions.html#ga3374cd4db74d705f4fa380cbb199ea4b" title="Task-safe NOR flash read. ">fmc_flash_nor_read()</a>.</li>
</ul>
</li>
<li><b>bool <a class="el" href="group__x3e___f_m_c___exported___flash___functions.html#gaf838c4108c71f7fe6a132b1c8c344b6e" title="Task-safe NOR flash write. ">fmc_flash_nor_write(uint32_t addr, void *data, uint32_t len)</a>;</b><ul>
<li>Writes data to flash through user mode. Users could specify the data length to be written.</li>
<li>Notice: <a class="el" href="group__x3d___f_m_c___exported___flash___functions.html#gaf838c4108c71f7fe6a132b1c8c344b6e" title="Task-safe NOR flash write. ">fmc_flash_nor_write()</a> modify the flash data through SPIC rather than the bus command, so this operation would not affect the data in the Cache. In this case, auto_read would return the old data in the Cache. The user could flush the Cache or use <a class="el" href="group__x3d___f_m_c___exported___flash___functions.html#ga3374cd4db74d705f4fa380cbb199ea4b" title="Task-safe NOR flash read. ">fmc_flash_nor_read()</a> to get the correct data after <a class="el" href="group__x3d___f_m_c___exported___flash___functions.html#gaf838c4108c71f7fe6a132b1c8c344b6e" title="Task-safe NOR flash write. ">fmc_flash_nor_write()</a>.</li>
</ul>
</li>
<li><b>bool <a class="el" href="group__x3e___f_m_c___exported___flash___functions.html#ga21593905530e0697ebde122aace68a13" title="Task-safe NOR flash erase. ">fmc_flash_nor_erase(uint32_t addr, FMC_FLASH_NOR_ERASE_MODE mode)</a>;</b><ul>
<li>Supports 3 erase types (FMC_FLASH_NOR_ERASE_MODE), FMC_FLASH_NOR_ERASE_CHIP (erase whole chip), FMC_FLASH_NOR_ERASE_SECTOR (4K Bytes) and FMC_FLASH_NOR_ERASE_BLOCK (64K Bytes).</li>
</ul>
</li>
</ul>
<div style="page-break-after: always;"></div><h2><a class="anchor" id="FLASH_Layout"></a>
3  Flash Layout</h2>
<p>In order to use flash more conveniently and prevent misuse, Flash layout is introduced.</p>
<h3><a class="anchor" id="FLASH_Layout_RTL87X3E"></a>
3.1 RTL87X3E Flash Layout</h3>
<p>RTL87X3E has a two-layer flash layout which indicates the start address and max size of images in flash:</p><ol type="1">
<li>The configurations of system config image and Boot Patch are fixed in the ROM, which can't be changed.</li>
<li>The configurations of PLATFORM_EXT, LOWERSTACK_EXT and UPPERSTACK are fixed when the SDK release.</li>
<li>The system config image and Boot Patch Header record the layout of high layer images(except images in BANKx).</li>
<li>The OTA Header fixed at beginning of the BANKx area defines the layout of images in the same BANKx(low layer). The address of "OTA Bank0" in the "High Level Type" is the same with the address of Bank0 OTA Header in the "OTA File Type". And the size of "OTA Bank0" in the "High Level Type" is the total space size of the bank0 images in the "OTA File Type". It's the same with bank1.</li>
</ol>
<p>The high layer illustration of flash layout is shown in <a href="#figure_3_1">Figure 3-1</a>.</p>
<div class="image">
<img src="RTL87X3E_High_Layer_Illustration_of_Flash_Layout.png" alt="RTL87X3E_High_Layer_Illustration_of_Flash_Layout.png" width="1000px" height="617px"/>
</div>
 <center><div id="figure_3_1"><b>Figure 3-1 RTL87X3E High Layer Illustration of Flash Layout</b></div></center><p><b>Note:</b></p><ol type="1">
<li>The BKP_DATA sections are reserved.</li>
<li>After the flash map is modified, please make sure to regenerate the related images.</li>
<li>The flash layout of all images should not overlap. And the flash layout of the high level regions should not overlap. The flash layout size of the image should be larger than the image size, and it's suggested to be aligned by flash sector size(0x1000 bytes). If two images share one flash sector, these two images should download together for the minimum flash erasure size is flash sector size.</li>
</ol>
<p>Here take 4M flash map as an example to show the detailed description of the flash layout in <a href="#figure_3_2">Figure 3-2</a>. Similarly, the other flash layout can be described according to its corresponding flash_map.h.</p>
<div class="image">
<img src="RTL87X3E_Flash_Layout_Config_Sample.png" alt="RTL87X3E_Flash_Layout_Config_Sample.png" width="1000px" height="289px"/>
</div>
 <center><div id="figure_3_2"><b>Figure 3-2 RTL87X3E Flash Layout Config Sample</b></div></center><h3><a class="anchor" id="FLASH_Layout_RTL87X3D"></a>
3.2 RTL87X3D Flash Layout</h3>
<p>RTL87X3D has a two-layer flash layout which indicates the start address and max size of images in flash:</p><ol type="1">
<li>The configurations of system config image and Boot Patch are fixed in ROM, which can't be changed.</li>
<li>The system config image includes the layout of high layer images(except images in BANKx).</li>
<li>The OTA Header fixed at beginning of the BANKx area defines the layout of images in the same BANKx(low layer). The address of "OTA Bank0" in the "High Level Type" is the same with the address of Bank0 OTA Header in the "OTA File Type". And the size of "OTA Bank0" in the "High Level Type" is the total space size of the bank0 images in the "OTA File Type". It's the same with bank1.</li>
</ol>
<p>The high layer illustration of flash layout is shown in <a href="#figure_3_3">Figure 3-3</a>.</p>
<div class="image">
<img src="RTL87X3D_high_layout.png" alt="RTL87X3D_high_layout.png" width="1000px" height="461px"/>
</div>
 <center><div id="figure_3_3"><b>Figure 3-3 RTL87X3D High Layer Illustration of Flash Layout</b></div></center><p><b>Note:</b></p><ol type="1">
<li>The BKP_DATA sections are reserved.</li>
<li>After the flash map is modified, please make sure to regenerate the related images.</li>
<li>The flash layout of all images should not overlap. And the flash layout of the high level regions should not overlap. The flash layout size of the image should be larger than the image size, and it's suggested to be aligned by flash sector size(0x1000 bytes). If two images share one flash sector, these two images should download together for the minimum flash erasure size is flash sector size.</li>
</ol>
<p>Here take 16M flash map as an example to show the detailed description of the flash layout in <a href="#figure_3_4">Figure 3-4</a>. Similarly, the other flash layout can be described according to its corresponding flash_map.h.</p>
<div class="image">
<img src="RTL87X3D_Flash_Layout_Config_Sample.png" alt="RTL87X3D_Flash_Layout_Config_Sample.png" width="1000px" height="295px"/>
</div>
 <center><div id="figure_3_4"><b>Figure 3-4 RTL87X3D Flash Layout Config Sample</b></div></center><h3><a class="anchor" id="FLASH_Layout_Tool"></a>
3.3 How to configure flash layout</h3>
<p>Flash Map Generator in the MPPGTool is designed to generate flash_map.ini and flash_map.h which could determine the flash layout. The flash_map.ini would be used by MPPGTool and MCUConfig Tool.</p>
<ol type="1">
<li>To generate the flash_map.ini by 'Flash Map Generator', user should open the MPPGTool first, as shown in <a href="#figure_3_5">Figure 3-5</a>. <br />
 <div class="image">
<img src="flash_map_generator.png" alt="flash_map_generator.png" width="1000px" height="693px"/>
</div>
 <center><div id="figure_3_5"><b>Figure 3-5 Flash Map Generator</b></div></center> <br />
</li>
<li>Configure the whole flash layout in the 'High Level Type' list and configure the layout for bank0/bank1 in 'OTA File Type' list after selecting 'Flash Size' combo box. Multi-image header size is provided in 'Image Header Size' combo box.'Set BP Size to Front' combo box is to set which area of the flash the BP level protects for.Notice that items which 'write enable' is selected 'RW' should be placed out of BP size. You can also import an existing flash map.ini by clicking the 'Import' button and then modify layout base on it. At last, you can click the 'Generate' button to generate a new flash map.ini. Please refer to <a href="#figure_3_6">Figure 3-6</a> and <a href="#figure_3_7">Figure 3-7</a>.</li>
</ol>
<div class="image">
<img src="RTL87X3E_generate_flash_map.png" alt="RTL87X3E_generate_flash_map.png" width="1000px" height="673px"/>
</div>
 <center><div id="figure_3_6"><b>Figure 3-6 RTL87X3E Configure Flash Map</b></div></center><p><br />
 </p><div class="image">
<img src="RTL87X3D_generate_flash_map.png" alt="RTL87X3D_generate_flash_map.png" width="1000px" height="673px"/>
</div>
 <center><div id="figure_3_7"><b>Figure 3-7 RTL87X3D Configure Flash Map</b></div></center><p><b>Note:</b> Please refer to the MPPG Tool Chain User Guide in the tool\MPPGTool directory for details.</p>
<h3><a class="anchor" id="FLASH_Layout_validate_new"></a>
3.4 Bring New Flash Layout into Effect</h3>
<p>User can adjust the flash layout in the flash_map.ini and flash_map.h through the "Flash Map Generator" in the MPPGTool under the "Tool" menu. But there are some constraints for the flash layout adjusting.</p>
<ul>
<li>The image address and size are suggested to be aligned by 0x1000 bytes for the minimum size for flash erase is flash sector size. If there are two images in one flash sector, these two images should be updated together.</li>
<li>Not all image layout can be adjusted. There are some constraints and restrictions for the images, refer to <a class="el" href="_u_m007__f_l_a_s_h.html#FLASH_Layout_Contraints">3.4.1 Constraints and restrictions brief</a>.</li>
</ul>
<h4><a class="anchor" id="FLASH_Layout_Contraints"></a>
3.4.1 Constraints and restrictions brief</h4>
<p>Flash layout for images can be adjusted under some constraints and restrictions according by the image types. Images can be divided into the following types:<br />
</p><ul>
<li>Images of fixed address in the flash layout<br />
 RTL87x3e : boot patch image, lowerstack ext image, platform ext image, upperstack image.<br />
 RTL87x3d : boot patch image.<br />
 The flash address for these images can't be changed.<br />
</li>
<li>Patch code images<br />
 RTL87x3e: fsbl image, sys patch image, stack patch image.<br />
 RTL87x3d: fsbl image, rom patch image, stack patch image.<br />
 When these images are released with position independent attribute, changing the flash layout for these images just needs to update the content of these images through the tool update_images_by_flash_map.exe under the directory of sdk\tool\Gadgets\update_images_by_flash_map. All the patch images in the release package with this user guide in the sdk document support position independent. So all the patch code images in the later document represent images that support the position independent attribute.</li>
<li>App code image<br />
 App image is compiled related with the app flash address in the flash layout, and it should be recompiled with the new flash layout. The FTL is not image, and if the FTL address or size is changed, app image should be recompiled with the new flash map, please refer to <a class="el" href="_u_m007__f_l_a_s_h.html#FTL_POOL">5.4 FTL POOL</a>.<br />
</li>
<li>System config image<br />
 The high level flash layout configuration about OTA bank0, OTA bank1, backup data and OTA tmp are placed in the system config image, so if the address or size of OTA bank0, OTA bank1, backup data or OTA tmp are changed, the system config image should be updated through MCUConfig tool with new flash map. If the address and size for OTA bank0, OTA bank1, backup data and OTA tmp are not changed, only the addrees or map for the images in the bank are changed, the system config image doesn't need to be updated. For the ftl layout, please refer to <a class="el" href="_u_m007__f_l_a_s_h.html#FTL_POOL">5.4 FTL POOL</a>. If the system config image can't be updated through the OTA upgrade procedure, all the high level flash layout can't be modified again.<br />
</li>
<li>OTA header image<br />
 All the flash layout information for the images in the bank are placed in the OTA header image for each bank. If the flash layout for the bank images are changed, the OTA header image should be updated through MPPGTool with the new flash map. If the address of OTA header image in bank0 or bank1 is changed, please keep the address of OTA Bank0 or OTA Bank1 in the high level same with it.<br />
</li>
<li>VP data image for RTL87x3e<br />
 The flash layout information for VP data image on the RTL87x3e is related with storage partition in the app code image. If the flash layout for VP data image is changed, the app code image should be recompiled with new flash map and updated on the flash.<br />
</li>
<li>Other images<br />
 RTL87x3e : dsp sys image, dsp app image, dsp data image, app config data image, ext image0~3.<br />
 RTL87x3d: dsp sys image, dsp app image, dsp data image, app config data image, ext image0~3.<br />
 For RTL87x3e, ext image0 is usually used as anc config data image.<br />
 For RTL87x3d, ext image0 is usually used as anc config data image, ext image1 is usually used as dsp2 system image, ext image2 is used as ext dsp config image, and ext image3 is used as ADSP app image.<br />
 The flash layout for these images can be adjusted without updating the content of these images.</li>
</ul>
<p>User should update images according to the actual flash layout adjustment situation:<br />
 1) If the high layer flash layout configuration about OTA bank0, OTA bank1, backup data and OTA tmp are not changed, and also the flash layout for fsbl/sys patch/rom patch/stack patch are not changed, only the flash layout for app image, dsp related images, app config image or ext image0~3 are changed, user needs to recompile the app image with new flash layout, please refer to <a class="el" href="_u_m007__f_l_a_s_h.html#FLASH_Layout_Update_APP">3.4.5 recompile app image</a>, and update the OTA header image, please refer to <a class="el" href="_u_m007__f_l_a_s_h.html#FLASH_Layout_Update_OTA_HEADER">3.4.3 update OTA header image</a>.<br />
 2) If the high layer flash layout configuration about OTA bank0, OTA bank1, backup data and OTA tmp are changed, user need to update the system config image through MCU Config Tool, please refer to <a class="el" href="_u_m007__f_l_a_s_h.html#FLASH_Layout_Update_System_Config">3.4.2 update system config image</a>.<br />
 3) If the flash layout for fsbl/sys patch/rom patch/stack patch are not changed, but the flash layout for app image, dsp related images, app config image or ext image0~3 are changed, user need to recompile the app image with new flash layout, please refer to <a class="el" href="_u_m007__f_l_a_s_h.html#FLASH_Layout_Update_APP">3.4.5 recompile app image</a>, and update OTA header image, please refer to <a class="el" href="_u_m007__f_l_a_s_h.html#FLASH_Layout_Update_OTA_HEADER">3.4.3 update OTA header image</a>.<br />
 4) If the flash layout for fsbl/sys patch/rom patch/stack patch are changed, user can update the content of these images by the tool update_images_by_flash_map.exe without recompiling, please refer to <a class="el" href="_u_m007__f_l_a_s_h.html#FLASH_Layout_Update_Patch_Content">3.4.4 update image content by flash map</a>.</p>
<p>So the OTA header image should be updated by referring to <a class="el" href="_u_m007__f_l_a_s_h.html#FLASH_Layout_Update_OTA_HEADER">3.4.3 update OTA header image</a> when the image layout in the bank is changed, and the system config image should be updated by referring to <a class="el" href="_u_m007__f_l_a_s_h.html#FLASH_Layout_Update_System_Config">3.4.2 update system config image</a> when the high layer flash layout is changed, and the flash layout for fsb/sys patch/rom patch/statck patch can be changed by updating the content with the tool update_images_by_flash_map.exe by referring to <a class="el" href="_u_m007__f_l_a_s_h.html#FLASH_Layout_Update_Patch_Content">3.4.4 update image content by flash map</a>. And app image need to be recompiled with new flash map by referring to <a class="el" href="_u_m007__f_l_a_s_h.html#FLASH_Layout_Update_APP">3.4.5 recompile app image</a> if the flash layout for app image is changed.</p>
<h4><a class="anchor" id="FLASH_Layout_Update_System_Config"></a>
3.4.2 update system config image</h4>
<p>If the high layer flash layout configuration about OTA bank0, OTA bank1, backup data and OTA tmp are changed, the system config image should be updated through MCUConfig Tool.</p>
<p>Open MCUConfig Tool and switch to the "System Configuration" tab, scroll down to the "OEM Header Setting" group, and then click the "Import flash_map.ini" button to load the new flash map. Then a new system config image will be generated. Please refer to <a href="#figure_3_8">Figure 3-8</a>. <br />
 </p><div class="image">
<img src="change_flash_map_in_system_config.png" alt="change_flash_map_in_system_config.png"/>
</div>
<center><div id="figure_3_8"><b>Figure 3-8 Change Flash Map in System Config</b></div></center><h4><a class="anchor" id="FLASH_Layout_Update_OTA_HEADER"></a>
3.4.3 update OTA header image</h4>
<p>If the image layout in the bank is changed, OTA header image should be updated through MPPGTool.</p>
<p>Open MPPGTool:</p><ul>
<li>Click the menu Tool -&gt; Generate OTA Header.</li>
<li>Click the "Load Flash Layout" button to load the new flash map.ini.</li>
<li>Select OTA bank "Bank0" or "Bank1".</li>
<li>Set the OTA image version. The OTA Image version is used for bank switch.</li>
<li>Set the RSA key through "Load RSA Key" button.</li>
<li>Click the "Generate" button to generate the OTA Header with the new flash layout. See <a href="#figure_3_9">Figure 3-9</a>. <br />
 <div class="image">
<img src="change_flash_map_in_otaheader.png" alt="change_flash_map_in_otaheader.png"/>
</div>
</li>
</ul>
<center><div id="figure_3_9"><b>Figure 3-9 Change Flash Map in OTA Header</b></div></center><h4><a class="anchor" id="FLASH_Layout_Update_Patch_Content"></a>
3.4.4 update image content by flash map</h4>
<p>All fsbl/sys patch/rom patch/stack patch images are compiled with position independent attribute in the sdk package with this user guide in the sdk document, the image content can be updated by the tool update_images_by_flash_map.exe with the new flash map without recompiling.</p>
<p>It's suggested to copy related files into a new work directory.</p><ul>
<li>Collect the images(fsbl/sys patch/stack patch/rom patch) adjusted by flash layout adjusted according to bank. If there's only one bank, take the bank type as bank0.</li>
<li>Copy update_images_by_flash_map.exe under the sdk\tool\Gadgets\update_images_by_flash_map to the new work directory.</li>
<li>If the images are needed to be signed by rsa private key on the secure device, user can copy the rsa private key to the new work directory, and the rsa signature can be updated by the tool update_images_by_flash_map.exe. Of course, all images can be updated the rsa signature by the resign tool under sdk\tool\Gadgets\resign_tool.<br />
</li>
</ul>
<p>Run the command to update the images by bank,specify the bank type by "--bank_type 0" or "--bank_type 1", specify the out directory through "-o out_directory_path" and specify the new flash_map.ini by "--flash_map_ini". Use "-d update_images_path" to update the images under the directory of update_images_path, and use "-f update_image_path" to update the specified image file.</p>
<p>Take bank0 images as example, user can update image content for bank0 with new flash_map.ini by the following command line.<br />
</p><ul>
<li>Update images in bank0 under the directory as <a href="#figure_3_10">Figure 3-10</a>.<br />
 &ensp;&ensp;&ensp;&ensp;<em>update_images_by_flash_map.exe --flash_map_ini NEW_FLASH_MAP_INI_PATH -d UPDATE_IMG_DIR_FOR_BAMK0 --bank_type 0 -o OUT_DIRECTORY</em><br />
</li>
</ul>
<div class="image">
<img src="update_images_by_flash_map_bank0.png" alt="update_images_by_flash_map_bank0.png" width="1000px" height="679px"/>
</div>
 <center><div id="figure_3_10"><b>Figure 3-10 update bank0 images under the directory by flash map</b></div></center><ul>
<li>Update the specified single image in bank0 as <a href="#figure_3_11">Figure 3-11</a>.<br />
 &ensp;&ensp;&ensp;&ensp;<em>update_images_by_flash_map.exe --flash_map_ini NEW_FLASH_MAP_INI_PATH -f UPDATE_IMG_FILE_PATH --bank_type 0 -o OUT_DIRECTORY</em><br />
</li>
</ul>
<div class="image">
<img src="update_single_image_by_flash_map_bank0.png" alt="update_single_image_by_flash_map_bank0.png" width="1000px" height="626px"/>
</div>
 <center><div id="figure_3_11"><b>Figure 3-11 update bank0 single image by flash map</b></div></center><p>For bank1 images, use "--bank_type 1" in the command line:<br />
</p>
<ul>
<li>Update images in bank1 under the directory as <a href="#figure_3_12">Figure 3-12</a>. <br />
 &ensp;&ensp;&ensp;&ensp;<em>update_images_by_flash_map.exe --flash_map_ini NEW_FLASH_MAP_INI_PATH -d UPDATE_IMG_DIR_FOR_BAMK1 --bank_type 1 -o OUT_DIRECTORY</em><br />
</li>
</ul>
<div class="image">
<img src="update_images_by_flash_map_bank1.png" alt="update_images_by_flash_map_bank1.png" width="1000px" height="682px"/>
</div>
 <center><div id="figure_3_12"><b>Figure 3-12 update bank1 images under the directory by flash map</b></div></center><ul>
<li>Update the specified single image in bank1 as <a href="#figure_3_13">Figure 3-13</a>. <br />
 &ensp;&ensp;&ensp;&ensp;<em>update_images_by_flash_map.exe --flash_map_ini NEW_FLASH_MAP_INI_PATH -f UPDATE_IMG_FILE_PATH --bank_type 1 -o OUT_DIRECTORY</em></li>
</ul>
<div class="image">
<img src="update_single_image_by_flash_map_bank1.png" alt="update_single_image_by_flash_map_bank1.png" width="1000px" height="627px"/>
</div>
 <center><div id="figure_3_13"><b>Figure 3-13 update bank1 single image by flash map</b></div></center><p> <br />
 </p>
<h4><a class="anchor" id="FLASH_Layout_Update_APP"></a>
3.4.5 recompile app image</h4>
<p>If the image layout for app is changed, app image should be recompiled.</p><ul>
<li>Copy the new flash_map.h and flash_map.ini to sdk\bin\flash_map_config to replace the old one.</li>
<li>Recompile the app project to generate an app image with the new flash layout.</li>
</ul>
<h4><a class="anchor" id="FLASH_Layout_Download_Images"></a>
3.4.6 download images with new flash layout</h4>
<p>The flash layout modification would take effect after downloading the images into flash using MPPGTool with new flash_map.ini. Please pay attention to the flash_map.ini setting and bank type setting on the UI. For secure device, please pay attention to the image resign operation.</p>
<h3><a class="anchor" id="FLASH_Layout_Generate"></a>
3.5 Generate ext image command line</h3>
<p>prepend_header.exe and md5.exe under sdk\tool\Gadgets will be used.</p>
<ol type="1">
<li><p class="startli">Use prepend_header.exe to add the image header for ext image payload ext_imageN.bin. <br />
 The output file name is the same as the input file name ext_imageN.bin. <br />
 ext image0: prepend_header.exe /ext_image0 ext_image0.bin /ic_type IC_TYPE <br />
 ext image1: prepend_header.exe /ext_image1 ext_image1.bin /ic_type IC_TYPE <br />
 ext image2: prepend_header.exe /ext_image2 ext_image2.bin /ic_type IC_TYPE <br />
 ext image3: prepend_header.exe /ext_image3 ext_image3.bin /ic_type IC_TYPE</p>
<p class="startli">IC_TYPE should be specified according to the ic type, optional 87x3E, 87x3D. <br />
</p>
</li>
<li><p class="startli">Add mp header for ext image through mp.ini. <br />
 The output file name will append "_MP" after the input file name ext_imageN_MP.bin. </p><div class="fragment"><div class="line">; This is a config file mp.ini used by prepend_header tool to generate MP header <span class="keywordflow">for</span> a given image.</div><div class="line">; </div><div class="line">; The following sections are mandatory: BinID, Version, PartNumber.</div><div class="line">; </div><div class="line">; Note that MP header is a 512 bytes fixed data area, pay attention to the <span class="keywordtype">long</span> strings you have</div><div class="line">; written and ensure they are not out of bound of the header.</div><div class="line"></div><div class="line"></div><div class="line">[MandatoryInfo]</div><div class="line"></div><div class="line">; Image type of current binary file.</div><div class="line">BinID=ID_EXT_IMAGE1</div><div class="line"></div><div class="line">; Version of current binary file. Range: 0.0.0.0 ~ 255.255.255.255</div><div class="line">Version=1.0.0.0</div><div class="line"></div><div class="line">; Part number of current image, ASCII type, 32 bytes maximum.</div><div class="line">PartNumber=RTL87x3E</div><div class="line"></div><div class="line"></div><div class="line">[OptionalInfo]</div><div class="line"></div><div class="line">; Optional. Fill the required version number in specific field <span class="keywordflow">if</span> specific image is needed. </div><div class="line">; Item will be ignored <span class="keywordflow">if</span> the format of the value is wrong or the value does not exist.</div><div class="line">DependOnSocvConfig      =</div><div class="line">DependOnOemConfig       =</div><div class="line">DependOnFactoryMp       =</div><div class="line">DependOnFsbl            =</div><div class="line">DependOnOtaHeader       =</div><div class="line">DependOnPatch           =</div><div class="line">DependOnApp             =</div><div class="line">DependOnAppData         =</div><div class="line">DependOnAppDataTone     =</div><div class="line">DependOnAppDataVp       =</div><div class="line">DependOnAppDspParam     =</div><div class="line">DependOnDspSys          =</div><div class="line">DependOnDspPatch        =</div><div class="line">DependOnDspScenario1    =</div><div class="line">DependOnDspScenario2    =</div><div class="line"></div><div class="line">; Optional ASCII type comment string, 255 bytes maximum.</div><div class="line">Comment=</div><div class="line"></div><div class="line">; Optional ASCII type author information string, 255 bytes maximum.</div><div class="line">Author=</div><div class="line"></div><div class="line">; Optional ASCII type date and time string, 255 bytes maximum.</div><div class="line">Date=</div><div class="line"></div><div class="line">; Optional bin header format revision.</div><div class="line">Revision=0x01</div></div><!-- fragment --><p class="startli">BinID for ext image in the mp.ini are defined as follows, please set the BinID according to the image type. See <a href="#table_3_1">Table 3-1</a>.</p>
</li>
</ol>
<center><div id="table_3_1"><b>Table 3-1 The BinID of ext image type</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">ext image type  </th><th class="markdownTableHeadCenter">BinID in mp.ini   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">ext_image0  </td><td class="markdownTableBodyCenter">ID_EXT_IMAGE0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">ext_image1  </td><td class="markdownTableBodyCenter">ID_EXT_IMAGE1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">ext_image2  </td><td class="markdownTableBodyCenter">ID_EXT_IMAGE2   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">ext_image3  </td><td class="markdownTableBodyCenter">ID_EXT_IMAGE3   </td></tr>
</table>
<p>add mp header command lines:</p>
<p>ext image0: prepend_header.exe /ext_image0 ext_image0.bin /mp_ini mp_ext_img0.ini /ic_type IC_TYPE <br />
 ext image1: prepend_header.exe /ext_image1 ext_image1.bin /mp_ini mp_ext_img1.ini /ic_type IC_TYPE <br />
 ext image2: prepend_header.exe /ext_image2 ext_image2.bin /mp_ini mp_ext_img2.ini /ic_type IC_TYPE <br />
 ext image3: prepend_header.exe /ext_image3 ext_image3.bin /mp_ini mp_ext_img3.ini /ic_type IC_TYPE <br />
 IC_TYPE should be specified according to the ic type, optional 87x3E, 87x3D. <br />
</p>
<ol type="1">
<li>Add md5 data in the image file name for ext_imageN_MP.bin. <br />
 The output file name will be ext_imageN_MP-MD5Number.bin. <br />
 md5.exe ext_imageN_MP.bin</li>
</ol>
<div style="page-break-after: always;"></div><h2><a class="anchor" id="Flash_Section"></a>
4  Section Usage</h2>
<p>Functions are placed on flash by default. Section is provided for users to move them to the ram area.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define FLASH_HEADER     __attribute__((section(&quot;.flash.header&quot;)))     __attribute__((used))</span></div><div class="line"><span class="preprocessor">#define FLASH_HEADER_EXT __attribute__((section(&quot;.flash.header_ext&quot;))) __attribute__((used))</span></div><div class="line"><span class="preprocessor">#define RAM_TEXT_SECTION __attribute__((section(&quot;.ram_text&quot;)))</span></div><div class="line"><span class="preprocessor">#define SHM_DATA_SECTION __attribute__((section(&quot;.shm.data&quot;)))</span></div><div class="line"><span class="preprocessor">#define ISR_TEXT_SECTION __attribute__((section(&quot;.isr.text&quot;))) </span><span class="comment">/*not very urgent isr*/</span><span class="preprocessor"></span></div></div><!-- fragment --><ul>
<li><b>FLASH_HEADER &amp; FLASH_HEADER_EXT</b><ul>
<li>FLASH_HEADER &amp; FLASH_HEADER_EXT are provided for image header.</li>
</ul>
</li>
</ul>
<div class="fragment"><div class="line"><a class="code" href="group___s_e_c_t_i_o_n___exported___macros.html#ga46d243a0b4193e5c20f5eb289e2e1b01">FLASH_HEADER</a> <span class="keyword">const</span> <a class="code" href="union___i_m_g___h_e_a_d_e_r___f_o_r_m_a_t.html">T_IMG_HEADER_FORMAT</a> <a class="code" href="group___s_y_s_t_e_m___i_n_i_t___exported___variables.html#gabcaafd2d1b6e831c49a22ac3723ce00a">img_header</a> =</div><div class="line">{</div><div class="line">    ...</div><div class="line">}</div></div><!-- fragment --><ul>
<li><b>RAM_TEXT_SECTION</b><ul>
<li>Functions with the RAM_TEXT_SECTION prefix will be placed in Ram.</li>
</ul>
</li>
</ul>
<div class="fragment"><div class="line"><a class="code" href="group___s_e_c_t_i_o_n___exported___macros.html#ga501017c9d06ffea48e92d5ed3757b9f5">RAM_TEXT_SECTION</a> <span class="keywordtype">bool</span> <a class="code" href="group___a_p_p___i_o___m_s_g.html#ga88a966ae202533d382e23ae22b27b819">app_io_msg_send</a>(<a class="code" href="struct_t___i_o___m_s_g.html">T_IO_MSG</a> *io_msg)</div><div class="line">{</div><div class="line">    <a class="code" href="group___a_p_p___m_s_g___exported___types.html#gae013f504d288fa3c19ec0f1af745975c">T_EVENT_TYPE</a> <span class="keyword">event</span> = <a class="code" href="group___a_p_p___m_s_g___exported___types.html#ggae013f504d288fa3c19ec0f1af745975ca54fa1d4504aab64b0e290572ad56a13e">EVENT_IO_TO_APP</a>;</div><div class="line">    <span class="keywordtype">bool</span> ret = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group___o_s__87x3d___message.html#gaaa510b44bebf45ba68bd83820dfc6456">os_msg_send</a>(<a class="code" href="group___a_p_p___m_a_i_n___exported___variables.html#gae608acf4da9aeedaf885f18e8b91eefc">audio_io_queue_handle</a>, io_msg, 0) == <span class="keyword">true</span>)</div><div class="line">    {</div><div class="line">        ret = <a class="code" href="group___o_s__87x3d___message.html#gaaa510b44bebf45ba68bd83820dfc6456">os_msg_send</a>(<a class="code" href="group___a_p_p___m_a_i_n___exported___variables.html#ga1dc336635d2a407d06df2101d4208c43">audio_evt_queue_handle</a>, &amp;event, 0);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (ret == <span class="keyword">false</span>)</div><div class="line">    {</div><div class="line">        <a class="code" href="group__x3d___t_r_a_c_e.html#gafa1ccb896a7868ea9562a638c550f8b2">APP_PRINT_ERROR3</a>(<span class="stringliteral">&quot;app_io_msg_send failed, type = %x, subtype = %x, param = %x&quot;</span>,</div><div class="line">                         io_msg-&gt;<a class="code" href="struct_t___i_o___m_s_g.html#acb5cfd209ba75c853d03f701e7f91679">type</a>, io_msg-&gt;<a class="code" href="struct_t___i_o___m_s_g.html#ac5d9ab8403fb9ca24facc32b821dd53b">subtype</a>, io_msg-&gt;<a class="code" href="struct_t___i_o___m_s_g.html#ac3cb856d7e1befacacda7d89dbaabd13">u</a>.<a class="code" href="struct_t___i_o___m_s_g.html#aba18f3d521fde3af39c58b809a9c7ef0">param</a>);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> ret;</div><div class="line">}</div></div><!-- fragment --><ul>
<li><b>SHM_DATA_SECTION</b><ul>
<li>Functions with the SHM_DATA_SECTION prefix will be placed in DSP share memory. Please make sure DSP Share memory is ready first.</li>
</ul>
</li>
</ul>
<div class="fragment"><div class="line"><a class="code" href="group___s_e_c_t_i_o_n___exported___macros.html#gaff9eb852d59dea718525a5dc4e0cda1d">SHM_DATA_SECTION</a> uint8_t name_buf[NAME_BUF_SIZE];</div></div><!-- fragment --><ul>
<li><b>ISR_TEXT_SECTION</b><ul>
<li>ISR functions need to place on RAM. Because if the flash is erasing, XIP would run away. Then a hard fault will appear. ISR_TEXT_SECTION is provided for the user to run XIP in ISR. But there is a limit: user should make sure that the ISR handler has added this Prefix.</li>
</ul>
</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">static</span> <a class="code" href="group___s_e_c_t_i_o_n___exported___macros.html#gaf901ecfe15c401262a5dfd752a0b0287">ISR_TEXT_SECTION</a> <span class="keywordtype">void</span> GPIOA0_Handler(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    imp_gpio_handler(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#gac485358099728ddae050db37924dd6b7">GPIOA</a>, 0, <a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#gad4d43f8748b542bce39e18790f845ecc">BIT0</a>, hal_gpio_sw_context.<a class="code" href="structt__gpio__state.html#acca0f99fefee26805c0dbe4117578be3">gpio_a0_callback</a>);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <a class="code" href="group___s_e_c_t_i_o_n___exported___macros.html#gaf901ecfe15c401262a5dfd752a0b0287">ISR_TEXT_SECTION</a> <span class="keywordtype">void</span> imp_gpio_handler(<a class="code" href="struct_g_p_i_o___type_def.html">GPIO_TypeDef</a> *GPIOx, uint8_t gpio_num,</div><div class="line">                                              uint32_t gpio_pin,</div><div class="line">                                              <a class="code" href="group__x3d___h_a_l___g_p_i_o___h__.html#ga41447790d1c5e017bdfcaf6b9b93f1e7">P_GPIO_CBACK</a> callback)</div><div class="line">{</div><div class="line">    <a class="code" href="group___g_p_i_o___exported___functions.html#ga6cfce4a61b6395f9409f92dd9559c80c">GPIOx_ClearINTPendingBit</a>(GPIOx, gpio_pin);</div><div class="line">    <span class="keywordflow">if</span> (callback)</div><div class="line">    {</div><div class="line">        callback(hal_gpio_sw_context.<a class="code" href="structt__gpio__state.html#ab706f9e7941d0bb6e37ebd62aa87ee19">context</a>[gpio_num]);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        <a class="code" href="group__x3_e___t_r_a_c_e___e_x_p_o_r_t_e_d___m_a_c_r_o_s.html#ga13345c6eca202e52ee45089dbc0dfb2d">IO_PRINT_ERROR1</a>(<span class="stringliteral">&quot;empty isr callback for gpioa%u&quot;</span>, gpio_num);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p> If users add ISR_TEXT_SECTION in GPIOA0_Handler() above, an XIP code like (hal_gpio_sw_context.gpio_a0_callback) could be used. And if the ram is enough, users could put the ISR_TEXT_SECTION to ram in the .sct file without modifying any code.</p>
<p>Put functions with ISR_TEXT_SECTION prefix on Flash: </p><div class="fragment"><div class="line">    FLASH_TEXT +0;</div><div class="line">    {</div><div class="line">        startup_rtl87x3e.o (<a class="code" href="group__x3e___r_t_l876x___exported__types.html#gga89136caac2e14c55151f527ac02daaffa589b7d94a3d91d145720e2fed0eb3a05">RESET</a>, +First)</div><div class="line"><span class="preprocessor">#if (FEATURE_RAM_CODE == 0)</span></div><div class="line">        * (+RO)</div><div class="line">#endif</div><div class="line">        * (.isr.text)</div><div class="line">    }</div></div><!-- fragment --><p>Move functions with ISR_TEXT_SECTION prefix to RAM: </p><div class="fragment"><div class="line">    RAM_TEXT APP_BUFFER_ON_ADR APP_BUFFER_ON_SIZE</div><div class="line">    {</div><div class="line"><span class="preprocessor">#if FEATURE_RAM_CODE</span></div><div class="line">        .ANY (+RO)</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">        * (.ram_text)</div><div class="line">        * (.isr.text)</div><div class="line">    }</div></div><!-- fragment --><div style="page-break-after: always;"></div><h2><a class="anchor" id="FTL"></a>
5  Flash Transport Layer</h2>
<p>flash transport layer(FTL) is used as an abstraction layer for the user to read&amp;write data on flash. The location of FTL POOL in flash can be found in FLASH_LAYOUT.</p>
<p>The purpose of FTL is to make it simpler to change the data stored in Flash:</p>
<p>Every time the user wants to change the data on flash, the flash needs to be erased first. If flash is modified frequently, a lot of time will be wasted on erasing. FTL replaces the physical address with the logical address to access flash. FTL records data and its logical address on flash. If a user wants to modify the data, FTL writes a new record rather than modifying the old record. In this way, users do not need to erase flash. And when the FTL detects that there is not enough space to write a new record, it will clear some expired records. This process is called Garbage Collection.</p>
<p>So FTL is designed for lightweight dynamical parameter storage, heavyweight and read-only data should not use it.</p>
<p>FTL uses modules to distinguish different data. FTL has a default module to ensure basic functionality. Users can save data in the default module, or apply for a new module.</p>
<h3><a class="anchor" id="FTL_DEFAULT_MODULE"></a>
5.1  Default FTL Module</h3>
<p>The data in the default module can be divided into the following regions. FTL layout is shown in <a href="#figure_5_1">Figure 5-1</a>:</p>
<div class="image">
<img src="ftl_layout.jpg" alt="ftl_layout.jpg"/>
</div>
 <center><div id="figure_5_1"><b>Figure 5-1 Default FTL module Layout</b></div></center><ul>
<li><b>Local stack information storage space</b><ul>
<li>range: 0x0000 - 0x003b</li>
<li>This region is used to store local stack information including device name, device appearance, and lock IRK. Please refer to GAPStorage_Stack for more information.</li>
</ul>
</li>
<li><b>Legacy key storage space</b><ul>
<li>range: 0x003c - (0x50 + max_legacy_paired_device*24 - 1)</li>
<li>This region is used to store legacy key information. Please refer to GAPStorage_LegacyKey for more information.</li>
<li>max_legacy_paired_device: It can be configured by MCU Configure Tool, and the default value is 8.</li>
</ul>
</li>
<li><b>LE key storage space</b><ul>
<li>range: (0x50 + max_legacy_paired_device*24) - (0x50 + max_legacy_paired_device*24 + 0x14 + max_le_paired_device*(148 + 4*gatt_server_ccc_bits_count) - 1)</li>
<li>This region is used to store LE key information. Please refer to GAPStorage_LeKey for more information.</li>
<li>max_le_paired_device: It can be configured by MCU Configure Tool, and the default value is 4.</li>
<li>gatt_server_ccc_bits_count: It can be configured by MCU Configure Tool, and the default value is 16.</li>
</ul>
</li>
<li><b>Reserved space</b><ul>
<li>range: (0x50 + max_legacy_paired_device*24 + 0x14 + max_le_paired_device*(148 + 4*gatt_server_ccc_bits_count)) - 0xA17</li>
<li>This region is reserved space. Because the variables max_legacy_paired_device and max_le_paired_device are configurable, this region can be used to expand Legacy key storage space and LE key storage space.</li>
<li>When variables max_legacy_paired_device and max_le_paired_device are determined, this region can be used by APP.</li>
</ul>
</li>
<li><b>ftl module info space</b><ul>
<li>range: 0x0A18 - 0x0A5B</li>
<li>This region records the FTL ext module's info.</li>
</ul>
</li>
<li><b>GFPS finder space</b><ul>
<li>range: 0x0A5C - 0x0A8B</li>
<li>This region can be used by APP to store GFPS Finder information.</li>
</ul>
</li>
<li><b>GFPS storage space</b><ul>
<li>range: 0x0A8C - 0x0BFF</li>
<li>This region can be used by APP to store GFPS information.</li>
</ul>
</li>
<li><b>APP storage space</b><ul>
<li>range: 0x0C00 - the maximum size of the default FTL module</li>
<li>This region can be used by APP to store information.</li>
</ul>
</li>
</ul>
<p>The maximum size of the default module should be set by the interface: ftl_pool_init(). An easy way to calculate the flash area size is (logical_size * 2). FTL uses mapping_table to save time, default FTL module takes nearly (logical_size / 2) sram.</p>
<h3><a class="anchor" id="FTL_DEFAULT_API"></a>
5.2 FTL APIs of default FTL module</h3>
<p><a class="el" href="group___f_t_l___exported___functions.html#ga3ae0735707865433b9b0ff50b4628c27" title="Save specified value to specified FTL offset. ">ftl_save_to_storage()</a> function is used by APP to save data to Default FTL Module. <br />
 <a class="el" href="group___f_t_l___exported___functions.html#gaf35f66810c9df2c952c880474168b15e" title="Load specified FTL offset parameter to specified buffer. ">ftl_load_from_storage()</a> function is used by APP to load data from Default FTL Module. The offset can be used starting from 0x0C00 when APP use <a class="el" href="group___f_t_l___exported___functions.html#ga3ae0735707865433b9b0ff50b4628c27" title="Save specified value to specified FTL offset. ">ftl_save_to_storage()</a> and <a class="el" href="group___f_t_l___exported___functions.html#gaf35f66810c9df2c952c880474168b15e" title="Load specified FTL offset parameter to specified buffer. ">ftl_load_from_storage()</a>.</p>
<p>Notice: The offset and the size in <a class="el" href="group___f_t_l___exported___functions.html#ga3ae0735707865433b9b0ff50b4628c27" title="Save specified value to specified FTL offset. ">ftl_save_to_storage()</a>&amp; <a class="el" href="group___f_t_l___exported___functions.html#gaf35f66810c9df2c952c880474168b15e" title="Load specified FTL offset parameter to specified buffer. ">ftl_load_from_storage()</a> must be 4 Bytes aligned.</p>
<p>A brief demo: </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group___a_p_p___c_f_g___exported___functions.html#ga8a648b1d65f86eb42348e019c459d418">app_cfg_load</a>(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    ...</div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group___a_p_p___c_f_g___exported___types.html#ga0063edee2b4c1c981d2db26ef6ff820a">app_cfg_nv</a>.<a class="code" href="group___a_p_p___c_f_g.html#ga4163c81b558e653253a3e61a7f32e7e1">hdr</a>.<a class="code" href="group___a_p_p___c_f_g.html#gaaa1124737e74fa03841425d44bcaf99e">sync_word</a> != DATA_SYNC_WORD)</div><div class="line">    {</div><div class="line">        <span class="comment">//Load factory reset bit first when mppgtool factory reset</span></div><div class="line">        <span class="keywordflow">if</span> (<a class="code" href="group___a_p_p___c_f_g___exported___types.html#ga0063edee2b4c1c981d2db26ef6ff820a">app_cfg_nv</a>.<a class="code" href="group___a_p_p___c_f_g.html#ga4163c81b558e653253a3e61a7f32e7e1">hdr</a>.<a class="code" href="group___a_p_p___c_f_g.html#gaebb70c2aab3407a9f05334c47131a43b">length</a> == 0)</div><div class="line">        {</div><div class="line">            <a class="code" href="group___f_t_l___exported___functions.html#gaf35f66810c9df2c952c880474168b15e">ftl_load_from_storage</a>(&amp;<a class="code" href="group___a_p_p___c_f_g___exported___types.html#ga0063edee2b4c1c981d2db26ef6ff820a">app_cfg_nv</a>.<a class="code" href="group___a_p_p___c_f_g.html#gadb4b5fb4b6109b3b4ecb2914e44c1dd7">eq_idx_anc_mode_record</a>, APP_RW_DATA_ADDR + FACTORY_RESET_OFFSET,</div><div class="line">                                  4);</div><div class="line">        }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">       <a class="code" href="group___a_p_p___c_f_g___exported___functions.html#gacec57652e8e2274156160bccc34f736a">app_cfg_reset</a>();</div><div class="line">    }</div><div class="line">    ...</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">uint32_t <a class="code" href="group___a_p_p___c_f_g___exported___functions.html#gab297c89769dd5a96e5d0e10c194869bc">app_cfg_store</a>(<span class="keywordtype">void</span> *pdata, uint16_t size)</div><div class="line">{</div><div class="line">...</div><div class="line"></div><div class="line">   <span class="keywordflow">return</span> <a class="code" href="group___f_t_l___exported___functions.html#ga3ae0735707865433b9b0ff50b4628c27">ftl_save_to_storage</a>(pdata, offset + APP_RW_DATA_ADDR, size);</div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="FTL_MODULE"></a>
5.3 How to add a FTL module</h3>
<p>FTL pool support up to 7 modules. The default FTL module takes up one.</p>
<p>Use <a class="el" href="group___f_t_l___exported___functions.html#gaa786e9ab7d03f6a73466c15a169704d6" title="Init an ext FTL module. ">ftl_init_module()</a> to malloc a new FTL module. The malloc_size is a logical size.</p>
<p>Before adding a new FTL module. Please make sure the flash size of the FTL POOL is big enough: if (((block_len + 4) % 8) == 0), new module takes up (malloc_size / block_len *(block_len + 4)) flash area. otherwise takes up (malloc_size / block_len *(block_len + 8)) flash area. And the mapping_table for this new FTL module takes (malloc_size / block_len * 2) sram.</p>
<p><b>Notice:</b></p><ul>
<li>1.The first 4Bytes of module_name should be unique.</li>
<li>2.block_len must be an integer multiple of 4 and cannot exceed 128.</li>
</ul>
<p>More info can be found in <a class="el" href="group___f_t_l___exported___functions.html#gaa786e9ab7d03f6a73466c15a169704d6" title="Init an ext FTL module. ">ftl_init_module()</a>.</p>
<p>Ext FTL module use <a class="el" href="group___f_t_l___exported___functions.html#ga0bf96895e5144147114fae9db1e0de97" title="Save specified value to FTL module. ">ftl_save_to_module()</a> / <a class="el" href="group___f_t_l___exported___functions.html#ga1f2d03f20aac227d7b2d603e632e8a7b" title="Load specified FTL module offset parameter to specified buffer. ">ftl_load_from_module()</a> to save/load data. The block_len in <a class="el" href="group___f_t_l___exported___functions.html#gaa786e9ab7d03f6a73466c15a169704d6" title="Init an ext FTL module. ">ftl_init_module()</a> is the smallest unit for reading and writing data in the current FTL module. Application may need additional operation about the read/write data if necessary.</p>
<p>Demo:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define EQ_EXT_FTL_PARTITION_NAME &quot;EQ_FTL&quot;</span></div><div class="line"><span class="preprocessor">#define EQ_SIZE     (0x2800)</span></div><div class="line"><span class="preprocessor">#define EQ_EXT_FTL_BLOCK_LEN     68</span></div><div class="line"></div><div class="line">int32_t eq_ext_ftl_partition_init(<span class="keyword">const</span> <a class="code" href="structt__storage__partition__info.html">T_STORAGE_PARTITION_INFO</a> *info)</div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="group___f_t_l___exported___functions.html#gaa786e9ab7d03f6a73466c15a169704d6">ftl_init_module</a>(EQ_EXT_FTL_PARTITION_NAME, EQ_SIZE, EQ_EXT_FTL_BLOCK_LEN);</div><div class="line">}</div><div class="line"></div><div class="line">int32_t eq_ext_ftl_partition_write(<span class="keyword">const</span> <a class="code" href="structt__storage__partition__info.html">T_STORAGE_PARTITION_INFO</a> *info, uint32_t offset,</div><div class="line">                                   uint32_t len, <span class="keywordtype">void</span> *buf)</div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="group___f_t_l___exported___functions.html#ga0bf96895e5144147114fae9db1e0de97">ftl_save_to_module</a>(EQ_EXT_FTL_PARTITION_NAME, (<span class="keywordtype">void</span> *)buf, offset, len);</div><div class="line">}</div><div class="line"></div><div class="line">int32_t eq_ext_ftl_partition_read(<span class="keyword">const</span> <a class="code" href="structt__storage__partition__info.html">T_STORAGE_PARTITION_INFO</a> *info, uint32_t offset,</div><div class="line">                                  uint32_t len, <span class="keywordtype">void</span> *buf)</div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="group___f_t_l___exported___functions.html#ga1f2d03f20aac227d7b2d603e632e8a7b">ftl_load_from_module</a>(EQ_EXT_FTL_PARTITION_NAME, (<span class="keywordtype">void</span> *)buf, offset, len);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> eq_ext_ftl_storage_init(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="structt__storage__partition__info.html">T_STORAGE_PARTITION_INFO</a> eq_partitions[] =</div><div class="line">    {</div><div class="line">        {</div><div class="line">            .<a class="code" href="structt__storage__partition__info.html#afcd1706c9144e6d6eee6127661ae3be2">name</a> = EQ_EXT_FTL_PARTITION_NAME,</div><div class="line">            .address = <a class="code" href="group___platform___types___exported___macros.html#ga070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>,</div><div class="line">            .size = <a class="code" href="group___platform___types___exported___macros.html#ga070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>,</div><div class="line">            .perm = <a class="code" href="group___h_a_l__87x3d___s_t_o_r_a_g_e___exported___macros.html#gaa34660629b424e52e148116f3cafa299">STORAGE_PERMISSION_READ</a> | <a class="code" href="group___h_a_l__87x3d___s_t_o_r_a_g_e___exported___macros.html#ga2d67ab7693fef8f3768649f2e68264f3">STORAGE_PERMISSION_WRITE</a>,</div><div class="line">            .media_type = <a class="code" href="group___h_a_l__87x3d___t___s_t_o_r_a_g_e___m_e_d_i_a___t_y_p_e.html#gga5ddb11e52f457c5ccb4449831c407c23a6e56b55f6960fb52b78299829889295b">STORAGE_MEDIA_TYPE_NOR</a>,</div><div class="line">            .content_type = <a class="code" href="group___h_a_l__87x3e___t___s_t_o_r_a_g_e___c_o_n_t_e_n_t___t_y_p_e.html#gga20aad0cde558bdee722b004b038359a3aa88fcd8508dec2422b438cfca4c2879b">STORAGE_CONTENT_TYPE_RW_DATA</a>,</div><div class="line">            .init = eq_ext_ftl_partition_init,</div><div class="line">            .read = eq_ext_ftl_partition_read,</div><div class="line">            .write = eq_ext_ftl_partition_write,</div><div class="line">            .erase = <a class="code" href="group___platform___types___exported___macros.html#ga070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>,</div><div class="line">            .async_read = <a class="code" href="group___platform___types___exported___macros.html#ga070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>,</div><div class="line">            .async_write = <a class="code" href="group___platform___types___exported___macros.html#ga070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>,</div><div class="line">            .async_erase = <a class="code" href="group___platform___types___exported___macros.html#ga070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>,</div><div class="line">        },</div><div class="line">    };</div><div class="line"></div><div class="line">    <a class="code" href="group___h_a_l__87x3d___storage___access___exported___functions.html#ga580418db850170faebc902971009da5b">storage_partition_init</a>(eq_partitions, <span class="keyword">sizeof</span>(eq_partitions) / <span class="keyword">sizeof</span>(eq_partitions[0]));</div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="FTL_POOL"></a>
5.4 FTL POOL</h3>
<p>All FTL modules save data in the same flash area(FTL POOL), which can be found in flash_map.h App uses the flash_map.h to define FTL pool info. The user can modify it directly, or use the FlashMapGenerator Tool. So the address and size of the FTL pool are determined by APP and cannot be modified by any other bins or tools.</p>
<p>In principle, the new FTL POOL must include all areas of the old FTL POOL. Otherwise, FTL data would be lost. In these conditions, users need to do Factory Reset.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define FTL_ADDR                        0x021F9000</span></div><div class="line"><span class="preprocessor">#define FTL_SIZE                        0x00007000  //28K Bytes</span></div></div><!-- fragment --><h4><a class="anchor" id="FTL_SIZE_CHANGE"></a>
5.4.1  How to estimate the min flash size of FTL POOL</h4>
<ul>
<li><b>garbage collection</b><ul>
<li>use 8K to do GC</li>
</ul>
</li>
<li><b>default FTL module</b><ul>
<li>takes up (logical_size * 2) flash area</li>
</ul>
</li>
<li><b>ext FTL module</b><ul>
<li>takes up (logical_size / block_len *(block_len + (block_len % 8)? 8: 4)) flash area</li>
</ul>
</li>
</ul>
<p>The size of the FTL POOL should be larger than the total size above. And must be 4K align.</p>
<h3><a class="anchor" id="FTL_CACHE"></a>
5.5 FTL cache</h3>
<p>FTL has a cache. The user could open the cache by the interface <a class="el" href="group___f_t_l___exported___functions.html#ga1c281588e96e7a2926fae109c162149f" title="Init FTL cache and set FTL cache enable. ">ftl_cache_init()</a>. And the param in <a class="el" href="group___f_t_l___exported___functions.html#ga1c281588e96e7a2926fae109c162149f" title="Init FTL cache and set FTL cache enable. ">ftl_cache_init()</a> is the size of the cache.</p>
<p>After enabling this cache, FTL saves data in the cache area when there is not enough space to write a new record.</p>
<ul>
<li><b>Advantages:</b><ul>
<li>reduce current write's time cost If there is no space for a new record, FTL needs to do GC. GC call flash write&amp;erase operation, this cost at least 50ms+. So if the current flow is time sensitive, it is suggested to open the cache.</li>
</ul>
</li>
<li><b>Disadvantages:</b><ul>
<li>data loss in an abnormal case Because data is in the cache, not on flash, this data will be lost if power is lost or an abnormal reboot happens.</li>
</ul>
</li>
</ul>
<div style="page-break-after: always;"></div><h2><a class="anchor" id="FLASH_External"></a>
6  External Flash</h2>
<p>Besides the MCM flash embedded in the SoC, most of the Realtek BT SoC would also support additional external flash if the desired Flash size is larger than the embedded one.</p>
<p>The chapter will take RTL8773D as an example to introduce it from the architecture perspective to the application level when the SDK user wants to add more flashes into the system.</p>
<p><b>Note:</b> The material in this chapter is captured from the latest RTL8773D document for external customers, but this may subject to change. So please refer to the latest ones in case any changes are made.</p>
<h3><a class="anchor" id="EXT_FLASH_System_Arch"></a>
6.1 System Arch</h3>
<p>The system architecture of 87X3D is shown in <a href="#figure_6_1">Figure 6-1</a>.</p>
<div class="image">
<img src="system_arch_87x3d.png" alt="system_arch_87x3d.png"/>
</div>
 <center><div id="figure_6_1"><b>Figure 6-1 System Arch of RTL87X3D</b></div></center><p>Picture above is captured from the the system overview of RTL8773D in the data sheet, and there you can clearly tell that SPIC0 is reserved for the MCM flash and there are still 3 SPICs left for external storage connections.</p>
<h3><a class="anchor" id="EXT_FLASH_SPIC"></a>
6.2 SPIC</h3>
<p>SPIC is designed to transmit/receive data to/from SPI flash memories. Usually to operate on the flash, the user has to set/read registers and transmit serial data to the flash, and the registers would vary on different flashes from different vendors.</p>
<p>As mentioned in the data sheet, the default priority order among all these SPICs is SPIC3&gt;SPIC2&gt;SPIC1. And in the demo code, we by default use SPIC3 for external flash connections as SPIC3 is better for high speed application which requires up to 80MHz and with larger address space up to 256MB.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#if F_APP_EXT_FLASH_SUPPORT</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">bool</span> ext_flash_init(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="group__x3d___f_m_c___exported___flash___functions.html#ga8cfb4142b9ee0b4e26265b45d2af0e39">fmc_flash_nor_init</a>(FMC_FLASH_NOR_IDX3);</div><div class="line">}</div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><h3><a class="anchor" id="EXT_FLASH_pinmux"></a>
6.3 Pinmux</h3>
<p>Pins for these SPICs are predefined and can not be changed. So once any SPIC is assigned to any external storage usage, the corresponding pins have to be reserved and connected to the external storage. Here is the pinmux setting for SPIC3, and if you want to use any SPIC other than SPIC3, please refer to the datasheet for its pre-allocated pinmux.</p>
<p>All these pins would be automatically initialized to these specified pinmux once the flash is initialized as the <a href="#table_6_1">Table 6-1</a>.</p>
<center><div id="table_6_1"><b>Table 6-1 Pinmux for external flash</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Pin Name  </th><th class="markdownTableHeadNone">Function   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">P3_2  </td><td class="markdownTableBodyNone">SPIC3_CLK (master only)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">P3_3  </td><td class="markdownTableBodyNone">SPIC3_CSN (master only)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">P3_4  </td><td class="markdownTableBodyNone">SPIC3_SIO0 (master 4 bit mode)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">P3_5  </td><td class="markdownTableBodyNone">SPIC3_SIO1 (master 4 bit mode)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">P3_6  </td><td class="markdownTableBodyNone">SPIC3_SIO2 (master 4 bit mode)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">P3_7  </td><td class="markdownTableBodyNone">SPIC3_SIO3 (master 4 bit mode)   </td></tr>
</table>
<p><b>Note:</b> All these pins are in VDDIO3, so make sure VDDIO3 is powered.</p>
<h3><a class="anchor" id="FLASH_ADDR"></a>
6.4 Flash Address</h3>
<p>Once the external storage connects to the SoC via SPIC, the flash address would be allocated, and here is flash space allocated for each SPIC:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define FMC_MAIN0_ADDR                                      (0x02000000) //for spic0</span></div><div class="line"><span class="preprocessor">#define FMC_MAIN0_UNCACHEABLE_ADDR                          (0x04000000)</span></div><div class="line"><span class="preprocessor">#define FMC_MAIN1_ADDR                                      (0x06000000) //for spic1</span></div><div class="line"><span class="preprocessor">#define FMC_MAIN1_UNCACHEABLE_ADDR                          (0x06000000)</span></div><div class="line"><span class="preprocessor">#define FMC_MAIN2_ADDR                                      (0x08000000) //for spic2</span></div><div class="line"><span class="preprocessor">#define FMC_MAIN2_UNCACHEABLE_ADDR                          (0x08000000)</span></div><div class="line"><span class="preprocessor">#define FMC_MAIN3_ADDR                                      (0x10000000) //for spic3</span></div><div class="line"><span class="preprocessor">#define FMC_MAIN3_UNCACHEABLE_ADDR                          (0x10000000)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define FMC_MAIN0_SIZE                                      ( 32 * 1024 * 1024)</span></div><div class="line"><span class="preprocessor">#define FMC_MAIN1_SIZE                                      ( 32 * 1024 * 1024)</span></div><div class="line"><span class="preprocessor">#define FMC_MAIN2_SIZE                                      (  8 * 1024 * 1024)</span></div><div class="line"><span class="preprocessor">#define FMC_MAIN3_SIZE                                      (256 * 1024 * 1024)</span></div></div><!-- fragment --><p>As you can tell from the definition above, we have cache address and non-cache address for each SPIC, but they are the same except SPIC0. So it means only SPIC0 has cache enabled for the MCM flash and for now none of the external storage has the cache.</p>
<p>Flash address also could help specify which SPIC you want to access. Here are the explaination with the example code:</p>
<ol type="1">
<li>read access MCM flash via cache which would be more efficient if cache is hit <div class="fragment"><div class="line"><a class="code" href="group__x3d___f_m_c___exported___flash___functions.html#ga3374cd4db74d705f4fa380cbb199ea4b">fmc_flash_nor_read</a>(<a class="code" href="group___a_p_p___o_t_a___s_e_r_v_i_c_e___exported___macros.html#gac26073df5f43e66012c32a95bce4526b">FMC_MAIN0_ADDR</a> + 0x1000, buffer, 0x1000)</div></div><!-- fragment --></li>
<li>write access MCM flash without cache <div class="fragment"><div class="line"><a class="code" href="group__x3d___f_m_c___exported___flash___functions.html#gaf838c4108c71f7fe6a132b1c8c344b6e">fmc_flash_nor_write</a>(<a class="code" href="group___a_p_p___o_t_a___s_e_r_v_i_c_e___exported___macros.html#gad502dce3e8a6d5e008f9930941724679">FMC_MAIN0_UNCACHEABLE_ADDR</a> + 0x1000, buffer, 0x1000)</div></div><!-- fragment --></li>
<li>read access SPIC3 flash <div class="fragment"><div class="line"><a class="code" href="group__x3d___f_m_c___exported___flash___functions.html#ga3374cd4db74d705f4fa380cbb199ea4b">fmc_flash_nor_read</a>(FMC_MAIN3_ADDR + 0x1000, buffer, 0x1000)</div></div><!-- fragment --></li>
</ol>
<p><b>Note:</b></p><ol type="1">
<li>Whether it supports cache in other BT SoC series, and how it supports cache, please refer to their datasheet</li>
<li>Cache is not available when access other SPICs</li>
<li>DMA could be used as well to access flash to reduce the CPU loading</li>
</ol>
<h3><a class="anchor" id="EXT_FLASH_Conclusion"></a>
6.5 Conclusion</h3>
<p>To summarize, to support external flash, you can</p>
<ol type="1">
<li>Reserve SPIC pre-allocate pins</li>
<li>Call initialize API above</li>
<li>Call flash API with specified address which is in SPIC3 arrange to access external flash </li>
</ol>
</div></div><!-- contents -->

<HR SIZE=5>
<font size="3" color="black">Copyright(c) 2020, <a href=" http://www.realtek.com.tw/"><font size="3" color="#6FB7B7"><b>Realtek Semiconductor Corporation</b></font></a>. All rights reserved.</font> 

<!-- HTML header for doxygen 1.8.14-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BT AUDIO SDK: OS Extern Exported Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="customdoxygen.css" rel="stylesheet" type="text/css" />
<link href="my_customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="bbpro-h55px.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">BT AUDIO SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,true,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">OS Extern Exported Functions<div class="ingroups"><a class="el" href="group___h_a_l__87x3e___o_s___e_x_t.html">OS Extern</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga21041ca33568bee9619baefcb23f4d42"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l__87x3e___o_s___e_x_t___exported___functions.html#ga21041ca33568bee9619baefcb23f4d42">monitor_memory_and_timer</a> (uint16_t heap_and_timer_monitor_timer_timeout_s)</td></tr>
<tr class="memdesc:ga21041ca33568bee9619baefcb23f4d42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an OS timer to monitor free heap and OS timer.  <a href="#ga21041ca33568bee9619baefcb23f4d42">More...</a><br /></td></tr>
<tr class="separator:ga21041ca33568bee9619baefcb23f4d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fefe47403c300c9aca703d4fcbb02d7"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l__87x3e___o_s___e_x_t___exported___functions.html#ga1fefe47403c300c9aca703d4fcbb02d7">os_timer_handle_get</a> (uint8_t id)</td></tr>
<tr class="memdesc:ga1fefe47403c300c9aca703d4fcbb02d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get OS timer handle with timer id.  <a href="#ga1fefe47403c300c9aca703d4fcbb02d7">More...</a><br /></td></tr>
<tr class="separator:ga1fefe47403c300c9aca703d4fcbb02d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae31c6f640fa09f1ca87e1e027386b8a5"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l__87x3e___o_s___e_x_t___exported___functions.html#gae31c6f640fa09f1ca87e1e027386b8a5">os_timer_index_get</a> (void *timer)</td></tr>
<tr class="memdesc:gae31c6f640fa09f1ca87e1e027386b8a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get timer index with timer handle.  <a href="#gae31c6f640fa09f1ca87e1e027386b8a5">More...</a><br /></td></tr>
<tr class="separator:gae31c6f640fa09f1ca87e1e027386b8a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade19a9cf4274fbb0366eb883e4ff3d8a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l__87x3e___o_s___e_x_t___exported___functions.html#gade19a9cf4274fbb0366eb883e4ff3d8a">os_timer_state_get</a> (void **pp_handle, uint32_t *p_timer_state)</td></tr>
<tr class="memdesc:gade19a9cf4274fbb0366eb883e4ff3d8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get OS timer state.  <a href="#gade19a9cf4274fbb0366eb883e4ff3d8a">More...</a><br /></td></tr>
<tr class="separator:gade19a9cf4274fbb0366eb883e4ff3d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3c05aa2339862ba0edaeb099771299c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l__87x3e___o_s___e_x_t___exported___functions.html#gaf3c05aa2339862ba0edaeb099771299c">os_portyield_from_isr</a> (<a class="el" href="group___h_a_l__87x3e___o_s___e_x_t___exported___variables.html#ga46fb21e00ae0729d7515c0fbf2269796">BaseType_t</a> x)</td></tr>
<tr class="memdesc:gaf3c05aa2339862ba0edaeb099771299c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do context switch or not before the interrupt exits.  <a href="#gaf3c05aa2339862ba0edaeb099771299c">More...</a><br /></td></tr>
<tr class="separator:gaf3c05aa2339862ba0edaeb099771299c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4444b6b1a4e8d7db156e6aaccdf66fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___h_a_l__87x3e___o_s___e_x_t___exported___variables.html#ga46fb21e00ae0729d7515c0fbf2269796">BaseType_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l__87x3e___o_s___e_x_t___exported___functions.html#gaf4444b6b1a4e8d7db156e6aaccdf66fa">xTimerPendFunctionCallFromISR</a> (<a class="el" href="group___h_a_l__87x3e___o_s___e_x_t___exported___variables.html#gaf6e8e2be58df2be9f9bb808fcdc51622">PendedFunction_t</a> xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, <a class="el" href="group___h_a_l__87x3e___o_s___e_x_t___exported___variables.html#ga46fb21e00ae0729d7515c0fbf2269796">BaseType_t</a> *pxHigherPriorityTaskWoken)</td></tr>
<tr class="memdesc:gaf4444b6b1a4e8d7db156e6aaccdf66fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used from application interrupt service routines to defer the execution of a function to the RTOS daemon task.  <a href="#gaf4444b6b1a4e8d7db156e6aaccdf66fa">More...</a><br /></td></tr>
<tr class="separator:gaf4444b6b1a4e8d7db156e6aaccdf66fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga21041ca33568bee9619baefcb23f4d42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21041ca33568bee9619baefcb23f4d42">&#9670;&nbsp;</a></span>monitor_memory_and_timer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void monitor_memory_and_timer </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>heap_and_timer_monitor_timer_timeout_s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an OS timer to monitor free heap and OS timer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout_s</td><td>Timeout time in seconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="ga1fefe47403c300c9aca703d4fcbb02d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1fefe47403c300c9aca703d4fcbb02d7">&#9670;&nbsp;</a></span>os_timer_handle_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* os_timer_handle_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get OS timer handle with timer id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Timer id. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="gae31c6f640fa09f1ca87e1e027386b8a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae31c6f640fa09f1ca87e1e027386b8a5">&#9670;&nbsp;</a></span>os_timer_index_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t os_timer_index_get </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>timer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get timer index with timer handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timer</td><td>Point to OS timer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>timer id </dd></dl>

</div>
</div>
<a id="gade19a9cf4274fbb0366eb883e4ff3d8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade19a9cf4274fbb0366eb883e4ff3d8a">&#9670;&nbsp;</a></span>os_timer_state_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool os_timer_state_get </td>
          <td>(</td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>pp_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>p_timer_state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get OS timer state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pp_handle</td><td>Point to timer handle. </td></tr>
    <tr><td class="paramname">p_timer_state</td><td>Timer state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Timer state. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The timer is activate. </td></tr>
    <tr><td class="paramname">false</td><td>The timer is inactive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf3c05aa2339862ba0edaeb099771299c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3c05aa2339862ba0edaeb099771299c">&#9670;&nbsp;</a></span>os_portyield_from_isr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void os_portyield_from_isr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_a_l__87x3e___o_s___e_x_t___exported___variables.html#ga46fb21e00ae0729d7515c0fbf2269796">BaseType_t</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do context switch or not before the interrupt exits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>If x is set to 0 , a context switch should be requested before the interrupt exits, otherwise it should not be requested. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="gaf4444b6b1a4e8d7db156e6aaccdf66fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4444b6b1a4e8d7db156e6aaccdf66fa">&#9670;&nbsp;</a></span>xTimerPendFunctionCallFromISR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___h_a_l__87x3e___o_s___e_x_t___exported___variables.html#ga46fb21e00ae0729d7515c0fbf2269796">BaseType_t</a> xTimerPendFunctionCallFromISR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_a_l__87x3e___o_s___e_x_t___exported___variables.html#gaf6e8e2be58df2be9f9bb808fcdc51622">PendedFunction_t</a>&#160;</td>
          <td class="paramname"><em>xFunctionToPend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pvParameter1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ulParameter2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___h_a_l__87x3e___o_s___e_x_t___exported___variables.html#ga46fb21e00ae0729d7515c0fbf2269796">BaseType_t</a> *&#160;</td>
          <td class="paramname"><em>pxHigherPriorityTaskWoken</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used from application interrupt service routines to defer the execution of a function to the RTOS daemon task. </p>
<p>Used from application interrupt service routines to defer the execution of a function to the RTOS daemon task (the timer service task, hence this function is implemented in timers.c and is prefixed with 'Timer').</p>
<p>Ideally an interrupt service routine (ISR) is kept as short as possible, but sometimes an ISR either has a lot of processing to do, or needs to perform processing that is not deterministic. In these cases <a class="el" href="group___h_a_l__87x3e___o_s___e_x_t___exported___functions.html#gaf4444b6b1a4e8d7db156e6aaccdf66fa" title="Used from application interrupt service routines to defer the execution of a function to the RTOS dae...">xTimerPendFunctionCallFromISR()</a> can be used to defer processing of a function to the RTOS daemon task.</p>
<p>A mechanism is provided that allows the interrupt to return directly to the task that will subsequently execute the pended callback function. This allows the callback function to execute contiguously in time with the interrupt - just as if the callback had executed in the interrupt itself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xFunctionToPend</td><td>The function to execute from the timer service/ daemon task. The function must conform to the PendedFunction_t prototype.</td></tr>
    <tr><td class="paramname">pvParameter1</td><td>The value of the callback function's first parameter. The parameter has a void * type to allow it to be used to pass any type. For example, unsigned longs can be cast to a void *, or the void * can be used to point to a structure.</td></tr>
    <tr><td class="paramname">ulParameter2</td><td>The value of the callback function's second parameter.</td></tr>
    <tr><td class="paramname">pxHigherPriorityTaskWoken</td><td>As mentioned above, calling this function will result in a message being sent to the timer daemon task. If the priority of the timer daemon task is higher than the priority of the currently running task (the task the interrupt interrupted) then *pxHigherPriorityTaskWoken will be set to true within <a class="el" href="group___h_a_l__87x3e___o_s___e_x_t___exported___functions.html#gaf4444b6b1a4e8d7db156e6aaccdf66fa" title="Used from application interrupt service routines to defer the execution of a function to the RTOS dae...">xTimerPendFunctionCallFromISR()</a>, indicating that a context switch should be requested before the interrupt exits. For that reason *pxHigherPriorityTaskWoken must be initialised to false. See the example code below.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the message is successfully sent to the timer daemon task.</dd></dl>
<p>Example usage: </p><pre class="fragment">*
*  // The callback function that will execute in the context of the daemon task.
*  // Note callback functions must all use this same prototype.
*  void vProcessInterface( void *pvParameter1, uint32_t ulParameter2 )
*  {
*      BaseType_t xInterfaceToService;
*
*      // The interface that requires servicing is passed in the second
*      // parameter.  The first parameter is not used in this case.
*      xInterfaceToService = ( BaseType_t ) ulParameter2;
*
*      // ...Perform the processing here...
*  }
*
*  // An ISR that receives data packets from multiple interfaces
*  void vAnISR( void )
*  {
*      BaseType_t xInterfaceToService, xHigherPriorityTaskWoken;
*
*      // Query the hardware to determine which interface needs processing.
*      xInterfaceToService = prvCheckInterfaces();
*
*      // The actual processing is to be deferred to a task.  Request the
*      // vProcessInterface() callback function is executed, passing in the
*      // number of the interface that needs processing.  The interface to
*      // service is passed in the second parameter.  The first parameter is
*      // not used in this case.
*      xHigherPriorityTaskWoken = pdFALSE;
*      xTimerPendFunctionCallFromISR( vProcessInterface, NULL, ( uint32_t ) xInterfaceToService, &amp;xHigherPriorityTaskWoken );
*
*      // If xHigherPriorityTaskWoken is now set to pdTRUE then a context
*      // switch should be requested.  The macro used is port specific and will
*      // be either portYIELD_FROM_ISR() or portEND_SWITCHING_ISR() - refer to
*      // the documentation page for the port being used.
*      portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
*
*  }
* </pre> 
</div>
</div>
</div><!-- contents -->

<HR SIZE=5>
<font size="3" color="black">Copyright(c) 2020, <a href=" http://www.realtek.com.tw/"><font size="3" color="#6FB7B7"><b>Realtek Semiconductor Corporation</b></font></a>. All rights reserved.</font> 

<!-- HTML header for doxygen 1.8.14-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BT AUDIO SDK: $title</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="customdoxygen.css" rel="stylesheet" type="text/css" />
<link href="my_customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="bbpro-h55px.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">BT AUDIO SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,true,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="contents">
<div class="textblock"><p><br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
 </p>
<h1><a class="anchor" id="USB_SDK_Page"></a>
USB User Guide    </h1>
<p><br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
 </p><center><b>V1.1</b></center><p><br />
 </p><center><b>2023/12/05</b></center><div style="page-break-after: always;"></div><h2><a class="anchor" id="USB_SDK_REV"></a>
Revision History</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Version  </th><th class="markdownTableHeadCenter">Date  </th><th class="markdownTableHeadCenter">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">V1.0  </td><td class="markdownTableBodyCenter">2023/06/19  </td><td class="markdownTableBodyCenter">Stable Release   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">V1.1  </td><td class="markdownTableBodyCenter">2023/12/05  </td><td class="markdownTableBodyCenter">Add CDC and Mass Storage Driver   </td></tr>
</table>
<div style="page-break-after: always;"></div><h2>Contents</h2>
<ul>
<li><a class="el" href="_u_m021__u_s_b__u_s_e_r__g_u_i_d_e.html#USB_SDK_REV">Revision History</a></li>
<li><a class="el" href="_u_m021__u_s_b__u_s_e_r__g_u_i_d_e.html#USB_SDK_Figure_List">Figure List</a></li>
<li><a class="el" href="_u_m021__u_s_b__u_s_e_r__g_u_i_d_e.html#USB_SDK_Table_List">Table List</a></li>
<li><a class="el" href="_u_m021__u_s_b__u_s_e_r__g_u_i_d_e.html#USB_SDK_Glossary">Glossary</a></li>
<li><a class="el" href="_u_m021__u_s_b__u_s_e_r__g_u_i_d_e.html#USB_SDK_Intro">1 Introduction</a></li>
<li><a class="el" href="_u_m021__u_s_b__u_s_e_r__g_u_i_d_e.html#USB_SDK_MCU_Config">2 USB Configuration</a></li>
<li><a class="el" href="_u_m021__u_s_b__u_s_e_r__g_u_i_d_e.html#USB_SDK_Module">3 USB SDK</a><ul>
<li><a class="el" href="_u_m021__u_s_b__u_s_e_r__g_u_i_d_e.html#USB_SDK_Composite">3.1 USB Composite</a><ul>
<li><a class="el" href="_u_m021__u_s_b__u_s_e_r__g_u_i_d_e.html#USB_SDK_Interface">3.1.1 Interface Structure</a></li>
<li><a class="el" href="_u_m021__u_s_b__u_s_e_r__g_u_i_d_e.html#USB_SDK_Request">3.1.2 Request Handling</a></li>
</ul>
</li>
<li><a class="el" href="_u_m021__u_s_b__u_s_e_r__g_u_i_d_e.html#USB_SDK_Class">3.2 USB Class Driver</a><ul>
<li><a class="el" href="_u_m021__u_s_b__u_s_e_r__g_u_i_d_e.html#USB_SDK_Audio">3.2.1 USB Audio Driver</a></li>
<li><a class="el" href="_u_m021__u_s_b__u_s_e_r__g_u_i_d_e.html#USB_SDK_HID">3.2.2 USB HID Driver</a></li>
<li><a class="el" href="_u_m021__u_s_b__u_s_e_r__g_u_i_d_e.html#USB_SDK_MSC">3.2.3 USB MSC Driver</a></li>
<li><a class="el" href="_u_m021__u_s_b__u_s_e_r__g_u_i_d_e.html#USB_SDK_CDC">3.2.4 USB CDC driver</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="el" href="_u_m021__u_s_b__u_s_e_r__g_u_i_d_e.html#USB_SDK_Appendix">Appendix</a></li>
</ul>
<div style="page-break-after: always;"></div><h2><a class="anchor" id="USB_SDK_Table_List"></a>
Table List</h2>
<ul>
<li><a href="#table_3_1">Table 3-1 USB Modules Location</a></li>
</ul>
<div style="page-break-after: always;"></div><h2><a class="anchor" id="USB_SDK_Figure_List"></a>
Figure List</h2>
<ul>
<li><a href="#figure_2_1">Figure 2-1 Enable USB Audio and HID</a></li>
<li><a href="#figure_2_2">Figure 2-2 Enable Adaptor</a></li>
<li><a href="#figure_2_3">Figure 2-3 Allow Power On When Charging</a></li>
<li><a href="#figure_2_4">Figure 2-4 LDOUSB Setting</a></li>
<li><a href="#figure_3_1">Figure 3-1 Architecture of the USB SDK</a></li>
<li><a href="#figure_3_2">Figure 3-2 USB Composite Flow</a></li>
<li><a href="#figure_3_3">Figure 3-3 USB Request Types</a></li>
<li><a href="#figure_3_4">Figure 3-4 Structure of the USB Audio Class Driver</a></li>
<li><a href="#figure_3_5">Figure 3-5 Instance Interface List</a></li>
<li><a href="#figure_3_6">Figure 3-6 USB Audio Init Flow</a></li>
<li><a href="#figure_3_7">Figure 3-7 Structure of the USB HID Class</a></li>
<li><a href="#figure_3_8">Figure 3-8 Structure of the USB Mass Storage Class</a></li>
<li><a href="#figure_3_9">Figure 3-9 Structure of the USB Communication Device Class</a></li>
</ul>
<div style="page-break-after: always;"></div><h2><a class="anchor" id="USB_SDK_Glossary"></a>
Glossary</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Terms  </th><th class="markdownTableHeadCenter">Definitions   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">USB  </td><td class="markdownTableBodyCenter">Universal Serial Bus   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">UAC  </td><td class="markdownTableBodyCenter">USB Audio Class   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">HID  </td><td class="markdownTableBodyCenter">Human Interface Device   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">SDK  </td><td class="markdownTableBodyCenter">Software Development Kit   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">PC  </td><td class="markdownTableBodyCenter">Personal Computer   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">CFU  </td><td class="markdownTableBodyCenter">Component Firmware Update   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">API  </td><td class="markdownTableBodyCenter">Application Programming Interface   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">MIC  </td><td class="markdownTableBodyCenter">Microphone   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">HAL  </td><td class="markdownTableBodyCenter">Hardware Abstraction Layer   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">MSC  </td><td class="markdownTableBodyCenter">Mass Storage Class   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">CDC  </td><td class="markdownTableBodyCenter">Communications Device Class   </td></tr>
</table>
<div style="page-break-after: always;"></div><h2><a class="anchor" id="USB_SDK_Intro"></a>
1 Introduction</h2>
<p>The purpose of this document is to introduce USB configuration and give an overview of the USB SDK. USB SDK support multiple USB classes, such as USB audio, HID, MSC and CDC. This document gives a tutorial of USB configuration by MCU Config Tool. What's more, it would help you to be familiar with the architecture of the USB driver.<br />
</p>
<div style="page-break-after: always;"></div><h2><a class="anchor" id="USB_SDK_MCU_Config"></a>
2 USB Configuration</h2>
<p>The section elaborates configuration process by MCU Config Tool to make USB work. MCU Config Tool is provided in directory as illustrated below.<br />
 Firstly, enable USB audio and HID, and then choose USB speed, as illustrated in Figure 2-1.<br />
 </p><div class="image">
<img src="enable_usb_audio_and_hid.png" alt="enable_usb_audio_and_hid.png"/>
</div>
 <center><div id="figure_2_1"><b>Figure 2-1 Enable USB Audio and HID </b></div></center><p>Because USB start/stop is triggered by adaptor in/out, the second thing is to enable adaptor, as illustrated in Figure 2-2.<br />
 </p><div class="image">
<img src="enable_adaptor.png" alt="enable_adaptor.png"/>
</div>
 <center><div id="figure_2_2"><b>Figure 2-2 Enable Adaptor </b></div></center><p>In addition, choose "Allow" from "Allow power on function when charging" combobox, as illustrated in Figure 2-3.<br />
 </p><div class="image">
<img src="usb_enable_power_on_when_charging.png" alt="usb_enable_power_on_when_charging.png"/>
</div>
 <center><div id="figure_2_3"><b>Figure 2-3 Allow Power On When Charging </b></div></center><p>For RTL87X3D, in system configuration, LDOUSB should be set as 3.3V as Figure 2-4.<br />
 </p><div class="image">
<img src="LDOUSB.PNG" alt="LDOUSB.PNG"/>
</div>
 <center><div id="figure_2_4"><b>Figure 2-4 LDOUSB Setting </b></div></center><div style="page-break-after: always;"></div><h2><a class="anchor" id="USB_SDK_Module"></a>
3 USB SDK</h2>
<p>The architecture of the USB SDK is shown in Figure 3-1. <br />
 </p><div class="image">
<img src="architecture_of_the_USB_SDK.png" alt="architecture_of_the_USB_SDK.png"/>
</div>
 <center><div id="figure_3_1"><b>Figure 3-1 Architecture of the USB SDK </b></div></center><ul>
<li>USB HAL mainly provides hardware initialization and APIs for data transmission.</li>
<li>USB composite mainly deals with the standard requests defined in Chapter 9 of the USB specification<sup>[1]</sup>. This module does not deal with interface-related requests, but it passes interface requests to the corresponding function driver to process.</li>
<li>The function driver mainly handles requests defined by class specifications, and some interface-related standard requests.</li>
<li>The initialization process needs to be bottom-up, HAL-&gt;composite-&gt;function driver-&gt;instance.</li>
</ul>
<p>Table 3-1 lists the locations of USB modules introduced above. <br />
 </p><center><div id="table_3_1"><b>Table 3-1 USB Modules Location</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">USB modules  </th><th class="markdownTableHeadCenter">Location   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">USB HAL  </td><td class="markdownTableBodyCenter">/sdk/src/mcu/usb/hal/   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">USB composite  </td><td class="markdownTableBodyCenter">/sdk/src/mcu/usb/lib/composite/   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">function driver  </td><td class="markdownTableBodyCenter">/sdk/src/mcu/usb/lib/class/   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">function instance  </td><td class="markdownTableBodyCenter">/sdk/src/sample/application/usb/   </td></tr>
</table>
<p>Note that <b>application</b> in Function instance can be rws, dongle, and etc.</p>
<p>This section mainly introduces the USB SDK, namely composite and class driver. <br />
</p>
<h3><a class="anchor" id="USB_SDK_Composite"></a>
3.1 USB Composite</h3>
<p>The USB composite device defines the device descriptor and configuration descriptor, and handles and filters all the requests. The flow is shown in Figure 3-2.<br />
 </p><div class="image">
<img src="USB_composite_flow.png" alt="USB_composite_flow.png"/>
</div>
 <center><div id="figure_3_2"><b>Figure 3-2 USB Composite Flow </b></div></center><ul>
<li>Initialize the USB device descriptor and configuration descriptor. If the string index of the USB device descriptor or USB configuration descriptor is not zero, string must be added.</li>
<li>Add the interfaces of the specific class.</li>
<li>After USB enumerates success, USB requests transmitted by the PC must be handled.</li>
</ul>
<h4><a class="anchor" id="USB_SDK_Interface"></a>
3.1.1 Interface Structure</h4>
<p>The structure of the interface is as follows:<br />
 </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="struct__usb__interface.html">_usb_interface</a></div><div class="line">{</div><div class="line">    uint8_t <a class="code" href="struct__usb__interface.html#a870cea08902c43da80dbb78e0f290eb2">if_num</a>;    <span class="comment">// the number of the interface</span></div><div class="line">    <span class="keyword">struct </span><a class="code" href="structusb__descriptor__header.html">usb_descriptor_header</a> **<a class="code" href="struct__usb__interface.html#a5491117533b5aa9294a0587b4876787f">descs_fs</a>;    <span class="comment">// full speed descriptors</span></div><div class="line">    <span class="keyword">struct </span><a class="code" href="structusb__descriptor__header.html">usb_descriptor_header</a> **<a class="code" href="struct__usb__interface.html#a4f72ec96ac115c3b27419fe5307ce031">descs_hs</a>;    <span class="comment">// high speed descriptors</span></div><div class="line">    T_USB_UTILS_LIST <a class="code" href="struct__usb__interface.html#aa403d3be5686299dfe242519ad6a9d78">eps</a>;    <span class="comment">// a list of endpoints belonging to the interface.</span></div><div class="line"></div><div class="line">    <span class="comment">// callbacks for the interface to realize</span></div><div class="line">    int (*<a class="code" href="struct__usb__interface.html#a808ae9c0026ae9669c54cb9b66c62116">ctrl_request_proc</a>)(<span class="keyword">struct </span><a class="code" href="struct__usb__interface.html">_usb_interface</a> *interface, <a class="code" href="struct__usb__device__request.html">T_USB_DEVICE_REQUEST</a> *ctrl_request, <a class="code" href="struct__hal__usb__request__block.html">T_HAL_USB_REQUEST_BLOCK</a> *ctrl_urb);</div><div class="line">    int (*<a class="code" href="struct__usb__interface.html#a828bf113ca2732a95a95afe44e953c53">alt_get</a>)(<span class="keyword">struct </span><a class="code" href="struct__usb__interface.html">_usb_interface</a> *interface, <a class="code" href="struct__hal__usb__request__block.html">T_HAL_USB_REQUEST_BLOCK</a> *ctrl_urb);</div><div class="line">    int (*<a class="code" href="struct__usb__interface.html#afa599e11055cb3c66af72497c2df3004">alt_set</a>)(<span class="keyword">struct </span><a class="code" href="struct__usb__interface.html">_usb_interface</a> *interface, <a class="code" href="struct__hal__usb__request__block.html">T_HAL_USB_REQUEST_BLOCK</a> *ctrl_urb, uint8_t alt);</div><div class="line">    int (*<a class="code" href="struct__usb__interface.html#aae257ef7b0d61bc3e558e280f802667a">suspend</a>)(<span class="keyword">struct </span><a class="code" href="struct__usb__interface.html">_usb_interface</a> *interface);</div><div class="line">    int (*<a class="code" href="struct__usb__interface.html#a96b4319dea52348add4d3490ccb33aaa">resume</a>)(<span class="keyword">struct </span><a class="code" href="struct__usb__interface.html">_usb_interface</a> *interface);</div><div class="line">    int (*<a class="code" href="struct__usb__interface.html#a0d02fa7f8cfd719dd67f626e507ac4e6">create</a>)(<span class="keyword">struct </span><a class="code" href="struct__usb__interface.html">_usb_interface</a> *interface);</div><div class="line">    int (*<a class="code" href="struct__usb__interface.html#ad1e8c3d27f143b10cb8b5727eb41e9b8">release</a>)(<span class="keyword">struct </span><a class="code" href="struct__usb__interface.html">_usb_interface</a> *interface);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> *<a class="code" href="struct__usb__interface.html#a8b6505c37d4ff95854b8b00527e4d9fa">priv</a>;    <span class="comment">// different for different interfaces</span></div><div class="line">} <a class="code" href="group___u_s_b___composite.html#ga3da3516f4a8690ba8cf8deb95f33bf3a">T_USB_INTERFACE</a>;</div></div><!-- fragment --><h4><a class="anchor" id="USB_SDK_Request"></a>
3.1.2 Request Handling</h4>
<p>The USB request can be divided into several types. The request types are shown in Figure 3-3.<br />
 </p><div class="image">
<img src="USB_request_types.png" alt="USB_request_types.png"/>
</div>
 <center><div id="figure_3_3"><b>Figure 3-3 USB Request Types </b></div></center><p> USB command can be divided into standard, class and vendor command<sup>[1]</sup>. <br />
</p>
<ul>
<li>The standard commands can also be divided into several types. These commands are handled following the USB specification<sup>[1]</sup>.</li>
<li>The vendor command is designed according to specific requirements.</li>
<li>The class commands are divided into device, interface and endpoint. All class related commands will be processed in class-related files and will not be implemented in this module.</li>
</ul>
<p>If you want to develop based on this layer, please refer to <a class="el" href="group___u_s_b___composite.html">USB Composite</a> in API reference.</p>
<h3><a class="anchor" id="USB_SDK_Class"></a>
3.2 USB Class Driver</h3>
<p>The purpose of this section is to give an overview of the USB class drivers, namely USB audio driver, USB HID driver, USB MSC driver and USB CDC driver. Other classes will be implemented in the future.<br />
</p>
<h4><a class="anchor" id="USB_SDK_Audio"></a>
3.2.1 USB Audio Driver</h4>
<p>USB audio can be used for audio playback and recording.<br />
 USB audio driver support:<br />
</p><ul>
<li>UAC1.0 and UAC2.0</li>
<li>Multiple audio streaming can work together.</li>
<li>A single audio streaming contains multiple alternate settings.</li>
</ul>
<p>The structure of USB audio class is shown in Figure 3-4.<br />
 </p><div class="image">
<img src="structure_of_the_USB_audio_class_driver.png" alt="structure_of_the_USB_audio_class_driver.png"/>
</div>
 <center><div id="figure_3_4"><b>Figure 3-4 Structure of the USB Audio Class Driver </b></div></center><p>USB Audio consists of multiple interfaces, such as the control interface, the out streaming interface, and the in streaming interface, which are shown in Figure 3-5.<br />
 </p><div class="image">
<img src="instance_interface_list.png" alt="instance_interface_list.png"/>
</div>
 <center><div id="figure_3_5"><b>Figure 3-5 Instance Interface List </b></div></center><p>The usb audio init flow is shown in figure 3-6. </p><div class="image">
<img src="usb_audio_init_flow.png" alt="usb_audio_init_flow.png"/>
</div>
 <center><div id="figure_3_6"><b>Figure 3-6 USB Audio Init Flow </b></div></center><ul>
<li><b>usb_audio_driver_inst_alloc</b> will init a USB audio instance.</li>
<li>The audio interface list items are allocated by <b>usb_audio_driver_desc_register</b>. For the control interface, the control entity list will be initialized. For the streaming interface, the alternate setting with the different alternate value will be inserted into the alternate settings list. In addition to attributes, other related resources will also be initialized.</li>
<li><b>usb_audio_driver_ctrl_register</b> will register the control entity list in the control interface.</li>
<li><b>usb_audio_driver_attr_init</b> will register the attribute in the alternate setting in each streaming interface.</li>
<li><b>usb_audio_driver_cb_register</b> will register data transmission related callbacks.</li>
<li><b>usb_audio_driver_init</b> will add interfaces to USB composite.</li>
</ul>
<p>The structure of the driver is as follows:<br />
 </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>_usb_audio</div><div class="line">{</div><div class="line">    T_USB_UTILS_LIST insts;</div><div class="line">} T_USB_AUDIO;</div></div><!-- fragment --><p>The driver can contain multiple audio instances. The structure of the instance is as follows:<br />
 </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>_usb_audio_inst</div><div class="line">{</div><div class="line">    <span class="keyword">struct </span>_usb_audio_inst *p_next;</div><div class="line">    uint8_t uac_ver;    <span class="comment">// the USB audio class version</span></div><div class="line">    T_USB_UTILS_LIST if_list;    <span class="comment">// the interface list belonging to the instance</span></div><div class="line">    <a class="code" href="struct__usb__audio__driver__cbs.html">T_USB_AUDIO_DRIVER_CBS</a> cbs;    <span class="comment">//  callbacks from the app to start and stop audio track, and transmit data</span></div><div class="line"></div><div class="line">    <a class="code" href="struct__hal__usb__iso__request__block.html">T_HAL_USB_ISO_REQUEST_BLOCK</a> *iso_in_urb;    <span class="comment">// the USB isochronous request block for upstreaming</span></div><div class="line">    uint8_t iso_in_proc_interval;    <span class="comment">// the interval to process the isochronous packet</span></div><div class="line"></div><div class="line">    <a class="code" href="struct__hal__usb__iso__request__block.html">T_HAL_USB_ISO_REQUEST_BLOCK</a> *iso_out_urb;</div><div class="line">    uint8_t iso_out_proc_interval;</div><div class="line">    uint16_t iso_out_max_buf_size;    <span class="comment">// the maximum size of the data transfer</span></div><div class="line">    uint8_t *copy_buf;    <span class="comment">// store the received isochronous out data</span></div><div class="line">} T_USB_AUDIO_INST;</div></div><!-- fragment --><p>The structure of the list item in the if_list is as follows:<br />
 </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>_usb_audio_if</div><div class="line">{</div><div class="line">    <span class="keyword">struct </span>_usb_audio_if *p_next;</div><div class="line">    uint8_t dir;    <span class="comment">// the direction of the audio streaming interface(in/out)</span></div><div class="line">    uint8_t sub_class;    <span class="comment">// the subclass of the interface is control or streaming</span></div><div class="line">    uint8_t cur_alt;    <span class="comment">// the current alternate setting of the interface</span></div><div class="line"></div><div class="line">    <a class="code" href="struct__usb__interface.html">T_USB_INTERFACE</a> interface;    <span class="comment">// the interface structure in the USB composite</span></div><div class="line">    <span class="keyword">union</span></div><div class="line">    {</div><div class="line">        T_ALT_SETTINGS *alt_settings;    <span class="comment">// For streaming, alternate settings</span></div><div class="line">        T_USB_UTILS_LIST *ctrl_entity_list;    <span class="comment">// For control, control topology</span></div><div class="line">    } priv;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> *owner;</div><div class="line">} T_USB_AUDIO_IF;</div></div><!-- fragment --><p>For the control interface, the control topology is as follows:<br />
 </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="struct__usb__audio__driver__ctrl.html">_usb_audio_driver_ctrl</a></div><div class="line">{</div><div class="line">    uint8_t <a class="code" href="struct__usb__audio__driver__ctrl.html#a1d127017fb298b889f4ba24752d08b8e">type</a>;</div><div class="line">    <a class="code" href="struct__usb__audio__driver__ctrl__attr.html">T_USB_AUDIO_DRIVER_CTRL_ATTR</a> <a class="code" href="struct__usb__audio__driver__ctrl.html#a1f2937fc5183616a9ded738699cba856">attr</a>;</div><div class="line">    <a class="code" href="group___u_s_b___a_u_d_i_o___d_r_i_v_e_r.html#gaa1873d4ebbec7bad12cd30ceff086048">T_USB_AUDIO_CTRL_SET_FUNC</a> <span class="keyword">set</span>;</div><div class="line">    <a class="code" href="group___u_s_b___a_u_d_i_o___d_r_i_v_e_r.html#ga521a3a1c15a694dd30552b9ddabc29f1">T_USB_AUDIO_CTRL_GET_FUNC</a> <span class="keyword">get</span>;</div><div class="line">} <a class="code" href="group___u_s_b___a_u_d_i_o___d_r_i_v_e_r.html#ga6047ab1024a4856a296f4c037d01ef40">T_USB_AUDIO_DRIVER_CTRL</a>;</div><div class="line"></div><div class="line"><span class="preprocessor">#define T_USB_AUDIO_DRIVER_CTRL_ENTITY(id, num)    \</span></div><div class="line"><span class="preprocessor">    struct _usb_audio_driver_ctrl_entity##id             \</span></div><div class="line"><span class="preprocessor">    {                                                    \</span></div><div class="line"><span class="preprocessor">        uint8_t    entity_id;                           \</span></div><div class="line"><span class="preprocessor">        uint8_t    ctrl_num;                            \</span></div><div class="line"><span class="preprocessor">        T_USB_AUDIO_DRIVER_CTRL *ctrls[num];             \</span></div><div class="line"><span class="preprocessor">    }</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="struct__usb__audio__driver__ctrl__entity__hdr.html">_usb_audio_driver_ctrl_entity_hdr</a></div><div class="line">{</div><div class="line">    uint8_t    <a class="code" href="struct__usb__audio__driver__ctrl__entity__hdr.html#a8a6a9a23f3529b81e24d622f72af55b1">entity_id</a>;</div><div class="line">    uint8_t    <a class="code" href="struct__usb__audio__driver__ctrl__entity__hdr.html#ae2d20eab45ccb693813f5ed4c99308da">ctrl_num</a>;</div><div class="line">} <a class="code" href="group___u_s_b___a_u_d_i_o___d_r_i_v_e_r.html#ga085cb7c2e371a848ae20bc596dae1070">T_USB_AUDIO_DRIVER_CTRL_ENTITY_HDR</a>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>_control_entity_item</div><div class="line">{</div><div class="line">    <span class="keyword">struct </span>_control_entity_item *p_next;</div><div class="line">    <a class="code" href="struct__usb__audio__driver__ctrl__entity__hdr.html">T_USB_AUDIO_DRIVER_CTRL_ENTITY_HDR</a> *ctrl_entity;</div><div class="line">} T_CONTROL_ENTITY_ITEM;</div></div><!-- fragment --><p>For each control unit, the following points need to be implemented:<br />
</p><ul>
<li><b><a class="el" href="group___u_s_b___a_u_d_i_o___d_r_i_v_e_r.html#ga7609f33b0603fe650687d66a4155f8bc" title="USB Audio driver control per control entity   entity_id: id of entity defined in control interface...">T_USB_AUDIO_DRIVER_CTRL_ENTITY(id, num)</a></b>, where id is the unit id of the feature unit descriptor, and num indicates how many attributes have been controlled by the unit, such as the possibility that the feature unit may simultaneously control volume and mute.</li>
<li><b>T_USB_AUDIO_DRIVER_CTRL</b> controls a single attribute.</li>
</ul>
<p>For the streaming interface, the alternate setting list is as follows:<br />
 </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>_alt_setting</div><div class="line">{</div><div class="line">    <span class="keyword">struct </span>_alt_setting *p_next;</div><div class="line"></div><div class="line">    uint8_t value;    <span class="comment">// an alternate value</span></div><div class="line">    <a class="code" href="struct__usb__endpoint__descriptor.html">T_USB_ENDPOINT_DESC</a> *hs_ep_desc;    <span class="comment">// the high-speed endpoint descriptor</span></div><div class="line">    <a class="code" href="struct__usb__endpoint__descriptor.html">T_USB_ENDPOINT_DESC</a> *fs_ep_desc;    <span class="comment">// the full-speed endpoint descriptor</span></div><div class="line"></div><div class="line">    <a class="code" href="struct__usb__audio__driver__attr.html">T_USB_AUDIO_DRIVER_ATTR</a> attr;    <span class="comment">//audio streaming parameters in the current alternate setting,</span></div><div class="line">                                     <span class="comment">//such as sample rate, bit width, and channel number</span></div><div class="line">} T_ALT_SETTING;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>_alt_settings</div><div class="line">{</div><div class="line">    <span class="keyword">union</span></div><div class="line">    {</div><div class="line">        uint32_t data;</div><div class="line">        <span class="keyword">struct</span></div><div class="line">        {</div><div class="line">            uint32_t freq: 24;</div><div class="line">            uint32_t rsv: 8;</div><div class="line">        } uac2;</div><div class="line">    } cs;    <span class="comment">// a custom parameter for different UAC versions. For UAC 2.0, it indicates the current frequency.</span></div><div class="line">    <a class="code" href="struct__usb__ep.html">T_USB_EP</a> *ep;    <span class="comment">// the endpoints included in alternate settings (only one isochronous endpoint is supported at most)</span></div><div class="line">    T_ALT_SETTING    *cur;    <span class="comment">// the current alternate setting</span></div><div class="line">    T_USB_UTILS_LIST    list;    <span class="comment">// T_ALT_SETTING list</span></div><div class="line">    <span class="keywordtype">void</span> *owner;    <span class="comment">// the audio interface to which the T_ALT_SETTINGS belong</span></div><div class="line">} T_ALT_SETTINGS;</div></div><!-- fragment --><p>If you want to develop based on this layer, please refer to the <a class="el" href="group___u_s_b___a_u_d_i_o___d_r_i_v_e_r.html">USB AUDIO DRIVER</a>.<br />
</p>
<h4><a class="anchor" id="USB_SDK_HID"></a>
3.2.2 USB HID Driver</h4>
<p>The USB HID can be used for mouse, keyboard, CFU, etc.<br />
 USB HID driver support:<br />
</p><ul>
<li>multiple interfaces</li>
<li>each interface with multiple endpoints</li>
</ul>
<p>The structure of the USB HID class is shown in Figure 3-7. </p><div class="image">
<img src="structure_of_the_USB_HID_class.png" alt="structure_of_the_USB_HID_class.png"/>
</div>
 <center><div id="figure_3_7"><b>Figure 3-7 Structure of the USB HID Class </b></div></center><ul>
<li>Initializing an interface requires calling the function <b>usb_hid_driver_if_desc_register</b> to register the interface and its corresponding report descriptors, and then initialize the functions in the interface, and insert them into if_list in the T_USB_HID structure.</li>
<li><b>usb_hid_driver_cbs_register</b> can bind <b>set_report</b> and <b>get_report</b> callbacks to the interface. It can transmit data from the app through <b>set_report</b> and <b>get_report</b> requests.</li>
<li><b>usb_hid_driver_init</b> will add interfaces to USB composite.</li>
</ul>
<p>The structure of the driver is as follows:<br />
 </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>_usb_hid</div><div class="line">{</div><div class="line">    T_USB_UTILS_LIST if_list;</div><div class="line">} T_USB_HID;</div></div><!-- fragment --><p>The driver can contain multiple HID interfaces. The structure of the interface is as follows:<br />
 </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>_usb_hid_if</div><div class="line">{</div><div class="line">    <span class="keyword">struct </span>_usb_hid_if *p_next;</div><div class="line">    <a class="code" href="struct__usb__interface.html">T_USB_INTERFACE</a> intf;    <span class="comment">// the interface structure of USB composite</span></div><div class="line">    uint8_t cur_alt;    <span class="comment">// the current alternate value</span></div><div class="line">    <a class="code" href="struct__usb__hid__driver__cbs.html">T_USB_HID_DRIVER_CBS</a> cbs;    <span class="comment">// the get report and set report callbacks registered from the application.</span></div><div class="line">} T_USB_HID_IF;</div></div><!-- fragment --><p>If you want to develop based on this layer, please refer to <a class="el" href="group___u_s_b___h_i_d___d_r_i_v_e_r.html">USB HID DRIVER</a>.</p>
<h4><a class="anchor" id="USB_SDK_MSC"></a>
3.2.3 USB MSC Driver</h4>
<p>The USB mass storage can be used for USB flash disk. This driver only supports Bulk-Only Transport, and does not care which command set specification and storage medium are used.<br />
 The structure of the USB mass storage class is shown in Figure 3-8. </p><div class="image">
<img src="structure_of_the_USB_mass_storage_class.png" alt="structure_of_the_USB_mass_storage_class.png"/>
</div>
 <center><div id="figure_3_8"><b>Figure 3-8 Structure of the USB Mass Storage Class </b></div></center><p> The driver only include an interface with two bulk endpoints.</p><ul>
<li>Initializing an interface requires calling the function <b>usb_ms_driver_if_desc_register</b> to register the interface, and then initialize the functions in the interface.</li>
<li><b>usb_ms_driver_disk_register</b> can register disk-related operations. These callbacks can access sdcard.</li>
<li><b>usb_ms_driver_init</b> will add interfaces to USB composite.</li>
</ul>
<p>The structure of the driver is as follows:<br />
 </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>_usb_ms</div><div class="line">{</div><div class="line">    <a class="code" href="struct__usb__interface.html">T_USB_INTERFACE</a> intf;  <span class="comment">// the interface structure of USB composite</span></div><div class="line">    uint8_t cur_alt;  <span class="comment">// the current alternate value</span></div><div class="line">    <span class="keywordtype">void</span> *pipe_tx;  <span class="comment">// pipe handle of bulk in ep</span></div><div class="line">    <span class="keywordtype">void</span> *pipe_rx;  <span class="comment">// pipe handle of bulk out ep</span></div><div class="line">    uint32_t mtu_tx;  <span class="comment">// max transfer size of bulk in ep</span></div><div class="line">    uint32_t mtu_rx;  <span class="comment">// max transfer size of bulk out ep</span></div><div class="line">    <a class="code" href="struct__t__rx__cb.html">T_RX_CB</a> rx_cbs;  <span class="comment">// cbs to process CBW and data stage</span></div><div class="line">    uint32_t xfer_len; <span class="comment">// current transfer length</span></div><div class="line">    uint32_t remaining_len; <span class="comment">// data transfer length of PC want to recv or send in CBW stage</span></div><div class="line">    <a class="code" href="group___u_s_b___m_s___d_r_i_v_e_r.html#gadb1953e0ba6f3b3948fc19d0e390d04f">USB_MS_DRIVER_TX_COMPLETE</a> tx_complete;  <span class="comment">// complete callback of bulk in ep </span></div><div class="line">    <a class="code" href="struct__t__disk__driver.html">T_DISK_DRIVER</a> disk;  <span class="comment">// disk-related callbacks</span></div><div class="line">    <span class="keywordtype">int</span> cur_cbw_tag;  <span class="comment">// CSWTag of current CBW</span></div><div class="line">    T_USB_MS_STATUS ms_status; <span class="comment">// status of ms</span></div><div class="line"></div><div class="line">} T_USB_MS;</div></div><!-- fragment --><p>If you want to develop based on this layer, please refer to <a class="el" href="group___u_s_b___m_s___d_r_i_v_e_r.html">USB MS DRIVER</a>.</p>
<h4><a class="anchor" id="USB_SDK_CDC"></a>
3.2.4 USB CDC driver</h4>
<p>The This driver support virtual port com to communicate with computer. The driver completes data transmission through two bulk eps.<br />
 The structure of the USB mass storage class is shown in Figure 3-9. </p><div class="image">
<img src="structure_of_the_USB_communication_device_class.png" alt="structure_of_the_USB_communication_device_class.png"/>
</div>
 <center><div id="figure_3_9"><b>Figure 3-9 Structure of the USB Communication Device Class </b></div></center><ul>
<li>Initializing an interface requires calling the function <b>usb_cdc_driver_if_desc_register</b> to register the interface, and then initialize the functions in the interface, and insert them into if_list in the T_USB_CDC structure.</li>
<li><b>usb_cdc_driver_init</b> will add interfaces to USB composite.</li>
</ul>
<p>The structure of the driver is as follows:<br />
 </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>_usb_cdc</div><div class="line">{</div><div class="line">    T_USB_UTILS_LIST if_list;</div><div class="line">} T_USB_CDC;</div></div><!-- fragment --><p>The driver can contain two cdc interfaces. The structure of the interface is as follows:<br />
 </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>_usb_cdc_if</div><div class="line">{</div><div class="line">    <span class="keyword">struct </span>_usb_cdc_if *p_next;</div><div class="line">    <a class="code" href="struct__usb__interface.html">T_USB_INTERFACE</a> intf;  <span class="comment">// the interface structure of USB composite</span></div><div class="line">    uint8_t cur_alt;  <span class="comment">// the current alternate value</span></div><div class="line">} T_USB_CDC_IF;</div></div><!-- fragment --><p>If you want to develop based on this layer, please refer to <a class="el" href="group___u_s_b___c_d_c___d_r_i_v_e_r.html">USB CDC DRIVER</a>.</p>
<div style="page-break-after: always;"></div><h2><a class="anchor" id="USB_SDK_Appendix"></a>
Appendix</h2>
<p>[1] Universal Serial Bus (USB) Specification, Version 2.0 </p>
</div></div><!-- contents -->

<HR SIZE=5>
<font size="3" color="black">Copyright(c) 2020, <a href=" http://www.realtek.com.tw/"><font size="3" color="#6FB7B7"><b>Realtek Semiconductor Corporation</b></font></a>. All rights reserved.</font> 

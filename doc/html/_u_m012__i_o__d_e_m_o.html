<!-- HTML header for doxygen 1.8.14-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BT AUDIO SDK: $title</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="customdoxygen.css" rel="stylesheet" type="text/css" />
<link href="my_customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="bbpro-h55px.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">BT AUDIO SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,true,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="contents">
<div class="textblock"><p><br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
 </p>
<h1><a class="anchor" id="IO_Demo_App_Page"></a>
IO User Manual  </h1>
<p><br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
 </p><center><b>V1.10</b></center><p><br />
 </p><center><b>2023/12/18</b></center><div style="page-break-after: always;"></div><h2><a class="anchor" id="DemoIO_Rev"></a>
Revision History</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Version  </th><th class="markdownTableHeadCenter">Date  </th><th class="markdownTableHeadCenter">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">V1.0.0.1  </td><td class="markdownTableBodyCenter">2021/08/23  </td><td class="markdownTableBodyCenter">Stable release   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">V1.0.0.2  </td><td class="markdownTableBodyCenter">2023/03/31  </td><td class="markdownTableBodyCenter">Normal update   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">V1.0.0.3  </td><td class="markdownTableBodyCenter">2023/04/04  </td><td class="markdownTableBodyCenter">Normal update   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">V1.4  </td><td class="markdownTableBodyCenter">2023/05/25  </td><td class="markdownTableBodyCenter">Update the format   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">V1.5  </td><td class="markdownTableBodyCenter">2023/05/31  </td><td class="markdownTableBodyCenter">Add spi external flash   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">V1.6  </td><td class="markdownTableBodyCenter">2023/07/27  </td><td class="markdownTableBodyCenter">Add sdio_fs_demo   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">V1.7  </td><td class="markdownTableBodyCenter">2023/08/22  </td><td class="markdownTableBodyCenter">Normal update   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">V1.8  </td><td class="markdownTableBodyCenter">2023/11/09  </td><td class="markdownTableBodyCenter">Normal update   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">V1.9  </td><td class="markdownTableBodyCenter">2023/11/10  </td><td class="markdownTableBodyCenter">Add spi demo code   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">V1.10  </td><td class="markdownTableBodyCenter">2023/12/18  </td><td class="markdownTableBodyCenter">Update spi note and sdio demo   </td></tr>
</table>
<div style="page-break-after: always;"></div><h2>Contents</h2>
<ul>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#DemoIO_Rev">Revision History</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#DemoIO_Table_List">Table List</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#DemoIO_Figure_List">Figure List</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#DemoIO_Glossary">Glossary</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#Io_Demo_Overview">1 Overview</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#IO_Demo_Project">2 IO Demo Project</a><ul>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#IO_Demo_Project_Introduction">2.1 IO Demo Project Introduction</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#How_to_run_IO_DEMO">2.2 How to run IO DEMO</a></li>
</ul>
</li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#IO_Demo_App">3 IO Demo App</a><ul>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#IO_Demo_Sample_Code_File">3.1 IO Demo Sample Code File</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#IO_Demo_Source_Code_Overview">3.2 IO Demo Source Code Overview</a><ul>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#IO_Demo_APP_Description">3.2.1 IO_Demo APP Description</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#IO_Initialization_flow">3.2.2 IO Initialization flow</a><ul>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#IO_Demo_Clock_Configuration">3.2.2.1 Clock Configuration</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#IO_Demo_PINMUX_Configuration">3.2.2.2 PINMUX Configuration</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#IO_Demo_PAD_Configuration">3.2.2.3 PAD Configuration</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#IO_Demo_Interrupt_Configuration">3.2.2.4 Interrupt Configuration</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#IO_Demo_Disable_Peripheral">3.2.2.5 Disable Peripheral</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#PINMUX_PAD">4 PINMUX and PAD</a><ul>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#PAD_Demo_Code_Support_List">4.1 PAD Demo Code Support List</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#PINMUX_PAD_Function_Description">4.2 Function Description</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#PINMUX_PAD_Feature_List">4.3 PAD Feature List</a></li>
</ul>
</li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#GPIO">5 GPIO</a><ul>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#GPIO_Demo_Code_Support_List">5.1 GPIO Demo Code Support List</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#GPIO_Function_Description">5.2 Function Description</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#GPIO_Feature_List">5.3 Feature List</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#GPIO_Initialization_Flow">5.4 GPIO Initialization Flow</a><ul>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#GPIO_Input_Mode">5.4.1 Input Mode</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#GPIO_Output_Mode">5.4.2 Output Mode</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#GPIO_Interrupt_Mode">5.4.3 Interrupt Mode</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#TIM">6 TIMER and PWM</a><ul>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#TIM_Demo_Code_Support_List">6.1 TIMER and PWM Demo Code Support List</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#TIM_Function_Description">6.2 Function Description</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#TIM_Feature_List">6.3 Feature List</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#TIM_TIMER_Operation_Flow">6.4 TIMER Operation Flow</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#TIM_PWM_Operation_Flow">6.5 PWM Operation Flow</a></li>
</ul>
</li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#UART">7 UART</a><ul>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#UART_Demo_Code_Support_List">7.1 UART Demo Code Support List</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#UART_Function_Description">7.2 Function Description</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#UART_Feature_List">7.3 Feature List</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#UART_Data_Format">7.4 Data Format</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#UART_Parity_Check">7.5 Parity Check</a><ul>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#Odd_Parity">7.5.1 Odd Parity</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#Even_Parity">7.5.2 Even Parity</a></li>
</ul>
</li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#UART_Hardware_Flow_Control">7.6 Hardware Flow Control</a><ul>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#RTS_Flow_Control">7.6.1 RTS Flow Control</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#CTS_Flow_Control">7.6.2 CTS Flow Control</a></li>
</ul>
</li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#UART_Baud_Rate">7.7 Baud Rate</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#UART_Initialization_Flow">7.8 Initialization Flow</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#UART_Receive_Data_by_Interrupt_Mode">7.9 Receive Data by Interrupt Mode</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#UART_Send_Data">7.10 Send Data</a></li>
</ul>
</li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#GDMA">8 GDMA</a><ul>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#GDMA_Demo_Code_Support_List">8.1 GDMA Demo Code Support List</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#GDMA_Function_Description">8.2 Function Description</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#GDMA_Feature_List">8.3 Feature List</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#GDMA_Parameter_Significance">8.4 Parameter Significance</a><ul>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#GDMA_ChannelNum">8.4.1 GDMA_ChannelNum</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#GDMA_DIR">8.4.2 GDMA_DIR</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#GDMA_SourceInc">8.4.3 GDMA_SourceInc</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#GDMA_DestinationInc">8.4.4 GDMA_DestinationInc</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#GDMA_SourceDataSize">8.4.5 GDMA_SourceDataSize</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#GDMA_DestinationDataSize">8.4.6 GDMA_DestinationDataSize</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#GDMA_SourceMsize">8.4.7 GDMA_SourceMsize</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#GDMA_DestinationMsize">8.4.8 GDMA_DestinationMsize</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#GDMA_BufferSize">8.4.9 GDMA_BufferSize</a></li>
</ul>
</li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#GDMA_Waterlevel_Setting">8.5 Waterlevel Setting</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#GDMA_Single-Block_Transfer_Initialization_Flow">8.6 GDMA Single-Block Transfer Initialization Flow</a></li>
</ul>
</li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#I2C">9 I2C</a><ul>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#I2C_Demo_Code_Support_List">9.1 I2C Demo Code Support List</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#I2C_Function_Description">9.2 Function Description</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#I2C_Feature_List">9.3 Feature List</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#I2C_Transfer_Protocol">9.4 I2C Transfer Protocol</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#I2C_Master_Mode">9.5 Master Mode</a><ul>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#I2C_7-Bit_Addressing_Mode">9.5.1 7-Bit Addressing Mode</a><ul>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#I2C_7-Bit_Master_Write">9.5.1.1 Master Write</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#I2C_7-Bit_Master_Read">9.5.1.2 Master Read</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#I2C_7-Bit_Master_Repeat_Read">9.5.1.3 Master Repeat Read</a></li>
</ul>
</li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#I2C_10-Bit_Addressing_Mode">9.5.2 10-Bit Addressing Mode</a><ul>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#I2C_10-Bit_Master_Write">9.5.2.1 Master Write</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#I2C_10-Bit_Master_Read">9.5.2.2 Master Read</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#I2C_10-Bit_Master_Repeat_Read">9.5.2.3 Master Repeat Read</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#I2C_Master_Mode_Initialization_Flow">9.6 Master Mode Initialization Flow</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#I2C_Slave_Mode_Initialization_Flow">9.7 Slave Mode Initialization Flow</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#I2C_Master_Write">9.8 Master Write</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#I2C_Master_Repeat_Read">9.9 Master Repeat Read</a></li>
</ul>
</li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#SPI">10 SPI</a><ul>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#SPI_Demo_Code_Support_List">10.1 SPI Demo Code Support List</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#SPI_Function_Description">10.2 Function Description</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#SPI_Feature_List">10.3 Feature List</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#SPI_Communication_Sequence_Diagram">10.4 SPI Communication Sequence Diagram</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#SPI_Initialization_Flow">10.5 SPI Initialization Flow</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#SPI_External_Flash">10.6 SPI External Flash</a><ul>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#SPI_Hardware_Connection">10.6.1 Hardware Connection</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#External_Flash_Demo_Code">10.6.2 Demo Code</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#IR">11 IR</a><ul>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#IR_Demo_Code_Support_List">11.1 IR Demo Code Support List</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#IR_Function_Description">11.2 Function Description</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#IR_Feature_List">11.3 Feature List</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#IR_TX">11.4 IR TX</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#IR_TX_Operation_Flow">11.5 Send Data Operation Flow</a><ul>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#IR_TX_Initialization_Flow">11.5.1 IR Initialization Flow</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#IR_Send_Data_Operation_Flow">11.5.2 IR Send Data Operation Flow</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#IR_TX_Interrupt_Handle_Flow">11.5.3 IR Interrupt Handle Flow</a></li>
</ul>
</li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#IR_RX_Operation_Flow">11.6 Receive Data Operation Flow</a><ul>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#IR_RX_Initialization_Flow">11.6.1 IR Initialization Flow</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#IR_Receive_Data_Operation_Flow">11.6.2 IR Receive Data Operation Flow</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#IR_RX_Interrupt_Handle_Flow">11.6.3 IR Interrupt Handle Flow</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#RTC">12 RTC</a><ul>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#RTC_Demo_Code_Support_List">12.1 RTC Demo Code Support List</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#RTC_Function_Description">12.2 Function Description</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#RTC_Feature_List">12.3 Feature List</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#RTC_Comparator_Function_Operation_Flow">12.4 Comparator Function Operation Flow</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#RTC_Overflow_Function_Operation_Flow">12.5 Overflow Function Operation Flow</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#RTC_Tick_Function_Operation_Flow">12.6 Tick Function Operation Flow</a></li>
</ul>
</li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#LPC">13 LPC</a><ul>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#LPC_Demo_Code_Support_List">13.1 LPC Demo Code Support List</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#LPC_Function_Description">13.2 Function Description</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#LPC_Comparator_Function_Operation_Flow">13.3 Comparator Function Operation Flow</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#LPC_Voltage_Detection_Function_Operation_Flow">13.4 Voltage Detection Function Operation Flow</a></li>
</ul>
</li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#SPI3wire">14 3-Wire SPI</a><ul>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#SPI3wire_Demo_Code_Support_List">14.1 3-Wire SPI Demo Code Support List</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#SPI3wire_Function_Description">14.2 Function Description</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#SPI3wire_Feature_List">14.3 Feature List</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#SPI3wire_data_format">14.4 3-Wire SPI data format</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#SPI3wire_Write_Operation">14.5 3-Wire SPI Write Operation</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#SPI3wire_Read_Operation">14.6 3-Wire SPI Read Operation</a><ul>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#SPI3wire_Single_Read_Mode">14.6.1 Single Read Mode</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#SPI3wire_Burst_Read_Mode">14.6.2 Burst Read Mode</a></li>
</ul>
</li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#SPI3wire_Initialization_Operation_Flow">14.7 Initialization Operation Flow</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#SPI3wire_Send_Data_Operation_Flow">14.8 Send Data Operation Flow</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#SPI3wire_Receive_Data_Operation_Flow">14.9 Receive Data Operation Flow</a></li>
</ul>
</li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#IO_Demo_CapTouch">15 CapTouch</a><ul>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#CapTouch_Demo_Code_Support_List">15.1 CapTouch Demo Code Support List</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#CapTouch_Function_Description">15.2 Function Description</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#CapTouch_Feature_List">15.3 Feature List</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#CapTouch_Channel_Pin_Location">15.4 CapTouch Channel Pin Location</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#CapTouch_Sample_Range">15.5 Sample Range</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#CapTouch_ETC">15.6 Environment Tracking and Calibration (ETC)</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#CapTouch_Touch_Judgement_Mode">15.7 Touch Judgement Mode (With ETC Function Enable)</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#CapTouch_Auto_Scan_Mode">15.8 Auto Scan Mode</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#CapTouch_Scan_Period">15.9 Scan Period</a><ul>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#Active_Time">15.9.1 Active Time</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#Sleep_Time">15.9.2 Sleep Time</a></li>
</ul>
</li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#CapTouch_Baseline_Auto-Initialization">15.10 Baseline Auto-Initialization</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#CapTouch_Noise_Threshold">15.11 Noise Threshold</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#CapTouch_Fast_Mode">15.12 Fast Mode</a><ul>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#Channel_False_Alarm">15.12.1 Channel False Alarm/Release Active Counter</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#Channel_Press_Counter">15.12.2 Channel Press Counter</a></li>
</ul>
</li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#CapTouch_Operation_Flow">15.13 CapTouch Operation Flow</a></li>
</ul>
</li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#ADC">16 ADC</a><ul>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#ADC_Demo_Code_Support_List">16.1 ADC Demo Code Support List</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#ADC_Feature_List">16.2 Feature List</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#ADC_Pin">16.3 ADC Pin</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#ADC_Channel_Mode">16.4 Channel Mode</a><ul>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#Single-Ended_Mode">16.4.1 Single-Ended Mode</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#Internal_VBAT_Mode">16.4.2 Internal VBAT/VADPIN Mode</a></li>
</ul>
</li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#ADC_External_Channel_Input_Mode">16.5 External Channel Input Mode</a><ul>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#Bypass_Mode">16.5.1 Bypass Mode</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#Divide_Mode">16.5.2 Divide Mode</a></li>
</ul>
</li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#ADC_Work_Mode">16.6 Work Mode</a><ul>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#One_Shot_Mode">16.6.1 One Shot Mode</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#Continuous_Mode">16.6.2 Continuous Mode</a></li>
</ul>
</li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#ADC_Schedule_Table_Index">16.7 ADC Schedule Table Index</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#ADC_One_Shot_Mode_Operation_Flow">16.8 ADC One Shot Mode Operation Flow</a><ul>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#ADC_Polling_Mode">16.8.1 Polling Mode</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#ADC_Interrupt_Mode">16.8.2 Interrupt Mode</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#ADC_Hardware_Average_Mode">16.8.3 Hardware Average Mode</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#ADC_Manager_Mode">16.8.4 ADC Manager Mode</a></li>
</ul>
</li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#ADC_Continuous_Mode_Operation_Flow">16.9 ADC Continuous Mode Operation Flow</a><ul>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#ADC_DMA_Mode">16.9.1 DMA Mode</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#SLEEP_LED">17 SLEEP LED</a><ul>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#SLEEP_LED_Demo_Code_Support_List">17.1 SLEEP LED Demo Code Support List</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#SLEEP_LED_Function_Description">17.2 Function Description</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#SLEEP_LED_Feature_List">17.3 Feature List</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#SLEEP_LED_Blink_Mode">17.4 Blink Mode</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#SLEEP_LED_Breathe_Mode">17.5 Breathe Mode</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#SLEEP_LED_Idle_State">17.6 Idle State</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#SLEEP_LED_Reverse_Output_Function">17.7 Reverse Output Function</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#SLEEP_LED_Blink_Mode_Operation_Flow">17.8 Blink Mode Operation Flow</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#SLEEP_LED_Breathe_Mode_Operation_Flow">17.9 Breathe Mode Operation Flow</a></li>
</ul>
</li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#QDEC">18 QDEC</a><ul>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#QDEC_Demo_Code_Support_List">18.1 QDEC Demo Code Support List</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#QDEC_Function_Description">18.2 Function Description</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#QDEC_Feature_List">18.3 Feature List</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#QDEC_Direction_Judgment_and_Counting_Method">18.4 Direction Judgment and Counting Method</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#QDEC_Operation_Flow">18.5 QDEC Operation Flow</a></li>
</ul>
</li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#KEYSCAN">19 KEYSCAN</a><ul>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#KEYSCAN_Demo_Code_Support_List">19.1 KEYSCAN Demo Code Support List</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#KEYSCAN_Function_Description">19.2 Function Description</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#KEYSCAN_Feature_List">19.3 Feature List</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#KEYSCAN_Clock_Divider">19.4 Clock Divider</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#KEYSCAN_Auto_Scan_Mode">19.5 Auto Scan Mode</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#KEYSCAN_Interrupt">19.6 Interrupt</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#KEYSCAN_Operation_Flow">19.7 KEYSCAN Operation Flow</a></li>
</ul>
</li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#I2S">20 I2S</a><ul>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#I2S_Function_Description">20.1 Function Description</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#I2S_Feature_List">20.2 Feature List</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#I2S_Initialization_Flow">20.3 I2S Initialization Flow</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#I2S_Clock_Divider">20.4 Clock Divider</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#I2S_Operation_Flow">20.5 I2S Operation Flow</a></li>
</ul>
</li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#SDIO">21 SDIO</a><ul>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#SDIO_Demo_Code_Support_List">21.1 SDIO Demo Code Support List</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#SDIO_Function_Description">21.2 Function Description</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#SDIO_Feature_List">21.3 Feature List</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#SDIO_SD_Bus_Protocol">21.4 SD Bus Protocol</a></li>
<li><a class="el" href="_u_m012__i_o__d_e_m_o.html#SDIO_Operation_Flow">21.5 SDIO Operation Flow</a></li>
</ul>
</li>
</ul>
<div style="page-break-after: always;"></div><h2><a class="anchor" id="DemoIO_Table_List"></a>
Table List</h2>
<ul>
<li><a href="#table_2_1">Table 2-1 IO Demo Sample Code File</a></li>
<li><a href="#table_4_1">Table 4-1 PAD Sample Code 1 Description</a></li>
<li><a href="#table_5_1">Table 5-1 GPIO Sample Code 1 Description</a></li>
<li><a href="#table_5_2">Table 5-2 GPIO Sample Code 2 Description</a></li>
<li><a href="#table_5_3">Table 5-3 GPIO Sample Code 3 Description</a></li>
<li><a href="#table_5_4">Table 5-4 GPIO Sample Code 4 Description</a></li>
<li><a href="#table_5_5">Table 5-5 GPIO Sample Code 5 Description</a></li>
<li><a href="#table_5_6">Table 5-6 GPIO Sample Code 6 Description</a></li>
<li><a href="#table_5_7">Table 5-7 GPIO Sample Code 7 Description</a></li>
<li><a href="#table_5_8">Table 5-8 GPIO Sample Code 8 Description</a></li>
<li><a href="#table_5_9">Table 5-9 GPIO Sample Code 9 Description</a></li>
<li><a href="#table_6_1">Table 6-1 TIMER and PWM Sample Code 1 Description</a></li>
<li><a href="#table_6_2">Table 6-2 TIMER and PWM Sample Code 2 Description</a></li>
<li><a href="#table_6_3">Table 6-3 TIMER and PWM Sample Code 3 Description</a></li>
<li><a href="#table_7_1">Table 7-1 UART Sample Code 1 Description</a></li>
<li><a href="#table_7_2">Table 7-2 UART Sample Code 2 Description</a></li>
<li><a href="#table_7_3">Table 7-3 UART Sample Code 3 Description</a></li>
<li><a href="#table_7_4">Table 7-4 UART Sample Code 4 Description</a></li>
<li><a href="#table_7_5">Table 7-5 UART Sample Code 5 Description</a></li>
<li><a href="#table_7_6">Table 7-6 UART Sample Code 6 Description</a></li>
<li><a href="#table_7_7">Table 7-7 UART Baud Rate Table</a></li>
<li><a href="#table_8_1">Table 8-1 GDMA Sample Code 1 Description</a></li>
<li><a href="#table_8_2">Table 8-2 GDMA Sample Code 2 Description</a></li>
<li><a href="#table_8_3">Table 8-3 GDMA Sample Code 3 Description</a></li>
<li><a href="#table_8_4">Table 8-4 GDMA Sample Code 4 Description</a></li>
<li><a href="#table_8_5">Table 8-5 GDMA Sample Code 5 Description</a></li>
<li><a href="#table_8_6">Table 8-6 GDMA Sample Code 6 Description</a></li>
<li><a href="#table_8_7">Table 8-7 GDMA Sample Code 7 Description</a></li>
<li><a href="#table_8_8">Table 8-8 GDMA Sample Code 8 Description</a></li>
<li><a href="#table_8_9">Table 8-9 GDMA Sample Code 9 Description</a></li>
<li><a href="#table_8_10">Table 8-10 MSize and Peripheral Waterlevel Setting Table</a></li>
<li><a href="#table_9_1">Table 9-1 I2C Sample Code 1 Description</a></li>
<li><a href="#table_9_2">Table 9-2 I2C Sample Code 2 Description</a></li>
<li><a href="#table_9_3">Table 9-3 I2C Sample Code 3 Description</a></li>
<li><a href="#table_9_4">Table 9-4 I2C Sample Code 4 Description</a></li>
<li><a href="#table_10_1">Table 10-1 SPI Sample Code 1 Description</a></li>
<li><a href="#table_10_2">Table 10-2 SPI Sample Code 2 Description</a></li>
<li><a href="#table_10_3">Table 10-3 SPI Sample Code 3 Description</a></li>
<li><a href="#table_10_4">Table 10-4 SPI Sample Code 4 Description</a></li>
<li><a href="#table_10_5">Table 10-5 SPI Sample Code 5 Description</a></li>
<li><a href="#table_10_6">Table 10-6 SPI Sample Code 6 Description</a></li>
<li><a href="#table_10_7">Table 10-7 SPI Sample Code 7 Description</a></li>
<li><a href="#table_10_8">Table 10-8 SPI Sample Code 8 Description</a></li>
<li><a href="#table_10_9">Table 10-9 SPI Sample Code 9 Description</a></li>
<li><a href="#table_10_10">Table 10-10 SPI Sample Code 10 Description</a></li>
<li><a href="#table_10_11">Table 10-11 SPI Sample Code 11 Description</a></li>
<li><a href="#table_10_12">Table 10-12 SPI Sample Code 12 Description</a></li>
<li><a href="#table_10_13">Table 10-13 SPI Sample Code 13 Description</a></li>
<li><a href="#table_10_14">Table 10-14 SPI Sample Code 14 Description</a></li>
<li><a href="#table_10_15">Table 10-15 SPI Sample Code 15 Description</a></li>
<li><a href="#table_10_16">Table 10-16 SPI Sample Code 16 Description</a></li>
<li><a href="#table_10_17">Table 10-17 SPI Sample Code 17 Description</a></li>
<li><a href="#table_10_18">Table 10-18 SPI Slow Clk Settings in RTL87X3E</a></li>
<li><a href="#table_10_19">Table 10-19 SPI Slow Clk Settings in RTL87X3D</a></li>
<li><a href="#table_11_1">Table 11-1 IR Sample Code 1 Description</a></li>
<li><a href="#table_11_2">Table 11-2 IR Sample Code 2 Description</a></li>
<li><a href="#table_11_3">Table 11-3 IR Sample Code 3 Description</a></li>
<li><a href="#table_11_4">Table 11-4 IR Sample Code 4 Description</a></li>
<li><a href="#table_12_1">Table 12-1 RTC Sample Code 1 Description</a></li>
<li><a href="#table_12_2">Table 12-2 RTC Sample Code 2 Description</a></li>
<li><a href="#table_12_3">Table 12-3 RTC Sample Code 3 Description</a></li>
<li><a href="#table_12_4">Table 12-4 RTC Sample Code 4 Description</a></li>
<li><a href="#table_12_5">Table 12-5 RTC Sample Code 5 Description</a></li>
<li><a href="#table_13_1">Table 13-1 LPC Sample Code 1 Description</a></li>
<li><a href="#table_13_2">Table 13-2 LPC Sample Code 2 Description</a></li>
<li><a href="#table_13_3">Table 13-3 LPC Sample Code 3 Description</a></li>
<li><a href="#table_14_1">Table 14-1 3-Wire SPI Sample Code 1 Description</a></li>
<li><a href="#table_15_1">Table 15-1 CapTouch Sample Code 1 Description</a></li>
<li><a href="#table_16_1">Table 16-1 ADC Sample Code 1 Description</a></li>
<li><a href="#table_16_2">Table 16-2 ADC Sample Code 2 Description</a></li>
<li><a href="#table_16_3">Table 16-3 ADC Sample Code 3 Description</a></li>
<li><a href="#table_16_4">Table 16-4 ADC Sample Code 4 Description</a></li>
<li><a href="#table_16_5">Table 16-5 ADC Sample Code 5 Description</a></li>
<li><a href="#table_16_6">Table 16-6 ADC Sample Code 6 Description</a></li>
<li><a href="#table_16_7">Table 16-7 ADC Schedule Table</a></li>
<li><a href="#table_17_1">Table 17-1 SLEEP LED Sample Code 1 Description</a></li>
<li><a href="#table_17_2">Table 17-2 SLEEP LED Sample Code 2 Description</a></li>
<li><a href="#table_18_1">Table 18-1 QDEC Sample Code 1 Description</a></li>
<li><a href="#table_19_1">Table 19-1 KEYSCAN Sample Code 1 Description</a></li>
<li><a href="#table_19_2">Table 19-2 KEYSCAN Sample Code 2 Description</a></li>
<li><a href="#table_20_1">Table 20-1 I2S Clock Divider Table</a></li>
<li><a href="#table_21_1">Table 21-1 SDIO Sample Code 1 Description</a></li>
<li><a href="#table_21_2">Table 21-2 SDIO Sample Code 2 Description</a></li>
<li><a href="#table_21_3">Table 21-3 SDIO Sample Code 3 Description</a></li>
<li><a href="#table_21_4">Table 21-4 SDIO Group Pins in RTL87X3D</a></li>
<li><a href="#table_21_5">Table 21-5 SDIO Group Pins in RTL87X3E</a></li>
<li><a href="#table_21_6">Table 21-6 SDIO Pin Definitions in Different Modes</a></li>
</ul>
<div style="page-break-after: always;"></div><h2><a class="anchor" id="DemoIO_Figure_List"></a>
Figure List</h2>
<ul>
<li><a href="#figure_3_1">Figure 3-1 Initialization Flow Chart</a></li>
<li><a href="#figure_4_1">Figure 4-1 Schematic Diagram of PINMUX and PAD Circuit</a></li>
<li><a href="#figure_5_1">Figure 5-1 GPIO Hardware Connection Diagram</a></li>
<li><a href="#figure_5_2">Figure 5-2 GPIO DMA Result Diagram</a></li>
<li><a href="#figure_5_3">Figure 5-3 GPIO Initialization Flow Chart</a></li>
<li><a href="#figure_6_1">Figure 6-1 PWM Demo Expected Result Diagram</a></li>
<li><a href="#figure_7_1">Figure 7-1 UART Demo 1/2/3/5 Hardware Connection Diagram</a></li>
<li><a href="#figure_7_2">Figure 7-2 UART Demo 4 Hardware Connection Diagram</a></li>
<li><a href="#figure_7_3">Figure 7-3 UART Demo 6 Hardware Connection Diagram</a></li>
<li><a href="#figure_7_4">Figure 7-4 Schematic Diagram of 7-bit Data Format</a></li>
<li><a href="#figure_7_5">Figure 7-5 Schematic Diagram of 8-bit Data Format</a></li>
<li><a href="#figure_7_6">Figure 7-6 Schematic Diagram of Hardware Flow Control</a></li>
<li><a href="#figure_7_7">Figure 7-7 UART Initialization Flow Chart</a></li>
<li><a href="#figure_7_8">Figure 7-8 UART Interrupt Handle Flow</a></li>
<li><a href="#figure_7_9">Figure 7-9 UART Interrupt Handle Flow</a></li>
<li><a href="#figure_8_1">Figure 8-1 I2C GDMA Hardware Connection Diagram</a></li>
<li><a href="#figure_8_2">Figure 8-2 GDMA Recover From DLPS Hardware Connection Diagram</a></li>
<li><a href="#figure_8_3">Figure 8-3 GDMA Single-Block Transfer Initialization Flow Chart</a></li>
<li><a href="#figure_9_1">Figure 9-1 I2C Demo1/2/3 Hardware Connection Diagram</a></li>
<li><a href="#figure_9_2">Figure 9-2 I2C Demo4 Hardware Connection Diagram</a></li>
<li><a href="#figure_9_3">Figure 9-3 Schematic Diagram of I2C Transmission Protocol</a></li>
<li><a href="#figure_9_4">Figure 9-4 Master Write in 7-bit Addressing Mode</a></li>
<li><a href="#figure_9_5">Figure 9-5 Master Read in 7-bit Addressing Mode</a></li>
<li><a href="#figure_9_6">Figure 9-6 Master Repeat Read in 7-bit Addressing Mode</a></li>
<li><a href="#figure_9_7">Figure 9-7 Master Write in 10-bit Addressing Mode</a></li>
<li><a href="#figure_9_8">Figure 9-8 Master Read in 10-bit Addressing Mode</a></li>
<li><a href="#figure_9_9">Figure 9-9 Master Repeat Read in 10-bit Addressing Mode</a></li>
<li><a href="#figure_9_10">Figure 9-10 I2C Master Mode Initialization Flow Chart</a></li>
<li><a href="#figure_9_11">Figure 9-11 I2C Slave Mode Initialization Flow Chart</a></li>
<li><a href="#figure_10_1">Figure 10-1 SPI Demo 1 Hardware Connection Diagram</a></li>
<li><a href="#figure_10_2">Figure 10-2 SPI Demo 2/6 Hardware Connection Diagram</a></li>
<li><a href="#figure_10_3">Figure 10-3 SPI Demo 3 Hardware Connection Diagram</a></li>
<li><a href="#figure_10_4">Figure 10-4 SPI Demo 4 Hardware Connection Diagram</a></li>
<li><a href="#figure_10_5">Figure 10-5 SPI Demo 5 Hardware Connection Diagram</a></li>
<li><a href="#figure_10_6">Figure 10-6 SPI Demo 7 Hardware Connection Diagram</a></li>
<li><a href="#figure_10_7">Figure 10-7 SPI Demo 8 Hardware Connection Diagram</a></li>
<li><a href="#figure_10_8">Figure 10-8 SPI Demo 9 Hardware Connection Diagram</a></li>
<li><a href="#figure_10_9">Figure 10-9 SPI Demo 10 Hardware Connection Diagram</a></li>
<li><a href="#figure_10_10">Figure 10-10 SPI Demo 11/12 Hardware Connection Diagram</a></li>
<li><a href="#figure_10_11">Figure 10-11 SPI Demo 13/14 Hardware Connection Diagram</a></li>
<li><a href="#figure_10_12">Figure 10-12 SPI Communication Sequence Diagram (SCPH = 0)</a></li>
<li><a href="#figure_10_13">Figure 10-13 SPI Communication Sequence Diagram (SCPH = 1)</a></li>
<li><a href="#figure_10_14">Figure 10-14 SPI Initialization Flow Chart</a></li>
<li><a href="#figure_11_1">Figure 11-1 Schematic Diagram of IR Module</a></li>
<li><a href="#figure_11_2">Figure 11-2 Schematic Diagram of IR TX</a></li>
<li><a href="#figure_11_3">Figure 11-3 IR Initialization Flow Chart</a></li>
<li><a href="#figure_11_4">Figure 11-4 IR Send Data Operation Flow Chart</a></li>
<li><a href="#figure_11_5">Figure 11-5 IR Interrupt Handle Flow Chart</a></li>
<li><a href="#figure_11_6">Figure 11-6 IR Initialization Flow Chart</a></li>
<li><a href="#figure_11_7">Figure 11-7 IR Receive Data Operation Flow Chart</a></li>
<li><a href="#figure_11_8">Figure 11-8 IR Interrupt Handle Flow Chart</a></li>
<li><a href="#figure_12_1">Figure 12-1 RTC Comparator Function Initialization Flow Chart</a></li>
<li><a href="#figure_12_2">Figure 12-2 RTC Interrupt Handle Flow Chart</a></li>
<li><a href="#figure_12_3">Figure 12-3 RTC Overflow Function Initialization Flow Chart</a></li>
<li><a href="#figure_12_4">Figure 12-4 RTC Interrupt Handle Flow Chart</a></li>
<li><a href="#figure_12_5">Figure 12-5 RTC Tick Function Initialization Flow Chart</a></li>
<li><a href="#figure_12_6">Figure 12-6 RTC Interrupt Handle Flow Chart</a></li>
<li><a href="#figure_13_1">Figure 13-1 LPC Comparator Function Initialization Flow Chart</a></li>
<li><a href="#figure_13_2">Figure 13-2 LPC Comparator Function Interrupt Handle Flow Chart</a></li>
<li><a href="#figure_14_1">Figure 14-1 3-Wire SPI Demo Hardware Connection Diagram</a></li>
<li><a href="#figure_14_2">Figure 14-2 3-Wire SPI Data Format</a></li>
<li><a href="#figure_14_3">Figure 14-3 Schematic Diagram of 3-Wire SPI Write Operation Frame Format</a></li>
<li><a href="#figure_14_4">Figure 14-4 Schematic Diagram of 3-Wire SPI Read Operation Frame Format</a></li>
<li><a href="#figure_14_5">Figure 14-5 3-Wire SPI Initialization Flow Chart</a></li>
<li><a href="#figure_14_6">Figure 14-6 3-Wire SPI Send Data Operation Flow Chart</a></li>
<li><a href="#figure_14_7">Figure 14-7 3-Wire SPI Receive Data Operation Flow Chart</a></li>
<li><a href="#figure_15_1">Figure 15-1 CapTouch Detect Theory</a></li>
<li><a href="#figure_15_2">Figure 15-2 CapTouch System</a></li>
<li><a href="#figure_15_3">Figure 15-3 Auto Scan Mode Flow Chart</a></li>
<li><a href="#figure_15_4">Figure 15-4 Schematic Diagram of Scan Period</a></li>
<li><a href="#figure_15_5">Figure 15-5 Fast Mode Control Flow Chart</a></li>
<li><a href="#figure_15_6">Figure 15-6 CapTouch Initialization Flow Chart</a></li>
<li><a href="#figure_15_7">Figure 15-7 CapTouch Interrupt Handle Flow Chart</a></li>
<li><a href="#figure_16_1">Figure 16-1 ADC Demo Hardware Connection Diagrame</a></li>
<li><a href="#figure_16_2">Figure 16-2 ADC One Shot Sampling by Polling Mode</a></li>
<li><a href="#figure_16_3">Figure 16-3 Turn Off Charger on the McuConfig Tool</a></li>
<li><a href="#figure_16_4">Figure 16-4 ADC One Shot Sampling by Interrupt Mode</a></li>
<li><a href="#figure_16_5">Figure 16-5 ADC Interrupt Handle Flow</a></li>
<li><a href="#figure_16_6">Figure 16-6 ADC One Shot Sampling by Hardware Average Mode</a></li>
<li><a href="#figure_16_7">Figure 16-7 ADC Interrupt Handle Flow</a></li>
<li><a href="#figure_16_8">Figure 16-8 ADC One Shot Sampling by ADC Manager Mode</a></li>
<li><a href="#figure_16_9">Figure 16-9 ADC Manager Callback Handle Flow</a></li>
<li><a href="#figure_16_10">Figure 16-10 ADC Continuous Sampling by DMA Mode</a></li>
<li><a href="#figure_17_1">Figure 17-1 SLEEP LED Demo Hardware Connection Diagrame</a></li>
<li><a href="#figure_17_2">Figure 17-2 Schematic Diagram of SLEEP LED Blink Mode</a></li>
<li><a href="#figure_17_3">Figure 17-3 Schematic Diagram of SLEEP LED Breathe Mode</a></li>
<li><a href="#figure_17_4">Figure 17-4 SLEEP LED Blink Mode Flow Chart</a></li>
<li><a href="#figure_17_5">Figure 17-5 SLEEP LED Breathe Mode Flow Chart</a></li>
<li><a href="#figure_18_1">Figure 18-1 QDEC Demo Hardware Connection Diagram</a></li>
<li><a href="#figure_18_2">Figure 18-2 Schematic Diagram of Two Quadrature Signals of QDEC</a></li>
<li><a href="#figure_18_3">Figure 18-3 Schematic Diagram of QDEC Direction Judgment</a></li>
<li><a href="#figure_18_4">Figure 18-4 QDEC Operation Flow Chart</a></li>
<li><a href="#figure_18_5">Figure 18-5 QDEC Interrupt Handle Flow</a></li>
<li><a href="#figure_19_1">Figure 19-1 KEYSCAN Hardware Connection Diagram</a></li>
<li><a href="#figure_19_2">Figure 19-2 Schematic Diagram of KEYSCAN Clock Divider</a></li>
<li><a href="#figure_19_3">Figure 19-3 Auto Scan Flow Chart</a></li>
<li><a href="#figure_19_4">Figure 19-4 KEYSCAN Initialization Flow Chart</a></li>
<li><a href="#figure_20_1">Figure 20-1 I2S Initialization Flow Chart</a></li>
<li><a href="#figure_20_2">Figure 20-2 I2S_BCLK_Jitter</a></li>
<li><a href="#figure_20_3">Figure 20-3 I2S_LRCK_Jitter</a></li>
<li><a href="#figure_20_4">Figure 20-4 I2S_TX_GDMA_Flow</a></li>
<li><a href="#figure_20_5">Figure 20-5 I2S_RX_GDMA_Flow</a></li>
<li><a href="#figure_21_1">Figure 21-1 SDIO Hardware Connection Diagram</a></li>
<li><a href="#figure_21_2">Figure 21-2 SDHC and SD card Connection Diagram</a></li>
<li><a href="#figure_21_3">Figure 21-3 SD BUS (Multiple)Block Read Operation</a></li>
<li><a href="#figure_21_4">Figure 21-4 SD BUS (Multiple)Block Write Operation</a></li>
</ul>
<div style="page-break-after: always;"></div><h2><a class="anchor" id="DemoIO_Glossary"></a>
Glossary</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Terms  </th><th class="markdownTableHeadCenter">Definitions   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">ADC  </td><td class="markdownTableBodyCenter">Analog-to-Digital Converter   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">CapTouch  </td><td class="markdownTableBodyCenter">Capacitive Touch Controller   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">GDMA  </td><td class="markdownTableBodyCenter">General Direct Memory Access Controller   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">GPIO  </td><td class="markdownTableBodyCenter">General Purpose Input Output   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">I2C  </td><td class="markdownTableBodyCenter">Internal Integrate Circuit   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">IO  </td><td class="markdownTableBodyCenter">Peripheral   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">PAD  </td><td class="markdownTableBodyCenter">Pad   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">PINMUX  </td><td class="markdownTableBodyCenter">Pin Multiplexing   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">SLEEP LED  </td><td class="markdownTableBodyCenter">Sleep mode led   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">RTC  </td><td class="markdownTableBodyCenter">Real-Time Clock   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">LPC  </td><td class="markdownTableBodyCenter">Low Power Comparator   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">SPI  </td><td class="markdownTableBodyCenter">Serial Peripheral Interface   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">TIM &amp; PWM  </td><td class="markdownTableBodyCenter">Universal Timer &amp; Pulse Width Modulation   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">UART  </td><td class="markdownTableBodyCenter">Universal Asynchronous Receiver Transmitter   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">KEYSCAN  </td><td class="markdownTableBodyCenter">Key Scan   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">QDEC  </td><td class="markdownTableBodyCenter">Quadrature Demodulator   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">3-Wire SPI  </td><td class="markdownTableBodyCenter">Three-Wire SPI   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">IR  </td><td class="markdownTableBodyCenter">Infrared module   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">I2S  </td><td class="markdownTableBodyCenter">Integrated Interchip Sound   </td></tr>
</table>
<div style="page-break-after: always;"></div><h2><a class="anchor" id="Io_Demo_Overview"></a>
1  Overview</h2>
<p>This document is aimed to help beginners quickly get familiar with the peripherals of Realtek MCU. This document introduces PINMUX/PAD/GPIO/TIMER/PWM/UART/GDMA/I2C/SPI/IR/RTC/LPC/3-WIRE SPI/CAPTOUCH/ADC/QDEC/KEYSCAN/SLEEP LED/I2S peripherals. This document introduces IO demo project, peripheral functions and features, hardware-related knowledge, peripheral operation flow and its demo code.</p>
<p>Each chapter is mainly divided into the following aspects to introduce peripherals.</p><ul>
<li>Peripheral function description</li>
<li>Peripheral feature description</li>
<li>Introduction to hardware protocols.</li>
<li>Basic hardware information of peripherals.</li>
<li>Operation flow</li>
<li>Sample code description</li>
</ul>
<div style="page-break-after: always;"></div><h2><a class="anchor" id="IO_Demo_Project"></a>
2  IO Demo Project</h2>
<h3><a class="anchor" id="IO_Demo_Project_Introduction"></a>
2.1  IO Demo Project Introduction</h3>
<p>IO demo project shows how to use peripherals to communicate with other devices. A specific peripheral and its usage scenario can be changed to demonstrate, with its source file added to the build target and its demo function called in <a class="el" href="group___s_p_p___d_e_m_o___m_a_i_n.html#ga840291bc02cba5474a4cb46a9b9566fe" title="Entry of APP code. ">main()</a>. Source code can be found in <b>src\sample\io_demo</b> folder and project setting can be found in <b>board\evb\io_demo</b> folder.</p>
<h3><a class="anchor" id="How_to_run_IO_DEMO"></a>
2.2  How to run IO DEMO</h3>
<ol type="1">
<li>Prepare hardware and software. <br />
 Please refer to <a class="el" href="_u_m001__q_u_i_c_k__s_t_a_r_t.html#Quick_Start">Quick Start User Guide </a> for hardware and software preparation.</li>
<li>Use MPPG Tool to download the default bin file first. <br />
 Please refer to MPPGTool for specific usage method.</li>
<li>Download IO DEMO bin file. <br />
 (1)Open the io_demo project located in sdk\board\evb\io_demo and build it. <br />
 (2)Open MPPG Tool and delete all the bin files added before. Choose the io_demo bin file, which is located in sdk\board\evb\io_demo\bin\io_demo_MP-xxxxxxxxxxxxxxxxxxxxxxxxxx.bin</li>
<li>Start the program. <br />
 Disconnect P2_0 from GND and press the reset key (red one).</li>
</ol>
<div style="page-break-after: always;"></div><h2><a class="anchor" id="IO_Demo_App"></a>
3  IO Demo App</h2>
<h3><a class="anchor" id="IO_Demo_Sample_Code_File"></a>
3.1  IO Demo Sample Code File</h3>
<p>The descriptions of each file in the application are shown below.</p>
<center><div id="table_2_1"><b>Table 2-1 IO Demo Sample Code File</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">File name  </th><th class="markdownTableHeadCenter">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">main.c  </td><td class="markdownTableBodyCenter">Entry of IO demo application.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">adc\adc_xx_demo.c  </td><td class="markdownTableBodyCenter">Implement ADC firmware function.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">captouch\cap_touch_demo.c  </td><td class="markdownTableBodyCenter">Implement CapTouch firmware functions.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">gdma\xx_gdma_demo.c  </td><td class="markdownTableBodyCenter">Implement different GDMA firmware functions.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">gpio\gpio_xx_demo.c  </td><td class="markdownTableBodyCenter">Implement GPIO firmware functions.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">i2c\i2c_xx_demo.c  </td><td class="markdownTableBodyCenter">Implement I2C firmware functions.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">ir\ir_xx_demo.c  </td><td class="markdownTableBodyCenter">Implement IR firmware functions.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">keyscan\keyscan_demo_xx.c  </td><td class="markdownTableBodyCenter">Implement KEYSCAN firmware functions.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">led\sleep_led_demo.c  </td><td class="markdownTableBodyCenter">Implement SLEEP LED firmware functions.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">lpc\lpc_xx_demo.c  </td><td class="markdownTableBodyCenter">Implement LPC firmware functions.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">qdec\qdec_demo.c  </td><td class="markdownTableBodyCenter">Implement QDEC firmware functions.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">rtc\rtc_xx_demo.c  </td><td class="markdownTableBodyCenter">Implement RTC firmware functions.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">spi\spi_xx_demo.c  </td><td class="markdownTableBodyCenter">Implement SPI firmware functions.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">spi3w\spi3wire_demo.c  </td><td class="markdownTableBodyCenter">Implement 3-wire SPI firmware functions.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">tim\xx_demo.c  </td><td class="markdownTableBodyCenter">Implement TIM and PWM firmware functions.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">uart\uart_xx_demo.c  </td><td class="markdownTableBodyCenter">Implement UART firmware functions.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">i2s\i2s_xx_demo.c  </td><td class="markdownTableBodyCenter">Implement I2S firmware functions.   </td></tr>
</table>
<h3><a class="anchor" id="IO_Demo_Source_Code_Overview"></a>
3.2  IO Demo Source Code Overview</h3>
<h4><a class="anchor" id="IO_Demo_APP_Description"></a>
3.2.1  IO_Demo APP Description</h4>
<p><b>IO_Demo App </b> main function is invoked when io_demo app is power-on or the chip resets, which would perform the following initialization functions: </p><div class="fragment"><div class="line"><a class="code" href="group___s_e_c_t_i_o_n___exported___macros.html#ga501017c9d06ffea48e92d5ed3757b9f5">RAM_TEXT_SECTION</a></div><div class="line"><span class="keywordtype">int</span> <a class="code" href="group___s_p_p___d_e_m_o___m_a_i_n.html#ga840291bc02cba5474a4cb46a9b9566fe">main</a>(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    __enable_irq();</div><div class="line">    <a class="code" href="group___h_a_l___w_d_g___a_p_i___exported___functions.html#gafaa411781eecd71bfd1f13edc42c58c2">WDG_Disable</a>();</div><div class="line"></div><div class="line">    IO_PRINT_INFO0(<span class="stringliteral">&quot;Hello io demo !&quot;</span>);</div><div class="line"></div><div class="line">    <span class="keyword">extern</span> <span class="keywordtype">void</span> gpio_int_demo(<span class="keywordtype">void</span>);</div><div class="line">    gpio_int_demo();</div><div class="line"></div><div class="line">    <a class="code" href="group___o_s__87x3e___schedule.html#ga3300197ad1a1b9d64a335dc4ffc0769f">os_sched_start</a>();</div><div class="line">}</div></div><!-- fragment --><p> The gpio_int_demo() function can be replaced by any demo function which is disabled in the other folder, such as adc_demo() of adc_demo.c in adc folder of this project. Note that each demo function is independent of each other.</p>
<h4><a class="anchor" id="IO_Initialization_flow"></a>
3.2.2  IO Initialization flow</h4>
<p>IO peripheral initialization mainly consists of the following components.</p><ul>
<li>Enable IO clock signal</li>
<li>Set IO PINMUX and PAD</li>
<li>Set IO initialization parameters</li>
<li>Enable IO</li>
</ul>
<p>The initialization procedure is shown in Figure 3-1, where XXX is the name of the peripheral to be initialized, such as GPIO, I2C, or SPI.</p>
<div class="image">
<img src="io_initialization_flow.jpg" alt="io_initialization_flow.jpg"/>
</div>
 <center><div id="figure_3_1"><b>Figure 3-1 Initialization Flow Chart</b></div></center><h4><a class="anchor" id="IO_Demo_Clock_Configuration"></a>
3.2.2.1  Clock Configuration</h4>
<p>Enable GPIO clock by calling <a class="el" href="group__x3e___r_c_c___exported___functions.html#ga0ff78e34dcddb1ed9a215ee66ccb2d1b">RCC_PeriphClockCmd()</a> function. </p><div class="fragment"><div class="line"><a class="code" href="group__x3e___r_c_c___exported___functions.html#ga0ff78e34dcddb1ed9a215ee66ccb2d1b">RCC_PeriphClockCmd</a>(<a class="code" href="group___a_p_b___peripheral___define.html#gaaa8957796ecbcf0cd2a7d76aeef858bc">APBPeriph_GPIO</a>, <a class="code" href="group___r_c_c___peripheral___clock.html#gabe4deffae254dd71d93123ae4c77d1e1">APBPeriph_GPIO_CLOCK</a>, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div></div><!-- fragment --><h4><a class="anchor" id="IO_Demo_PINMUX_Configuration"></a>
3.2.2.2  PINMUX Configuration</h4>
<p>Configure PINMUX status of pin by calling <a class="el" href="group__x3e___p_i_n_m_u_x___exported___functions.html#ga54f185f00ccea46d0645189f40a4f8d0" title="Config the selected pin to its corresponding IO function. ">Pinmux_Config()</a> function. </p><div class="fragment"><div class="line"><span class="comment">/* Configure Pin P0_5 as GPIO function */</span></div><div class="line"><a class="code" href="group__x3e___p_i_n_m_u_x___exported___functions.html#ga54f185f00ccea46d0645189f40a4f8d0">Pinmux_Config</a>(<a class="code" href="group__x3d___r_t_l876_x___pin___number.html#gaa1681f3dab52db87cd32f77b20352770">P0_5</a>, <a class="code" href="group___pin___function___number.html#ga9d5468fc89ece8692bbc8e132e2e2471">DWGPIO</a>);</div></div><!-- fragment --><p>For optional pin values and map GPIO please reference rtl876x.h group of RTL876X_Pin_Number</p>
<p><br />
RTL87X3E : <a class="el" href="rtl87x3e_2platform_2rtl876x_8h_source.html">sdk\inc\rtl87x3e\platform\rtl876x.h</a> <br />
RTL87X3D : <a class="el" href="rtl87x3d_2platform_2rtl876x_8h_source.html">sdk\inc\rtl87x3d\platform\rtl876x.h</a> <br />
RTL87X3G : sdk\inc\rtl87x3g\platform\rtl876x.h</p>
<h4><a class="anchor" id="IO_Demo_PAD_Configuration"></a>
3.2.2.3  PAD Configuration</h4>
<p>Configure PAD status of pin by calling <a class="el" href="group__x3e___p_i_n_m_u_x___exported___functions.html#ga38de86a8ea4d49c04e681494cc1c69cc" title="config the corresponding pad. ">Pad_Config()</a> function. </p><div class="fragment"><div class="line"><a class="code" href="group__x3e___p_i_n_m_u_x___exported___functions.html#ga38de86a8ea4d49c04e681494cc1c69cc">Pad_Config</a>(<a class="code" href="group__x3d___r_t_l876_x___pin___number.html#gaa1681f3dab52db87cd32f77b20352770">P0_5</a>, <a class="code" href="group__x3e___p_a_d___mode.html#gga2cc156cba11040bcf54db2efeb9cb587a8309999f45f91d480cb6fbb7082efbf3">PAD_PINMUX_MODE</a>, <a class="code" href="group__x3e___p_a_d___power___mode.html#ggac2e804c73a9d287080d1cf1207e6a177a64ef7041a073bac1e848da51333064e0">PAD_IS_PWRON</a>, <a class="code" href="group__x3e___p_a_d___pull___mode.html#ggaed6ddbb1abccbd7d16dd3dcb8319f475ace4bff5003037646cf8dd9c1ee4dc7d1">PAD_PULL_NONE</a>, <a class="code" href="group__x3e___p_a_d___output___config.html#ggacfc9e3ea370eb8401828c4b97c110dd0a4f06d28834349a9bb7138b4beb07cd5e">PAD_OUT_ENABLE</a>, <a class="code" href="group__x3e___p_a_d___output___value.html#gga1bbbfd046e26ccb142c1b42f1d4dccd7a2c46edbcf7e322cae25b4a64fc568bb8">PAD_OUT_HIGH</a>);</div></div><!-- fragment --><h4><a class="anchor" id="IO_Demo_Interrupt_Configuration"></a>
3.2.2.4  Interrupt Configuration</h4>
<p>Enable IRQ interrupt by calling <a class="el" href="group__x3e___n_v_i_c___exported___functions.html#ga4e06b4f5c9109d6bc8990adf77e5f8d3" title="Initializes the NVIC peripheral according to the specified parameters in the NVIC_InitStruct. ">NVIC_Init()</a> function.<br />
</p>
<div class="fragment"><div class="line"><a class="code" href="struct_n_v_i_c___init_type_def.html">NVIC_InitTypeDef</a> NVIC_InitStruct;</div><div class="line">NVIC_InitStruct.<a class="code" href="struct_n_v_i_c___init_type_def.html#a921af0ab04e071d7d276c003e0048123">NVIC_IRQChannel</a> = GPIO5_IRQ;</div><div class="line">NVIC_InitStruct.<a class="code" href="struct_n_v_i_c___init_type_def.html#acd582bc2edce30e9d7ab5e0ede400f36">NVIC_IRQChannelPriority</a> = 5;</div><div class="line">NVIC_InitStruct.<a class="code" href="struct_n_v_i_c___init_type_def.html#a3c5567ef024a0489884083c88f17b4d5">NVIC_IRQChannelCmd</a> = <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>;</div><div class="line"><a class="code" href="group__x3e___n_v_i_c___exported___functions.html#ga4e06b4f5c9109d6bc8990adf77e5f8d3">NVIC_Init</a>(&amp;NVIC_InitStruct);</div></div><!-- fragment --><p><b>Note:</b> User irq priority should be set larger than 2 (priority lower than os lock base priority), and less than 7 (system PendSV/Systick ISR priority).</p>
<h4><a class="anchor" id="IO_Demo_Disable_Peripheral"></a>
3.2.2.5  Disable Peripheral</h4>
<p>Disable peripheral by calling XXX_DeInit for each peripheral, and "XXX" is the name of the peripheral to be disabled. </p><div class="fragment"><div class="line"><a class="code" href="group___g_p_i_o___exported___functions.html#ga1c7948b79aa8c8bec29dd026218b2687">GPIOx_DeInit</a>();</div></div><!-- fragment --><div style="page-break-after: always;"></div><h2><a class="anchor" id="PINMUX_PAD"></a>
4  PINMUX and PAD</h2>
<h3><a class="anchor" id="PAD_Demo_Code_Support_List"></a>
4.1 PAD Demo Code Support List</h3>
<center><div id="table_4_1"><b>Table 4-1 PAD Sample Code 1 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 1  </th><th class="markdownTableHeadNone">dlps_gpio_wk_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:180px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:670px">Demonstrates how PAD wakes up the system from DLPS mode.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Brief Introduction  </td><td class="markdownTableBodyNone">This sample code Demonstrates PAD wakes up the system. TEST_Pin is set to low <br />
level wake-up. System will enter DLPS mode automatically while it's in idle state. <br />
When TEST_Pin is pulled down to low level, the system is woken up.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\dlps\dlps_gpio_wk_demo.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">dlps_gpio_wk_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">When the system needs to be woken up, connect M0_0 to GND on EVB.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">1. Press RESET on the EVB, string "dlps_store: enter dlps" will be printed in <br />
DebugAnalyzer, and system will enter DLPS mode.<br />
2. Then connect M0_0 to GND, the system will be woken up and print string <br />
"dlps_restore: exit dlps" in DebugAnalyzer.   </td></tr>
</table>
<h3><a class="anchor" id="PINMUX_PAD_Function_Description"></a>
4.2  Function Description</h3>
<p>PINMUX is an abbreviation of Pin Multiplexing, because the SOC has a limited number of pins, pin multiplexing allows the SOC to use the limited pins for various functions, such as SPI, I2C, and GPIO. <br />
Pad is used to control the behaviors of a pin such as Pull up/down, output high or low level, and wake up functions. <br />
As shown in the figure below. PINMUX circuit and IO modules are in the core domain and will be powered down during low power mode, so they cannot work during low power mode. PAD circuit is in the AON domain and will not be powered down during low power mode, so PAD can work normally during low power mode. Pad is mainly used to maintain pin output state or wake up the system in low power mode. <br />
PAD can be configured as PINMUX mode and software mode. Only when the PAD is set to PINMUX mode, this pin can be connected to the core domain to achieve pin multiplexing.</p>
<div class="image">
<img src="Schematic_Diagram_of_PINMUX_and_PAD_Circuit.jpg" alt="Schematic_Diagram_of_PINMUX_and_PAD_Circuit.jpg"/>
</div>
 <center><div id="figure_4_1"><b>Figure 4-1 Schematic Diagram of PINMUX and PAD Circuit</b></div></center><h3><a class="anchor" id="PINMUX_PAD_Feature_List"></a>
4.3  PAD Feature List</h3>
<ul>
<li>Two operating modes: PINMUX mode and software mode</li>
<li>Configurable pin pull-up or pull-down resistors</li>
<li>Configurable pin independently output high or low level in software mode</li>
<li>No power down during low power mode</li>
<li>Wake up the system from low power mode</li>
</ul>
<div style="page-break-after: always;"></div><h2><a class="anchor" id="GPIO"></a>
5  GPIO</h2>
<h3><a class="anchor" id="GPIO_Demo_Code_Support_List"></a>
5.1 GPIO Demo Code Support List</h3>
<center><div id="table_5_1"><b>Table 5-1 GPIO Sample Code 1 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 1  </th><th class="markdownTableHeadNone">gpio_input_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:180px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:670px">Demonstrates GPIO input mode.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Brief Introduction  </td><td class="markdownTableBodyNone">This sample code demonstrates GPIO input function. Then get the input level value <br />
of the GPIO.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\gpio\input\gpio_input_demo.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">gpio_input_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">GPIO Direction  </td><td class="markdownTableBodyNone">input mode   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">None   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">Press RESET on the EVB, string "gpio_test: gpio_value 1" will be printed in <br />
DebugAnalyzer.   </td></tr>
</table>
<center><div id="table_5_2"><b>Table 5-2 GPIO Sample Code 2 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 2  </th><th class="markdownTableHeadNone">gpio_output_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:180px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:670px">Demonstrates GPIO output mode.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Brief Introduction  </td><td class="markdownTableBodyNone">This sample code demonstrates GPIO output function. <br />
The output level value can be detected by connecting with LED.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\gpio\output\gpio_output_demo.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">gpio_output_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">GPIO Direction  </td><td class="markdownTableBodyNone">output mode   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">As shown in Figure 5-1. On EVB, connect P0_1 and LED1; connect P0_2 and LED2.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">Press RESET on the EVB, LED1 and LED2 will be lighted up or off when the output level is selected as high or low.   </td></tr>
</table>
<center><div id="table_5_3"><b>Table 5-3 GPIO Sample Code 3 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 3  </th><th class="markdownTableHeadNone">gpioab_output_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:180px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:670px">Demonstrates GPIOx output mode whatever pin belongs to GPIOA or B.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Brief Introduction  </td><td class="markdownTableBodyNone">This sample code demonstrates GPIOx output function. <br />
The output level value can be detected by connecting with LED.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\gpio\output\gpio_a_b\gpioab_output_demo.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">gpioab_output_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">GPIO Direction  </td><td class="markdownTableBodyNone">output mode   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">As shown in Figure 5-1. On EVB, connect P4_3 and LED1.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">Press RESET on the EVB, LED1 will be lighted up or off when the gpio_pin_bit is <br />
selected to Set or Reset.   </td></tr>
</table>
<div style="page-break-after: always;"></div><center><div id="table_5_4"><b>Table 5-4 GPIO Sample Code 4 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo4  </th><th class="markdownTableHeadNone">gpioab_output_group_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:180px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:670px">Demonstrates GPIOx group output mode whatever pins belong to GPIOA or B.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Brief Introduction  </td><td class="markdownTableBodyNone">This sample code demonstrates GPIOx group output function. <br />
These output level values can be detected by connecting with LED.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\gpio\output\gpio_a_b\gpioab_output_group_demo.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">gpioab_output_group_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">GPIO Direction  </td><td class="markdownTableBodyNone">output mode   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">As shown in Figure 5-1. On EVB, connect LED and testpin, which need to be <br />
detected in the testPinGruop.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">Press RESET on the EVB, LED will be lighted up or off when the gpio_pin_bit is <br />
selected to Set or Reset.   </td></tr>
</table>
<center><div id="table_5_5"><b>Table 5-5 GPIO Sample Code 5 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 5  </th><th class="markdownTableHeadNone">gpio_int_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:180px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:670px">Demonstrates GPIO used as a key by edge trigger mode with hw debounce.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Brief Introduction  </td><td class="markdownTableBodyNone">This sample code demonstrates the detection of GPIO input through interrupt. When button is pressed (such as P1_0 changes from high level to low level), the falling <br />
edge of GPIO is detected and the GPIO interrupt is triggered. Then switch the edge <br />
trigger, after button is released (P1_0 changes from low level to high level), the GPIO <br />
interrupt is triggered again.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\gpio\interrupt\gpio_int_demo.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">gpio_int_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">GPIO Direction  </td><td class="markdownTableBodyNone">input mode   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">As shown in Figure 5-1. On EVB, connect P1_0, P1_1, P2_1, P2_1 to KEY1 ~ KEY4 respectively.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">Press RESET on the EVB.<br />
Press KEY1 ~ KEY4: string "gpio_isr_cb: pin_name P1_0, gpio_level 0" <br />
"gpio_isr_cb: pin_name P1_1, gpio_level 1" <br />
"gpio_isr_cb: pin_name P2_1, gpio_level 0" <br />
"gpio_isr_cb: pin_name P2_2, gpio_level 1" will be printed in DebugAnalyzer. <br />
Release KEY1 ~ KEY4: string "gpio_isr_cb: pin_name P1_0, gpio_level 1" <br />
"gpio_isr_cb: pin_name P1_1, gpio_level 0" <br />
"gpio_isr_cb: pin_name P2_1, gpio_level 1" <br />
"gpio_isr_cb: pin_name P2_2, gpio_level 0" will be printed in DebugAnalyzer.   </td></tr>
</table>
<div style="page-break-after: always;"></div><center><div id="table_5_6"><b>Table 5-6 GPIO Sample Code 6 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 6  </th><th class="markdownTableHeadNone">pad_int_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:180px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:670px">Demonstrates PAD interrupt mode to realize key detection.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Brief Introduction  </td><td class="markdownTableBodyNone">This sample code demonstrates key detection by PAD interrupt mode. When button is pressed (such as P1_0 changes from high level to low level), the low level of pin is <br />
detected and the System handler is triggered. Then switch the level trigger, after <br />
button is released (P1_0 changes from low level to high level), the System handler is <br />
triggered again.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\gpio\interrupt\pad_int_demo.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">pad_int_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">GPIO Direction  </td><td class="markdownTableBodyNone">input mode   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">As shown in Figure 5-1. On EVB, connect P1_0, P1_1, P2_1, P2_1 to KEY1 ~ KEY4 respectively.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">Press RESET on the EVB.<br />
Press KEY1: string "system_handler: pin0 interrupt triggered, pin_0_state 0" will <br />
be printed in DebugAnalyzer. <br />
Release KEY1: string "system_handler: pin0 interrupt triggered, pin_0_state 1" will <br />
be printed in DebugAnalyzer.   </td></tr>
</table>
<center><div id="table_5_7"><b>Table 5-7 GPIO Sample Code 7 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 7  </th><th class="markdownTableHeadNone">gpio_key.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:180px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:670px">Demonstrates GPIO used as a key by level trigger mode with hw timer debounce.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Brief Introduction  </td><td class="markdownTableBodyNone">This sample code demonstrates the detection of GPIO input through interrupt. When button is pressed(P0_0 changes from high level to low level), the low level of GPIO <br />
is detected and the GPIO interrupt is triggered. Then restart the timer in gpio handler, after 30ms debounce time, enter timer handler to switch the level trigger, when button is released (P1_0 changes from low level to high level), the GPIO interrupt is <br />
triggered again. Then timer restarts again.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\gpio\key\level_tim\gpio_key.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">gpio_key()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">GPIO Direction  </td><td class="markdownTableBodyNone">input mode   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">As shown in Figure 5-1. On EVB, connect P0_0 and KEY1.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">Press RESET on the EVB.<br />
Press KEY1: string "key_handler: key_status 0" <br />
"debounce_hw_timer_callback: Key press" will be printed in DebugAnalyzer. <br />
Release KEY1: string "key_handler: key_status 1" <br />
"debounce_hw_timer_callback: Key release" will be printed in DebugAnalyzer.   </td></tr>
</table>
<div style="page-break-after: always;"></div><center><div id="table_5_8"><b>Table 5-8 GPIO Sample Code 8 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 8  </th><th class="markdownTableHeadNone">gpio_edge_key.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:180px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:670px">Demonstrates GPIO used as a key by edge trigger mode with hw debounce.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Brief Introduction  </td><td class="markdownTableBodyNone">This sample code demonstrates the detection of GPIO input through interrupt. When button is pressed (P0_0 changes from high level to low level), the falling edge of <br />
GPIO is detected and the GPIO interrupt is triggered. Then switch the edge trigger, <br />
after button is released (P0_0 changes from low level to high level), the GPIO <br />
interrupt is triggered again.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\gpio\key\edge\gpio_edge_key.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">gpio_edge_key()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">GPIO Direction  </td><td class="markdownTableBodyNone">input mode   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">As shown in Figure 5-1. On EVB, connect P0_0 and KEY1.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">Press RESET on the EVB.<br />
Press KEY1: string "key_handler: Key press" will be printed in DebugAnalyzer. <br />
Release KEY1: string "key_handler: Key release" will be printed in DebugAnalyzer.   </td></tr>
</table>
<center><div id="table_5_9"><b>Table 5-9 GPIO Sample Code 9 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 9  </th><th class="markdownTableHeadNone">dma_tim_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:180px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:670px">Demonstrates how GPIO receives data by GDMA Singleblock or Multiblock <br />
transfer.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Brief Introduction  </td><td class="markdownTableBodyNone">This sample code demonstrates the communication between GPIO and PC through <br />
GDMA. The Handshake is realized by hw timer. PC transmits some data to GPIO. <br />
GDMA can select Singleblock or Multiblock transfer through <br />
GDMA_Multi_Block_En.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\gdma\multiblock_tim_gpio\dma_tim_demo.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">GPIO Direction  </td><td class="markdownTableBodyNone">output mode   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">GDMA Direction  </td><td class="markdownTableBodyNone">Memory to Peripheral   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">dma_tim_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">None.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">Press RESET on the EVB. Use Logic Analyzer to capture the waveform of P0_2, and the output waveform results of Singleblock or Multiblock are shown in Figure 5-2.   </td></tr>
</table>
<div class="image">
<img src="GPIO_Hardware_Connection_Diagram.jpg" alt="GPIO_Hardware_Connection_Diagram.jpg"/>
</div>
 <center><div id="figure_5_1"><b>Figure 5-1 GPIO Hardware Connection Diagram</b></div></center><div class="image">
<img src="GPIO_DMA_Result_Diagram.jpg" alt="GPIO_DMA_Result_Diagram.jpg"/>
</div>
 <center><div id="figure_5_2"><b>Figure 5-2 GPIO DMA Result Diagram</b></div></center><h3><a class="anchor" id="GPIO_Function_Description"></a>
5.2  Function Description</h3>
<p>The GPIO integrated core is programmable general purpose input/output, each GPIO pin can be configured by software as an output, input or interrupt peripheral function.</p>
<h3><a class="anchor" id="GPIO_Feature_List"></a>
5.3  Feature List</h3>
<ul>
<li>Up to 3 ports, A, B, and C, which are separately configurable</li>
<li>32 independently configured GPIO signals in every port, independently controllable signal bits</li>
<li>Support hardware and software control</li>
<li>Support input and output control</li>
<li>Support level-triggered and edge-triggered interrupt</li>
<li>Support low and high level-triggered interrupts</li>
<li>Support rising and falling edge-triggered interrupts</li>
<li>Support both-edge-triggered interrupt</li>
<li>Support hardware debounce function</li>
<li>Support GPIO+TIMER+GDMA function</li>
</ul>
<p><b>Note:</b> RTL87X3D supports 3 ports, RTL87X3E supports 2 ports, RTL87X3G supports 1 port.</p>
<p><b>Note:</b> When the GPIO is controlled by GDMA, it should be configured in hardware mode.</p>
<h3><a class="anchor" id="GPIO_Initialization_Flow"></a>
5.4  GPIO Initialization Flow</h3>
<p>GPIO initialization flow is shown in Figure 5-3.</p>
<div class="image">
<img src="GPIO_Initialization_Flow_Chart.jpg" alt="GPIO_Initialization_Flow_Chart.jpg"/>
</div>
 <center><div id="figure_5_3"><b>Figure 5-3 GPIO Initialization Flow Chart</b></div></center><h4><a class="anchor" id="GPIO_Input_Mode"></a>
5.4.1  Input Mode</h4>
<p>The codes below show the operation flow of GPIO in input mode. </p><div class="fragment"><div class="line"><a class="code" href="group__x3d___h_a_l___g_p_i_o___h__.html#gab5ae6f712980fbf6f16ecb6dc8ae1a36">hal_gpio_init</a>();</div><div class="line"><a class="code" href="group__x3d___h_a_l___g_p_i_o___h__.html#ga3826ae3324dab5d23192d2101f2cab3b">hal_gpio_init_pin</a>(TEST_Pin, <a class="code" href="group__x3e___h_a_l___g_p_i_o___h__.html#gga18690463b43fb88963baf1098b54f075af9c945172bdc28d142ed7e79af279f32">GPIO_TYPE_AUTO</a>, <a class="code" href="group__x3e___h_a_l___g_p_i_o___h__.html#gga83e087b95bdbbc7626f48a407120b429a3f9cca83af864e65a125bb363f5cc1a6">GPIO_DIR_INPUT</a>, <a class="code" href="group__x3e___h_a_l___g_p_i_o___h__.html#ggac9b234191aefcbffa9f5cbfcb67ba911ae7d1b2a9078939dd744dd9a7cd61d9df">GPIO_PULL_UP</a>);</div><div class="line"></div><div class="line">gpio_value  = <a class="code" href="group__x3d___h_a_l___g_p_i_o___h__.html#ga72f8dccebef04fca81c21d69ede70381">hal_gpio_get_input_level</a>(TEST_Pin);</div></div><!-- fragment --><h4><a class="anchor" id="GPIO_Output_Mode"></a>
5.4.2  Output Mode</h4>
<p>The codes below show the operation flow of GPIO in output mode. </p><div class="fragment"><div class="line"><a class="code" href="group__x3d___h_a_l___g_p_i_o___h__.html#gab5ae6f712980fbf6f16ecb6dc8ae1a36">hal_gpio_init</a>();</div><div class="line"><a class="code" href="group__x3d___h_a_l___g_p_i_o___h__.html#ga3826ae3324dab5d23192d2101f2cab3b">hal_gpio_init_pin</a>(TEST_PIN, <a class="code" href="group__x3e___h_a_l___g_p_i_o___h__.html#gga18690463b43fb88963baf1098b54f075ad6bf32430a2b7af6721521d3e247f978">GPIO_TYPE_CORE</a>, <a class="code" href="group__x3e___h_a_l___g_p_i_o___h__.html#gga83e087b95bdbbc7626f48a407120b429a2faef38751d4761242d11663f4cf75e5">GPIO_DIR_OUTPUT</a>, <a class="code" href="group__x3e___h_a_l___g_p_i_o___h__.html#ggac9b234191aefcbffa9f5cbfcb67ba911ae7d1b2a9078939dd744dd9a7cd61d9df">GPIO_PULL_UP</a>);</div><div class="line"><a class="code" href="group__x3d___h_a_l___g_p_i_o___h__.html#ga3826ae3324dab5d23192d2101f2cab3b">hal_gpio_init_pin</a>(TEST_PIN_2, <a class="code" href="group__x3e___h_a_l___g_p_i_o___h__.html#gga18690463b43fb88963baf1098b54f075a4558e2fc1e35a2f4c0b285b06fda30fc">GPIO_TYPE_AON</a>, <a class="code" href="group__x3e___h_a_l___g_p_i_o___h__.html#gga83e087b95bdbbc7626f48a407120b429a2faef38751d4761242d11663f4cf75e5">GPIO_DIR_OUTPUT</a>, <a class="code" href="group__x3e___h_a_l___g_p_i_o___h__.html#ggac9b234191aefcbffa9f5cbfcb67ba911ae7d1b2a9078939dd744dd9a7cd61d9df">GPIO_PULL_UP</a>);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (uint16_t i = 0; i &lt; 10; i++)</div><div class="line">{</div><div class="line">    <a class="code" href="group__x3d___h_a_l___g_p_i_o___h__.html#ga88ecffdd260f46bcb6b9f9aa95c83e97">hal_gpio_set_level</a>(TEST_PIN, <a class="code" href="group__x3e___h_a_l___g_p_i_o___h__.html#ggaad2a5fc083589d27cc58e3e2de7b932fa0227e43a6201c3330b2e6e9f71b74d6f">GPIO_LEVEL_LOW</a>);</div><div class="line">    <a class="code" href="group__x3d___h_a_l___g_p_i_o___h__.html#ga88ecffdd260f46bcb6b9f9aa95c83e97">hal_gpio_set_level</a>(TEST_PIN_2, <a class="code" href="group__x3e___h_a_l___g_p_i_o___h__.html#ggaad2a5fc083589d27cc58e3e2de7b932fa0227e43a6201c3330b2e6e9f71b74d6f">GPIO_LEVEL_LOW</a>);</div><div class="line">    <a class="code" href="group__x3d___h_a_l___g_p_i_o___h__.html#ga88ecffdd260f46bcb6b9f9aa95c83e97">hal_gpio_set_level</a>(TEST_PIN, <a class="code" href="group__x3e___h_a_l___g_p_i_o___h__.html#ggaad2a5fc083589d27cc58e3e2de7b932fa5a87f4701da8987969657f9ffb2563e0">GPIO_LEVEL_HIGH</a>);</div><div class="line">    <a class="code" href="group__x3d___h_a_l___g_p_i_o___h__.html#ga88ecffdd260f46bcb6b9f9aa95c83e97">hal_gpio_set_level</a>(TEST_PIN_2, <a class="code" href="group__x3e___h_a_l___g_p_i_o___h__.html#ggaad2a5fc083589d27cc58e3e2de7b932fa5a87f4701da8987969657f9ffb2563e0">GPIO_LEVEL_HIGH</a>);</div><div class="line">}</div></div><!-- fragment --><h4><a class="anchor" id="GPIO_Interrupt_Mode"></a>
5.4.3  Interrupt Mode</h4>
<p>The codes below show the operation flow of GPIO in interrupt mode. </p><div class="fragment"><div class="line"><a class="code" href="group__x3d___h_a_l___g_p_i_o___h__.html#gab5ae6f712980fbf6f16ecb6dc8ae1a36">hal_gpio_init</a>();</div><div class="line"><a class="code" href="group__x3d___g_p_i_o___i_n_t___h__.html#ga960816c8e05cc820f66af432bc6de7ad">hal_gpio_int_init</a>();</div><div class="line"><a class="code" href="group__x3d___h_a_l___g_p_i_o___h__.html#gae5cfebfbc696e4b26c22a682a2bab5e5">hal_gpio_set_debounce_time</a>(30);</div><div class="line"></div><div class="line"><a class="code" href="group__x3d___h_a_l___g_p_i_o___h__.html#ga3826ae3324dab5d23192d2101f2cab3b">hal_gpio_init_pin</a>(GPIO_DEMO_INPUT_PIN0, <a class="code" href="group__x3e___h_a_l___g_p_i_o___h__.html#gga18690463b43fb88963baf1098b54f075af9c945172bdc28d142ed7e79af279f32">GPIO_TYPE_AUTO</a>, <a class="code" href="group__x3e___h_a_l___g_p_i_o___h__.html#gga83e087b95bdbbc7626f48a407120b429a3f9cca83af864e65a125bb363f5cc1a6">GPIO_DIR_INPUT</a>, <a class="code" href="group__x3e___h_a_l___g_p_i_o___h__.html#ggac9b234191aefcbffa9f5cbfcb67ba911ae7d1b2a9078939dd744dd9a7cd61d9df">GPIO_PULL_UP</a>);</div><div class="line"><a class="code" href="group__x3d___h_a_l___g_p_i_o___h__.html#ga3826ae3324dab5d23192d2101f2cab3b">hal_gpio_init_pin</a>(GPIO_DEMO_INPUT_PIN1, <a class="code" href="group__x3e___h_a_l___g_p_i_o___h__.html#gga18690463b43fb88963baf1098b54f075af9c945172bdc28d142ed7e79af279f32">GPIO_TYPE_AUTO</a>, <a class="code" href="group__x3e___h_a_l___g_p_i_o___h__.html#gga83e087b95bdbbc7626f48a407120b429a3f9cca83af864e65a125bb363f5cc1a6">GPIO_DIR_INPUT</a>, <a class="code" href="group__x3e___h_a_l___g_p_i_o___h__.html#ggac9b234191aefcbffa9f5cbfcb67ba911a93970a9b4ab92816371682f4e537a8e2">GPIO_PULL_DOWN</a>);</div><div class="line"><a class="code" href="group__x3d___h_a_l___g_p_i_o___h__.html#ga3826ae3324dab5d23192d2101f2cab3b">hal_gpio_init_pin</a>(GPIO_DEMO_INPUT_PIN2, <a class="code" href="group__x3e___h_a_l___g_p_i_o___h__.html#gga18690463b43fb88963baf1098b54f075af9c945172bdc28d142ed7e79af279f32">GPIO_TYPE_AUTO</a>, <a class="code" href="group__x3e___h_a_l___g_p_i_o___h__.html#gga83e087b95bdbbc7626f48a407120b429a3f9cca83af864e65a125bb363f5cc1a6">GPIO_DIR_INPUT</a>, <a class="code" href="group__x3e___h_a_l___g_p_i_o___h__.html#ggac9b234191aefcbffa9f5cbfcb67ba911ae7d1b2a9078939dd744dd9a7cd61d9df">GPIO_PULL_UP</a>);</div><div class="line"><a class="code" href="group__x3d___h_a_l___g_p_i_o___h__.html#ga3826ae3324dab5d23192d2101f2cab3b">hal_gpio_init_pin</a>(GPIO_DEMO_INPUT_PIN3, <a class="code" href="group__x3e___h_a_l___g_p_i_o___h__.html#gga18690463b43fb88963baf1098b54f075af9c945172bdc28d142ed7e79af279f32">GPIO_TYPE_AUTO</a>, <a class="code" href="group__x3e___h_a_l___g_p_i_o___h__.html#gga83e087b95bdbbc7626f48a407120b429a3f9cca83af864e65a125bb363f5cc1a6">GPIO_DIR_INPUT</a>, <a class="code" href="group__x3e___h_a_l___g_p_i_o___h__.html#ggac9b234191aefcbffa9f5cbfcb67ba911a93970a9b4ab92816371682f4e537a8e2">GPIO_PULL_DOWN</a>);</div><div class="line"></div><div class="line"><a class="code" href="group__x3d___h_a_l___g_p_i_o___h__.html#ga33877bb6f864bf13365d530ea498f829">hal_gpio_set_up_irq</a>(GPIO_DEMO_INPUT_PIN0, <a class="code" href="group__x3e___h_a_l___g_p_i_o___h__.html#ggaf9fd97f2ddde04dd3ae2a54dbc0f27f7a2636d7c0a40a6aa62fdeab06e5343914">GPIO_IRQ_EDGE</a>, <a class="code" href="group__x3e___h_a_l___g_p_i_o___h__.html#gga73aa619532bdbf9d2b620ec419641690ad67ef08eb10e464490335f1267f5d61b">GPIO_IRQ_ACTIVE_LOW</a>, <span class="keyword">true</span>);</div><div class="line"><a class="code" href="group__x3d___h_a_l___g_p_i_o___h__.html#ga33877bb6f864bf13365d530ea498f829">hal_gpio_set_up_irq</a>(GPIO_DEMO_INPUT_PIN1, <a class="code" href="group__x3e___h_a_l___g_p_i_o___h__.html#ggaf9fd97f2ddde04dd3ae2a54dbc0f27f7a2636d7c0a40a6aa62fdeab06e5343914">GPIO_IRQ_EDGE</a>, <a class="code" href="group__x3e___h_a_l___g_p_i_o___h__.html#gga73aa619532bdbf9d2b620ec419641690a3e3edb0a796ad9411de885e2a7e8f45b">GPIO_IRQ_ACTIVE_HIGH</a>, <span class="keyword">true</span>);</div><div class="line"><a class="code" href="group__x3d___h_a_l___g_p_i_o___h__.html#ga33877bb6f864bf13365d530ea498f829">hal_gpio_set_up_irq</a>(GPIO_DEMO_INPUT_PIN2, <a class="code" href="group__x3e___h_a_l___g_p_i_o___h__.html#ggaf9fd97f2ddde04dd3ae2a54dbc0f27f7a2636d7c0a40a6aa62fdeab06e5343914">GPIO_IRQ_EDGE</a>, <a class="code" href="group__x3e___h_a_l___g_p_i_o___h__.html#gga73aa619532bdbf9d2b620ec419641690ad67ef08eb10e464490335f1267f5d61b">GPIO_IRQ_ACTIVE_LOW</a>, <span class="keyword">true</span>);</div><div class="line"><a class="code" href="group__x3d___h_a_l___g_p_i_o___h__.html#ga33877bb6f864bf13365d530ea498f829">hal_gpio_set_up_irq</a>(GPIO_DEMO_INPUT_PIN3, <a class="code" href="group__x3e___h_a_l___g_p_i_o___h__.html#ggaf9fd97f2ddde04dd3ae2a54dbc0f27f7a2636d7c0a40a6aa62fdeab06e5343914">GPIO_IRQ_EDGE</a>, <a class="code" href="group__x3e___h_a_l___g_p_i_o___h__.html#gga73aa619532bdbf9d2b620ec419641690a3e3edb0a796ad9411de885e2a7e8f45b">GPIO_IRQ_ACTIVE_HIGH</a>, <span class="keyword">true</span>);</div><div class="line"></div><div class="line"><a class="code" href="group__x3d___g_p_i_o___i_n_t___h__.html#ga986785a267647c840ad807c08dffa9c9">hal_gpio_register_isr_callback</a>(GPIO_DEMO_INPUT_PIN0, gpio_isr_cb, GPIO_DEMO_INPUT_PIN0);</div><div class="line"><a class="code" href="group__x3d___g_p_i_o___i_n_t___h__.html#ga986785a267647c840ad807c08dffa9c9">hal_gpio_register_isr_callback</a>(GPIO_DEMO_INPUT_PIN1, gpio_isr_cb, GPIO_DEMO_INPUT_PIN1);</div><div class="line"><a class="code" href="group__x3d___g_p_i_o___i_n_t___h__.html#ga986785a267647c840ad807c08dffa9c9">hal_gpio_register_isr_callback</a>(GPIO_DEMO_INPUT_PIN2, gpio_isr_cb, GPIO_DEMO_INPUT_PIN2);</div><div class="line"><a class="code" href="group__x3d___g_p_i_o___i_n_t___h__.html#ga986785a267647c840ad807c08dffa9c9">hal_gpio_register_isr_callback</a>(GPIO_DEMO_INPUT_PIN3, gpio_isr_cb, GPIO_DEMO_INPUT_PIN3);</div><div class="line"></div><div class="line"><a class="code" href="group__x3d___h_a_l___g_p_i_o___h__.html#gaae922b7d64d09b96637d21715a386260">hal_gpio_irq_enable</a>(GPIO_DEMO_INPUT_PIN0);</div><div class="line"><a class="code" href="group__x3d___h_a_l___g_p_i_o___h__.html#gaae922b7d64d09b96637d21715a386260">hal_gpio_irq_enable</a>(GPIO_DEMO_INPUT_PIN1);</div><div class="line"><a class="code" href="group__x3d___h_a_l___g_p_i_o___h__.html#gaae922b7d64d09b96637d21715a386260">hal_gpio_irq_enable</a>(GPIO_DEMO_INPUT_PIN2);</div><div class="line"><a class="code" href="group__x3d___h_a_l___g_p_i_o___h__.html#gaae922b7d64d09b96637d21715a386260">hal_gpio_irq_enable</a>(GPIO_DEMO_INPUT_PIN3);</div></div><!-- fragment --><div style="page-break-after: always;"></div><h2><a class="anchor" id="TIM"></a>
6  TIMER and PWM</h2>
<h3><a class="anchor" id="TIM_Demo_Code_Support_List"></a>
6.1 TIMER and PWM Demo Code Support List</h3>
<center><div id="table_6_1"><b>Table 6-1 TIMER and PWM Sample Code 1 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 1  </th><th class="markdownTableHeadNone">tim_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:180px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:670px">Demonstrates how hardware timer module work in reload mode and it will trigger <br />
interrupt every 3 seconds.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\tim\interrupt\tim_demo.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">tim_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Timeout  </td><td class="markdownTableBodyNone">3 seconds   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">Print string "demo_hw_timer_callback" in DebugAnalyzer every 3 seconds.   </td></tr>
</table>
<center><div id="table_6_2"><b>Table 6-2 TIMER and PWM Sample Code 2 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 2  </th><th class="markdownTableHeadNone">pwm_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:180px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:670px">Demonstrates PWM output and PWM complementary output and deadzone.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\tim\pwm\pwm_demo.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">pwm_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">Connect M0_0 of EVB to channel0 of logic analyzer and connect M0_2 of EVB to <br />
channel1 of logic analyzer and connect M0_3 of EVB to channel2 of logic analyzer.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">The waveforms displayed by channels 0/1/2 of the logic analyzer are shown in <br />
Figure 6-1.   </td></tr>
</table>
<center><div id="table_6_3"><b>Table 6-3 TIMER and PWM Sample Code 3 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 3  </th><th class="markdownTableHeadNone">led_demo_task.c<br />
sw_led_demo.c<br />
sw_led_demo.h   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:180px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:670px">Demonstrates how to realize the effect of breath light by PWM.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\led\led_demo_task.c<br />
sdk\src\sample\io_demo\led\sw_led_demo.c<br />
sdk\src\sample\io_demo\led\sw_led_demo.h   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">led_demo_task()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">On EVB, connect M2_1 to LED0 and connect M2_2 to LED1 and connect M2_7 to <br />
LED2.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">LEDs turn from dark to bright and then from bright to dark with the effect of breath <br />
light.   </td></tr>
</table>
<div class="image">
<img src="PWM_Demo_Expected_Result_Diagram.jpg" alt="PWM_Demo_Expected_Result_Diagram.jpg"/>
</div>
 <center><div id="figure_6_1"><b>Figure 6-1 PWM Demo Expected Result Diagram</b></div></center><h3><a class="anchor" id="TIM_Function_Description"></a>
6.2  Function Description</h3>
<p>The hardware timer consists of a 32-bit automatic load counter with an optional clock source. Each timer is completely independent and does not share any resources. They can operate synchronously together. The timer operation mode is divided into user-defined count mode and free-running mode. In user-defined count mode, the timer counts down from the value set by the user. In free-running mode, the timer counts down from 0xffffffff. When the timer counter is enabled after being reset or disabled, the timer counts down from its initial value, and when it reaches 0, an interrupt is triggered. The clock source of timer can be selected from fixed 40MHz clock and PLL clock. The clock of timer is obtained by the above-mentioned clock source after two-stage frequency division. The first-level frequency division is shared, and the second-level frequency division is independent of each other, which is divided into five gears of 1/2/4/8/40.</p>
<p><b>Note:</b> Only timer2 ~ timer7 can select the PLL clock as the clock source.</p>
<h3><a class="anchor" id="TIM_Feature_List"></a>
6.3  Feature List</h3>
<ul>
<li>Up to 16 timers</li>
<li>Two operation modes: user-defined count mode and free-running mode</li>
<li>Timer width: 32 bits</li>
<li>Each timer supports PWM output mode</li>
<li>Timer2 and timer3 support PWM complementary output mode</li>
<li>Timer2 and timer3 Support deadzone</li>
<li>Timer2 and timer3 Support emergency stop control</li>
</ul>
<p><b>Note:</b> RTL87X3D supports up to 16 hw timers, 12 of which can be used for application.<br />
 RTL87X3E supports up to 8 hw timers, 5 of which can be used for application.<br />
 RTL87X3G supports up to 8 hw timers, 5 of which can be used for application.<br />
 HW Timer 0 and Timer 1 are reserved for low stack.<br />
 HW Timer 7 is reserved for log time stamp.<br />
</p>
<div style="page-break-after: always;"></div><h3><a class="anchor" id="TIM_TIMER_Operation_Flow"></a>
6.4  TIMER Operation Flow</h3>
<p>The codes below show TIMER operation flow. For details, please refer to src\sample\io_demo\tim\interrupt\tim_demo.c </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> tim_driver_init(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* Create the timer, user-defined mode, the period is 3 seconds. */</span></div><div class="line">    demo_timer_handle = <a class="code" href="group___h_w___t_i_m___exported___functions.html#gaf99a867dfdd34bbeb67989388b6022c9">hw_timer_create</a>(<span class="stringliteral">&quot;demo_hw_timer&quot;</span>, 3000 * 1000, <span class="keyword">true</span>, demo_hw_timer_callback);</div><div class="line">    <span class="keywordflow">if</span> (demo_timer_handle == <a class="code" href="group___platform___types___exported___macros.html#ga070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)</div><div class="line">    {</div><div class="line">        IO_PRINT_ERROR0(<span class="stringliteral">&quot;tim_driver_init: fail to create hw timer, check hw timer usage&quot;</span>);</div><div class="line">        <span class="keywordflow">return</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    IO_PRINT_TRACE1(<span class="stringliteral">&quot;tim_driver_init: create hw timer instance successfully, id %d&quot;</span>,</div><div class="line">                    <a class="code" href="group___h_w___t_i_m___exported___functions.html#gac83e01f633698f8401e548481aca0fcb">hw_timer_get_id</a>(demo_timer_handle));</div><div class="line"></div><div class="line">    <span class="comment">/* Start the specified timer */</span></div><div class="line">    <a class="code" href="group___h_w___t_i_m___exported___functions.html#ga239c129fa692ab7328424e40a2a48e75">hw_timer_start</a>(demo_timer_handle);</div><div class="line">}</div></div><!-- fragment --><p>When the timer counts to zero, the contents of the callback function will be executed. The codes below show TIMER callback handle flow. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> demo_hw_timer_callback(<a class="code" href="group___h_w___t_i_m___exported___types.html#ga09f0eca4d24ba3eb999603118b8cab28">T_HW_TIMER_HANDLE</a> handle)</div><div class="line">{</div><div class="line">    <span class="comment">//Add User code here</span></div><div class="line">    IO_PRINT_TRACE0(<span class="stringliteral">&quot;demo_hw_timer_callback&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><p><b>Note:</b> If the callback function (cback) is not NULL, the period value (period_us) must be greater than or equal to 5.</p>
<div style="page-break-after: always;"></div><h3><a class="anchor" id="TIM_PWM_Operation_Flow"></a>
6.5  PWM Operation Flow</h3>
<p>The codes below show PWM operation flow. For details, please refer to src\sample\io_demo\tim\pwm\pwm_demo.c </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> driver_pwm_init(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="struct___t___h_w___t_i_m_e_r___p_w_m.html">T_PWM_CONFIG</a> demo_pwm_deadzone_para;</div><div class="line"></div><div class="line">    <span class="comment">/* Create the PWM, high level time is 2 seconds, low level time is 2 seconds */</span></div><div class="line">    demo_pwm_handle = <a class="code" href="group___p_w_m___exported___functions.html#ga7b15efe253d8c927c21e163f1a02cc6b">pwm_create</a>(<span class="stringliteral">&quot;demo_pwm&quot;</span>, PWM_HIGH_LEVEL_CNT, PWM_LOW_LEVEL_CNT, <span class="keyword">false</span>);</div><div class="line">    <span class="keywordflow">if</span> (demo_pwm_handle == <a class="code" href="group___platform___types___exported___macros.html#ga070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)</div><div class="line">    {</div><div class="line">        IO_PRINT_ERROR0(<span class="stringliteral">&quot;driver_pwm_init: Fail to create pwm handle&quot;</span>);</div><div class="line">        <span class="keywordflow">return</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Configure PIN ADC_0 as PWM output */</span></div><div class="line">    <a class="code" href="group___p_w_m___exported___functions.html#gaaf148e129133994010db44f8b3a5df41">pwm_pin_config</a>(demo_pwm_handle, PWM_OUT_PIN, <a class="code" href="group___p_w_m___exported__constants.html#ggab297bdd225e23d95f99b841a2ac08f8eafabb0a128607c428a6831664d31488bc">PWM_FUNC</a>);</div><div class="line">    <span class="comment">/* Start the specified PWM */</span></div><div class="line">    <a class="code" href="group___p_w_m___exported___functions.html#ga6d84c88eb8292a41e25578882b9e6fab">pwm_start</a>(demo_pwm_handle);</div><div class="line"></div><div class="line">    <span class="comment">/* Create the PWM, deadzone is enabled. */</span></div><div class="line">    demo_pwm_deadzone_handle = <a class="code" href="group___p_w_m___exported___functions.html#ga7b15efe253d8c927c21e163f1a02cc6b">pwm_create</a>(<span class="stringliteral">&quot;demo_pwm_deadzone&quot;</span>, PWM_HIGH_LEVEL_CNT, PWM_LOW_LEVEL_CNT,</div><div class="line">                                          <span class="keyword">true</span>);</div><div class="line">    <span class="keywordflow">if</span> (demo_pwm_deadzone_handle == <a class="code" href="group___platform___types___exported___macros.html#ga070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)</div><div class="line">    {</div><div class="line">        IO_PRINT_ERROR0(<span class="stringliteral">&quot;driver_pwm_init: Fail to create pwm deadzone handle&quot;</span>);</div><div class="line">        <span class="keywordflow">return</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Set high level time */</span></div><div class="line">    demo_pwm_deadzone_para.<a class="code" href="struct___t___h_w___t_i_m_e_r___p_w_m.html#a716c1e02c059936b57f1387cdde40138">pwm_high_count</a> = PWM_HIGH_LEVEL_CNT;</div><div class="line">    <span class="comment">/* Set low level time */</span></div><div class="line">    demo_pwm_deadzone_para.<a class="code" href="struct___t___h_w___t_i_m_e_r___p_w_m.html#a2847465b2dc88fe1aa5cebbf364a4424">pwm_low_count</a> = PWM_LOW_LEVEL_CNT;</div><div class="line">    <span class="comment">/* Enable deadzone */</span></div><div class="line">    demo_pwm_deadzone_para.<a class="code" href="struct___t___h_w___t_i_m_e_r___p_w_m.html#a332a7ff31698e28f9fb14329d2fa10e6">pwm_deadzone_enable</a> = <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>;</div><div class="line">    <span class="comment">/* Configure PWM clock source as 1MHz */</span></div><div class="line">    demo_pwm_deadzone_para.<a class="code" href="struct___t___h_w___t_i_m_e_r___p_w_m.html#a2ec1ece92e684405f9c1c7f603d83e45">clock_source</a> = <a class="code" href="group___p_w_m___exported__constants.html#ggaed2d6ac3ebb52ddd5bcc1fe508edbc5aa1e97b2d29499efaa81d65a8d4ab43c3f">PWM_CLOCK_1M</a>;</div><div class="line">    <span class="comment">/* Set deadzone size count, count frequnce is 32K */</span></div><div class="line">    demo_pwm_deadzone_para.<a class="code" href="struct___t___h_w___t_i_m_e_r___p_w_m.html#ab04b8a15c55ad2c404edef95dc1b8ccb">pwm_deadzone_size</a> = PWM_DEADZONE_SIZE_CNT;</div><div class="line">    <span class="comment">/* Configure PWM_P emergency stop state as low level */</span></div><div class="line">    demo_pwm_deadzone_para.<a class="code" href="struct___t___h_w___t_i_m_e_r___p_w_m.html#af352d76487fb844295618fd47a010f95">pwm_p_stop_state</a> = <a class="code" href="group___p_w_m___exported__constants.html#gga159d00f59f41976774d7595a926607f6ad7b18408e4ac71f55ac369bf76a96fba">PWM_DEAD_ZONE_STOP_LOW</a>;</div><div class="line">    <span class="comment">/* Configure PWM_N emergency stop state as high level */</span></div><div class="line">    demo_pwm_deadzone_para.<a class="code" href="struct___t___h_w___t_i_m_e_r___p_w_m.html#a372eb380a6a937c6aa3f7304b7aa1a61">pwm_n_stop_state</a> = <a class="code" href="group___p_w_m___exported__constants.html#gga159d00f59f41976774d7595a926607f6a0f9d1d69e25d2bc57ee1152b7ff03bc4">PWM_DEAD_ZONE_STOP_HIGH</a>;</div><div class="line">    <span class="comment">/* Initialize PWM */</span></div><div class="line">    <a class="code" href="group___p_w_m___exported___functions.html#ga1bd5ae17a7494167d226999fa9ba27ac">pwm_config</a>(demo_pwm_deadzone_handle, &amp;demo_pwm_deadzone_para);</div><div class="line"></div><div class="line">    <span class="comment">/* Configure PIN ADC_2 as PWM_P output */</span></div><div class="line">    <a class="code" href="group___p_w_m___exported___functions.html#gaaf148e129133994010db44f8b3a5df41">pwm_pin_config</a>(demo_pwm_deadzone_handle, PWM_OUT_PIN_P, <a class="code" href="group___p_w_m___exported__constants.html#ggab297bdd225e23d95f99b841a2ac08f8eac6312abcefd2d71a3a023d316550adc3">PWM_FUNC_P</a>);</div><div class="line">    <span class="comment">/* Configure PIN ADC_3 as PWM_N output */</span></div><div class="line">    <a class="code" href="group___p_w_m___exported___functions.html#gaaf148e129133994010db44f8b3a5df41">pwm_pin_config</a>(demo_pwm_deadzone_handle, PWM_OUT_PIN_N, <a class="code" href="group___p_w_m___exported__constants.html#ggab297bdd225e23d95f99b841a2ac08f8ea33823e53a7f72209fe4256fada734d33">PWM_FUNC_N</a>);</div><div class="line">    <span class="comment">/* Start the specified PWM */</span></div><div class="line">    <a class="code" href="group___p_w_m___exported___functions.html#ga6d84c88eb8292a41e25578882b9e6fab">pwm_start</a>(demo_pwm_deadzone_handle);</div><div class="line">}</div></div><!-- fragment --><div style="page-break-after: always;"></div><h2><a class="anchor" id="UART"></a>
7  UART</h2>
<h3><a class="anchor" id="UART_Demo_Code_Support_List"></a>
7.1 UART Demo Code Support List</h3>
<center><div id="table_7_1"><b>Table 7-1 UART Sample Code 1 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 1  </th><th class="markdownTableHeadNone">uart_polling_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:200px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:650px">Demonstrate how UART sends and receives data in polling mode.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Brief Introduction  </td><td class="markdownTableBodyNone">This sample code demonstrates the communication between chip and PC. PC <br />
transmits some data to chip and then chip returns the same data received to PC.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\uart\polling\uart_polling_demo.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">uart_polling_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">As shown in Figure 7-1.<br />
RTL87X3E: On EVB, TX is connected to M3_0, RX is connected to M3_1, <br />
FT_VIO is connected to VIO1, and CON3 is connected to PC.<br />
RTL87X3D: On EVB, TXD is connected to M3_0, RXD is connected to M3_1, <br />
FT_VIO is connected to VIO1, and P2 is connected to PC.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">UART TX PIN  </td><td class="markdownTableBodyNone">#define UART_TX_PIN P3_1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">UART RX PIN  </td><td class="markdownTableBodyNone">#define UART_RX_PIN P3_0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">UART ID  </td><td class="markdownTableBodyNone">UART0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Baud Rate  </td><td class="markdownTableBodyNone">115200   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Parity Check  </td><td class="markdownTableBodyNone">No Parity   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Data Format  </td><td class="markdownTableBodyNone">8-bit   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Stop Bit  </td><td class="markdownTableBodyNone">1-bit   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Hardware Flow Control  </td><td class="markdownTableBodyNone">None   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">1. Press RESET on the EVB, string <br />
"### Welcome to use RealTek Bumblebee ###\r\n" will be displayed in UART <br />
debug tool.<br />
2. Use UART debug tool to send data to chip, then chip will send the received <br />
same data back to PC and display the data in UART debug tool.   </td></tr>
</table>
<div style="page-break-after: always;"></div><center><div id="table_7_2"><b>Table 7-2 UART Sample Code 2 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 2  </th><th class="markdownTableHeadNone">uart_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:200px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:650px">Demonstrate how UART receives data in interrupt mode.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Brief Introduction  </td><td class="markdownTableBodyNone">This sample code demonstrates the communication between chip and PC. PC <br />
transmits some data to chip and then chip returns the same data received to PC.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\uart\interrupt\uart_demo.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">uart_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">As shown in Figure 7-1.<br />
RTL87X3E: On EVB, TX is connected to M3_0, RX is connected to M3_1, <br />
FT_VIO is connected to VIO1, and CON3 is connected to PC.<br />
RTL87X3D: On EVB, TXD is connected to M3_0, RXD is connected to M3_1, <br />
FT_VIO is connected to VIO1, and P2 is connected to PC.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">UART TX PIN  </td><td class="markdownTableBodyNone">#define UART_TX_PIN P3_1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">UART RX PIN  </td><td class="markdownTableBodyNone">#define UART_RX_PIN P3_0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">UART ID  </td><td class="markdownTableBodyNone">UART0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Baud Rate  </td><td class="markdownTableBodyNone">115200   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Parity Check  </td><td class="markdownTableBodyNone">No Parity   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Data Format  </td><td class="markdownTableBodyNone">8-bit   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Stop Bit  </td><td class="markdownTableBodyNone">1-bit   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Hardware Flow Control  </td><td class="markdownTableBodyNone">None   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">1. Press RESET on the EVB, string <br />
"### Welcome to use RealTek Bumblebee ###\r\n" will be displayed in UART <br />
debug tool.<br />
2. Use UART debug tool to send data to chip, then chip will send the received <br />
same data plus string "\r\n" back to PC and display the data in UART debug tool.   </td></tr>
</table>
<div style="page-break-after: always;"></div><center><div id="table_7_3"><b>Table 7-3 UART Sample Code 3 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 3  </th><th class="markdownTableHeadNone">uart_tx_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:200px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:650px">Demonstrate how UART sends data in interrupt mode.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Brief Introduction  </td><td class="markdownTableBodyNone">This sample code demonstrates the communication between chip and PC. Chip <br />
transmits some data to PC.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\uart\interrupt\uart_tx_demo.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">uart_tx_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">As shown in Figure 7-1.<br />
RTL87X3E: On EVB, TX is connected to M3_0, RX is connected to M3_1, <br />
FT_VIO is connected to VIO1, and CON3 is connected to PC.<br />
RTL87X3D: On EVB, TXD is connected to M3_0, RXD is connected to M3_1, <br />
FT_VIO is connected to VIO1, and P2 is connected to PC.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">UART TX PIN  </td><td class="markdownTableBodyNone">#define UART_TX_PIN P3_1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">UART RX PIN  </td><td class="markdownTableBodyNone">#define UART_RX_PIN P3_0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">UART ID  </td><td class="markdownTableBodyNone">UART0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Baud Rate  </td><td class="markdownTableBodyNone">115200   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Parity Check  </td><td class="markdownTableBodyNone">No Parity   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Data Format  </td><td class="markdownTableBodyNone">8-bit   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Stop Bit  </td><td class="markdownTableBodyNone">1-bit   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Hardware Flow Control  </td><td class="markdownTableBodyNone">None   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">Press RESET on the EVB, string <br />
"### Welcome to use RealTek Bumblebee ###\r\n" will be displayed in UART <br />
debug tool.   </td></tr>
</table>
<div style="page-break-after: always;"></div><center><div id="table_7_4"><b>Table 7-4 UART Sample Code 4 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 4  </th><th class="markdownTableHeadNone">uart_fc_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:200px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:650px">Demonstrate how UART sends and receives data with hardware flow control.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Brief Introduction  </td><td class="markdownTableBodyNone">This sample code demonstrates the communication between chip and PC. PC <br />
transmits some data to chip and then chip returns the same data received to PC.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\uart\hw_flow_control\uart_fc_demo.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">uart_fc_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">As shown in Figure 7-2.<br />
RTL87X3E: On EVB, TX is connected to M3_0, RX is connected to M3_1, RTS is connected to M0_0, CTS is connected to M0_1, FT_VIO is connected to VIO1, <br />
and CON3 is connected to PC.<br />
RTL87X3D: On EVB, TXD is connected to M3_0, RXD is connected to M3_1, <br />
RTS is connected to M0_0, CTS is connected to M0_1, FT_VIO is connected to <br />
VIO1, and P2 is connected to PC.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">UART TX PIN  </td><td class="markdownTableBodyNone">#define UART_TX_PIN P3_1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">UART RX PIN  </td><td class="markdownTableBodyNone">#define UART_RX_PIN P3_0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">UART CTS PIN  </td><td class="markdownTableBodyNone">#define UART_CTS_PIN P0_0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">UART RTS PIN  </td><td class="markdownTableBodyNone">#define UART_RTS_PIN P0_1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">UART ID  </td><td class="markdownTableBodyNone">UART0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Baud Rate  </td><td class="markdownTableBodyNone">115200   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Parity Check  </td><td class="markdownTableBodyNone">No Parity   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Data Format  </td><td class="markdownTableBodyNone">8-bit   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Stop Bit  </td><td class="markdownTableBodyNone">1-bit   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Hardware Flow Control  </td><td class="markdownTableBodyNone">CTS and RTS Flow Control   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">1. Press RESET on the EVB, string <br />
"### Uart demo--Auto Hardware Flow Contrl ###\r\n" will be displayed in UART <br />
debug tool.<br />
2. Use UART debug tool to send data to chip, then chip will send the received <br />
same data plus string "\r\n" back to PC and display the data in UART debug tool.   </td></tr>
</table>
<div style="page-break-after: always;"></div><center><div id="table_7_5"><b>Table 7-5 UART Sample Code 5 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 5  </th><th class="markdownTableHeadNone">dlps_uart_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:200px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:650px">Demonstrates how UART wakes up the system from DLPS mode.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Brief Introduction  </td><td class="markdownTableBodyNone">This sample code demonstrates the communication between chip and PC. It <br />
realizes the function that transmits/receives data through UART and wakes up the <br />
system by UART after entering DLPS mode. System will enter DLPS mode <br />
automatically while it's in idle state. When some data is sent to chip, <br />
UART_RX_PIN will be pulled down to low level and wake up system to rebuild <br />
communication between PC and chip.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\uart\dlps\dlps_uart_demo.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">dlps_uart_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">As shown in Figure 7-1.<br />
RTL87X3E: On EVB, TX is connected to M3_0, RX is connected to M3_1, <br />
FT_VIO is connected to VIO1, and CON3 is connected to PC.<br />
RTL87X3D: On EVB, TXD is connected to M3_0, RXD is connected to M3_1, <br />
FT_VIO is connected to VIO1, and P2 is connected to PC.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">UART ID  </td><td class="markdownTableBodyNone">UART2   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Baud Rate  </td><td class="markdownTableBodyNone">115200   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Parity Check  </td><td class="markdownTableBodyNone">No Parity   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Data Format  </td><td class="markdownTableBodyNone">8-bit   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Stop Bit  </td><td class="markdownTableBodyNone">1-bit   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Hardware Flow Control  </td><td class="markdownTableBodyNone">None   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">1. Press RESET on the EVB, string <br />
"### Welcome to use RealTek Bumblebee ###\r\n" will be displayed in UART <br />
debug tool.<br />
2. When system is in idle state, it will enter DLPS mode automatically.<br />
 3. The first group of data will be sent to chip to wake up system and then data can be transmitted normally. Chip will send the data same with the data received back <br />
to PC, which will be displayed in UART debug tool.   </td></tr>
</table>
<div style="page-break-after: always;"></div><center><div id="table_7_6"><b>Table 7-6 UART Sample Code 6 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 6  </th><th class="markdownTableHeadNone">adp_1wire_uart_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:200px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:650px">Demonstrates how adp 1wire works.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Brief Introduction  </td><td class="markdownTableBodyNone">This sample code demonstrates how adp 1wire works. When the adapter plugs in, it works as UART RX. When the adapter plugs out, it works as GPIO.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\adp_1wire\adp_1wire_uart_demo.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">adp_1wire_uart_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">As shown in Figure 7-3.<br />
On EVB, the TX of PC UART is connected to VADP.<br />
RTL87X3E: On EVB, the capacitance of ADPIN on PCB needs to be replaced by <br />
100pF.<br />
RTL87X3D: The daughter board changes C186 to 100pf. The motherboard <br />
removes C164, DP38 and C71, and raises VAUX1 to 3.3V, connecting VIO4 <br />
to VAUX1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">UART RX PIN  </td><td class="markdownTableBodyNone">RTL87X3D: #define ADP_PIN P_UART <br />
RTL87X3E: #define ADP_PIN P10_0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">UART ID  </td><td class="markdownTableBodyNone">UART0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Baud Rate  </td><td class="markdownTableBodyNone">9600   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Parity Check  </td><td class="markdownTableBodyNone">No Parity   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Data Format  </td><td class="markdownTableBodyNone">8-bit   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Stop Bit  </td><td class="markdownTableBodyNone">1-bit   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Hardware Flow Control  </td><td class="markdownTableBodyNone">None   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">1. Press RESET on the EVB.<br />
2. When the TX of PC UART is connected to VADP, the string <br />
"adp_io_in_out: adp io in" will be displayed in DebugAnalyzer tool, and chip can <br />
receive uart data from PC.<br />
 3. When the TX of PC UART is disconnected from VADP, the string <br />
"adp_io_in_out: adp io out" will be displayed in DebugAnalyzer tool.   </td></tr>
</table>
<div class="image">
<img src="UART_Demo_Hardware_Connection_Diagram_1.jpg" alt="UART_Demo_Hardware_Connection_Diagram_1.jpg"/>
</div>
 <center><div id="figure_7_1"><b>Figure 7-1 UART Demo 1/2/3/5 Hardware Connection Diagram</b></div></center><div class="image">
<img src="UART_Demo_Hardware_Connection_Diagram_2.jpg" alt="UART_Demo_Hardware_Connection_Diagram_2.jpg"/>
</div>
 <center><div id="figure_7_2"><b>Figure 7-2 UART Demo 4 Hardware Connection Diagram</b></div></center><div class="image">
<img src="UART_Demo_Hardware_Connection_Diagram_3.jpg" alt="UART_Demo_Hardware_Connection_Diagram_3.jpg"/>
</div>
 <center><div id="figure_7_3"><b>Figure 7-3 UART Demo 6 Hardware Connection Diagram</b></div></center><h3><a class="anchor" id="UART_Function_Description"></a>
7.2  Function Description</h3>
<p>The Universal Asynchronous Receiver / Transmitter (UART) provides a flexible method for full-duplex data exchange with external devices. The UART utilizes a fractional baud rate generator to provide a wide range of baud rate options. It supports half-duplex single-wire communication and you can also use GDMA to transmit data and achieve high-speed data communications.</p>
<h3><a class="anchor" id="UART_Feature_List"></a>
7.3  Feature List</h3>
<ul>
<li>Up to 4 UART</li>
<li>Support 1-bit or 2-bit stop bit</li>
<li>Support 7-bit or 8-bit data format</li>
<li>Support odd or even parity</li>
<li>Support hardware flow control</li>
<li>Programmable baud rate</li>
<li>Support GDMA</li>
<li>Support 1-wire UART</li>
</ul>
<p><b>Note:</b> RTL87X3D supports 4 UART, UART1 is used as log UART. RTL87X3E and RTL87X3G support 3 UART, UART1 is used as log UART.</p>
<h3><a class="anchor" id="UART_Data_Format"></a>
7.4  Data Format</h3>
<p>The schematic diagram of the 7-bit data format is shown in Figure 7-4.</p>
<div style="page-break-after: always;"></div><div class="image">
<img src="Schematic_Diagram_of_7-bit_Data_Format.jpg" alt="Schematic_Diagram_of_7-bit_Data_Format.jpg"/>
</div>
 <center><div id="figure_7_4"><b>Figure 7-4 Schematic Diagram of 7-bit Data Format</b></div></center><p>The schematic diagram of the 8-bit data format is shown in Figure 7-5.</p>
<div class="image">
<img src="Schematic_Diagram_of_8-bit_Data_Format.jpg" alt="Schematic_Diagram_of_8-bit_Data_Format.jpg"/>
</div>
 <center><div id="figure_7_5"><b>Figure 7-5 Schematic Diagram of 8-bit Data Format</b></div></center><h3><a class="anchor" id="UART_Parity_Check"></a>
7.5  Parity Check</h3>
<h4><a class="anchor" id="Odd_Parity"></a>
7.5.1  Odd Parity</h4>
<p>Odd parity means that the number of "1" in the data bits and check bit is odd. When the number of "1" in the data bit is odd, the check bit is "0", otherwise it is "1".</p>
<h4><a class="anchor" id="Even_Parity"></a>
7.5.2  Even Parity</h4>
<p>Even parity means that the number of "1" in the data bits and check bit is even. When the number of "1" in the data bits is even, the check bit is "0", otherwise it is "1".</p>
<h3><a class="anchor" id="UART_Hardware_Flow_Control"></a>
7.6  Hardware Flow Control</h3>
<p>The schematic diagram of hardware flow control is shown in Figure 7-6.</p>
<div class="image">
<img src="Schematic_Diagram_of_Hardware_Flow_Control.jpg" alt="Schematic_Diagram_of_Hardware_Flow_Control.jpg"/>
</div>
 <center><div id="figure_7_6"><b>Figure 7-6 Schematic Diagram of Hardware Flow Control</b></div></center><h4><a class="anchor" id="RTS_Flow_Control"></a>
7.6.1  RTS Flow Control</h4>
<p>When the UART receiver is ready to accept new data, RTS becomes active and the low level is active. When data arrives in the receive register, the RTS is released, thereby indicating that it is desired to stop data transmission at the end of the current frame.</p>
<h4><a class="anchor" id="CTS_Flow_Control"></a>
7.6.2  CTS Flow Control</h4>
<p>The transmitter checks the CTS before sending the next frame. If CTS is valid (low level is valid), the next data is sent, otherwise, the next frame data is not sent. If the CTS becomes invalid during transmission, the transmission is stopped after the current transmission is completed.</p>
<h3><a class="anchor" id="UART_Baud_Rate"></a>
7.7  Baud Rate</h3>
<p>Set the baud rate by configuring div, ovsr, and ovsr_adj. UART baud rate table is shown below.</p>
<center><div id="table_7_7"><b>Table 7-7 UART Baud Rate Table</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Baudrate  </th><th class="markdownTableHeadCenter">div  </th><th class="markdownTableHeadCenter">ovsr  </th><th class="markdownTableHeadCenter">ovsr_adj   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">1200  </td><td class="markdownTableBodyCenter">2589  </td><td class="markdownTableBodyCenter">7  </td><td class="markdownTableBodyCenter">0x7F7   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">9600  </td><td class="markdownTableBodyCenter">271  </td><td class="markdownTableBodyCenter">10  </td><td class="markdownTableBodyCenter">0x24A   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">14400  </td><td class="markdownTableBodyCenter">271  </td><td class="markdownTableBodyCenter">5  </td><td class="markdownTableBodyCenter">0x222   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">19200  </td><td class="markdownTableBodyCenter">123  </td><td class="markdownTableBodyCenter">11  </td><td class="markdownTableBodyCenter">0x6FF   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">28800  </td><td class="markdownTableBodyCenter">82  </td><td class="markdownTableBodyCenter">11  </td><td class="markdownTableBodyCenter">0x6FF   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">38400  </td><td class="markdownTableBodyCenter">85  </td><td class="markdownTableBodyCenter">7  </td><td class="markdownTableBodyCenter">0x222   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">57600  </td><td class="markdownTableBodyCenter">41  </td><td class="markdownTableBodyCenter">11  </td><td class="markdownTableBodyCenter">0x6FF   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">76800  </td><td class="markdownTableBodyCenter">35  </td><td class="markdownTableBodyCenter">9  </td><td class="markdownTableBodyCenter">0x7EF   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">115200  </td><td class="markdownTableBodyCenter">20  </td><td class="markdownTableBodyCenter">12  </td><td class="markdownTableBodyCenter">0x252   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">128000  </td><td class="markdownTableBodyCenter">25  </td><td class="markdownTableBodyCenter">7  </td><td class="markdownTableBodyCenter">0x555   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">153600  </td><td class="markdownTableBodyCenter">15  </td><td class="markdownTableBodyCenter">12  </td><td class="markdownTableBodyCenter">0x252   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">230400  </td><td class="markdownTableBodyCenter">10  </td><td class="markdownTableBodyCenter">12  </td><td class="markdownTableBodyCenter">0x252   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">460800  </td><td class="markdownTableBodyCenter">5  </td><td class="markdownTableBodyCenter">12  </td><td class="markdownTableBodyCenter">0x252   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">500000  </td><td class="markdownTableBodyCenter">8  </td><td class="markdownTableBodyCenter">5  </td><td class="markdownTableBodyCenter">0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">921600  </td><td class="markdownTableBodyCenter">3  </td><td class="markdownTableBodyCenter">9  </td><td class="markdownTableBodyCenter">0x2AA   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">1000000  </td><td class="markdownTableBodyCenter">4  </td><td class="markdownTableBodyCenter">5  </td><td class="markdownTableBodyCenter">0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">1382400  </td><td class="markdownTableBodyCenter">2  </td><td class="markdownTableBodyCenter">9  </td><td class="markdownTableBodyCenter">0x2AA   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">1444400  </td><td class="markdownTableBodyCenter">2  </td><td class="markdownTableBodyCenter">8  </td><td class="markdownTableBodyCenter">0x5F7   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">1500000  </td><td class="markdownTableBodyCenter">2  </td><td class="markdownTableBodyCenter">8  </td><td class="markdownTableBodyCenter">0x492   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">1843200  </td><td class="markdownTableBodyCenter">2  </td><td class="markdownTableBodyCenter">5  </td><td class="markdownTableBodyCenter">0x3F7   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">2000000  </td><td class="markdownTableBodyCenter">2  </td><td class="markdownTableBodyCenter">5  </td><td class="markdownTableBodyCenter">0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">2100000  </td><td class="markdownTableBodyCenter">2  </td><td class="markdownTableBodyCenter">14  </td><td class="markdownTableBodyCenter">0x400   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">2764800  </td><td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyCenter">9  </td><td class="markdownTableBodyCenter">0x2AA   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">3000000  </td><td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyCenter">8  </td><td class="markdownTableBodyCenter">0x492   </td></tr>
</table>
<h3><a class="anchor" id="UART_Initialization_Flow"></a>
7.8  Initialization Flow</h3>
<p>UART initialization flow is shown in Figure 7-7.</p>
<div class="image">
<img src="UART_Initialization_Flow_Chart.jpg" alt="UART_Initialization_Flow_Chart.jpg"/>
</div>
 <center><div id="figure_7_7"><b>Figure 7-7 UART Initialization Flow Chart</b></div></center><p>The codes below show UART interrupt handle flow. </p><div class="fragment"><div class="line"><span class="comment">/* Enable UART0 clock */</span></div><div class="line"><a class="code" href="group__x3e___r_c_c___exported___functions.html#ga0ff78e34dcddb1ed9a215ee66ccb2d1b">RCC_PeriphClockCmd</a>(<a class="code" href="group___a_p_b___peripheral___define.html#ga3032d14c701a7a6da6bd667dadd76a93">APBPeriph_UART0</a>, <a class="code" href="group___r_c_c___peripheral___clock.html#ga0f6dfe79bb28b81d220d5cf1c2aa7b7a">APBPeriph_UART0_CLOCK</a>, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line"></div><div class="line"><a class="code" href="struct_u_a_r_t___init_type_def.html">UART_InitTypeDef</a> uartInitStruct;</div><div class="line"><span class="comment">/* Fill each UART_InitTypeDef member variable with its default value */</span></div><div class="line"><a class="code" href="group___u_a_r_t___exported___functions.html#ga73087c97b8a29a580894ced7b125bc41">UART_StructInit</a>(&amp;uartInitStruct);</div><div class="line"></div><div class="line"><span class="comment">/* change default rx trigger level */</span></div><div class="line">uartInitStruct.<a class="code" href="struct_u_a_r_t___init_type_def.html#af8d97f58569bf70b54ecc38fc32ca812">rxTriggerLevel</a> = <a class="code" href="group___u_a_r_t___r_x___f_i_f_o___level.html#gacf6d6c87c8fde912be78452205877bfe">UART_RX_FIFO_TRIGGER_LEVEL_14BYTE</a>;</div><div class="line"></div><div class="line"><a class="code" href="group__x3e___u_a_r_t___exported___functions.html#ga8e2ec5ad013db0dd17962a4614f847cc">UART_Init</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#gaf7cb12b462b4594bd759d1b4e241ec4c">UART</a>, &amp;uartInitStruct);</div><div class="line"></div><div class="line"><span class="comment">//enable rx interrupt and line status interrupt</span></div><div class="line"><a class="code" href="group___u_a_r_t___exported___functions.html#gadbb607b47f810ed2c3314663a5de1201">UART_INTConfig</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#gaf7cb12b462b4594bd759d1b4e241ec4c">UART</a>, <a class="code" href="group___u_a_r_t___interrupts___definition.html#ga3722b5e6b8f7730c795696fcfc5a54a5">UART_INT_RD_AVA</a> | <a class="code" href="group___u_a_r_t___interrupts___definition.html#ga1eec1d4e4c0dee5f7ec2652785349ec0">UART_INT_LINE_STS</a> | <a class="code" href="group___u_a_r_t___interrupts___definition.html#gab95dc75d54f24e5b99daf54f7d30348e">UART_INT_IDLE</a>, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line"></div><div class="line"><a class="code" href="group___h_a_l___vector_table.html#ga1ddcc6c785e2655f5de7b7edf1f4302d">RamVectorTableUpdate</a>(UART0_VECTORn, (IRQ_Fun)Data_Uart_Handler);</div><div class="line"></div><div class="line"><a class="code" href="struct_n_v_i_c___init_type_def.html">NVIC_InitTypeDef</a> NVIC_InitStruct;</div><div class="line">NVIC_InitStruct.<a class="code" href="struct_n_v_i_c___init_type_def.html#a921af0ab04e071d7d276c003e0048123">NVIC_IRQChannel</a> = <a class="code" href="group__x3e___r_t_l876x___exported__types.html#gga666eb0caeb12ec0e281415592ae89083ae9122b85b58f7c24033a8515615a7b74">UART0_IRQn</a>;</div><div class="line">NVIC_InitStruct.<a class="code" href="struct_n_v_i_c___init_type_def.html#acd582bc2edce30e9d7ab5e0ede400f36">NVIC_IRQChannelPriority</a> = 3;</div><div class="line">NVIC_InitStruct.<a class="code" href="struct_n_v_i_c___init_type_def.html#a3c5567ef024a0489884083c88f17b4d5">NVIC_IRQChannelCmd</a> = <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>;</div><div class="line"><a class="code" href="group__x3e___n_v_i_c___exported___functions.html#ga4e06b4f5c9109d6bc8990adf77e5f8d3">NVIC_Init</a>(&amp;NVIC_InitStruct);</div></div><!-- fragment --><h3><a class="anchor" id="UART_Receive_Data_by_Interrupt_Mode"></a>
7.9  Receive Data by Interrupt Mode</h3>
<p>UART interrupt handle flow as shown in Figure 7-8.</p>
<div class="image">
<img src="UART_Interrupt_Handle_Flow.jpg" alt="UART_Interrupt_Handle_Flow.jpg"/>
</div>
 <center><div id="figure_7_8"><b>Figure 7-8 UART Interrupt Handle Flow</b></div></center><p>The codes below show UART interrupt handle flow.</p>
<div style="page-break-after: always;"></div> <div class="fragment"><div class="line"><span class="keywordtype">void</span> data_uart_handler(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    uint8_t <span class="keyword">event</span> = IO_DEMO_EVENT_UART_RX;</div><div class="line">    uint32_t int_status = 0;</div><div class="line">    uint8_t recv_len;</div><div class="line">    uint8_t line_status = 0;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group___u_a_r_t___exported___functions.html#gaf8ec7481e29957fa07c40a211309fb9e">UART_GetFlagState</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#gaf7cb12b462b4594bd759d1b4e241ec4c">UART</a>, <a class="code" href="group___u_a_r_t___flag.html#ga3b23374a31fc004d9075cab4fcbc1b5d">UART_FLAG_RX_IDLE</a>) == <a class="code" href="group__x3e___r_t_l876x___exported__types.html#gga89136caac2e14c55151f527ac02daaffab44c8101cc294c074709ec1b14211792">SET</a>)</div><div class="line">    {</div><div class="line">        <a class="code" href="group___u_a_r_t___exported___functions.html#gadbb607b47f810ed2c3314663a5de1201">UART_INTConfig</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#gaf7cb12b462b4594bd759d1b4e241ec4c">UART</a>, <a class="code" href="group___u_a_r_t___interrupts___definition.html#gab95dc75d54f24e5b99daf54f7d30348e">UART_INT_IDLE</a>, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1ad3a9df141be0ccf10389b640f492b26d">DISABLE</a>);</div><div class="line">        <span class="keywordflow">if</span> (<a class="code" href="group___o_s__87x3d___message.html#gaaa510b44bebf45ba68bd83820dfc6456">os_msg_send</a>(<a class="code" href="group___p_e_r_i_p_h___a_p_p___t_a_s_k.html#gab16d5e105b1c246220eda8b551cdeb67">io_queue_handle</a>, &amp;event, 0) == <span class="keyword">false</span>)</div><div class="line">        {</div><div class="line">            IO_PRINT_ERROR0(<span class="stringliteral">&quot;data_uart_handler: Send Queue Error&quot;</span>);</div><div class="line">        }</div><div class="line">        <span class="comment">//user code here</span></div><div class="line"></div><div class="line">        <a class="code" href="group___u_a_r_t___exported___functions.html#gadbb607b47f810ed2c3314663a5de1201">UART_INTConfig</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#gaf7cb12b462b4594bd759d1b4e241ec4c">UART</a>, <a class="code" href="group___u_a_r_t___interrupts___definition.html#gab95dc75d54f24e5b99daf54f7d30348e">UART_INT_IDLE</a>, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* read interrupt id */</span></div><div class="line">    int_status = <a class="code" href="group___u_a_r_t___exported___functions.html#ga486446950ca480ed8915ad7815f50d81">UART_GetIID</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#gaf7cb12b462b4594bd759d1b4e241ec4c">UART</a>);</div><div class="line"></div><div class="line">    <span class="keywordflow">switch</span> (int_status)</div><div class="line">    {</div><div class="line">    <span class="comment">/* tx fifo empty, not enable */</span></div><div class="line">    <span class="keywordflow">case</span> <a class="code" href="group___u_a_r_t___interrupt___identifier.html#ga90b526d152aa9fd65b059d52d5610770">UART_INT_ID_TX_EMPTY</a>:</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* rx data available */</span></div><div class="line">    <span class="keywordflow">case</span> <a class="code" href="group___u_a_r_t___interrupt___identifier.html#gad208fb8d7648a2572e7188a65ac983b8">UART_INT_ID_RX_LEVEL_REACH</a>:</div><div class="line">        recv_len = <a class="code" href="group___u_a_r_t___exported___functions.html#ga167746d9eba5c1673de9b86c95bb64e6">UART_GetRxFIFOLen</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#gaf7cb12b462b4594bd759d1b4e241ec4c">UART</a>);</div><div class="line">        <a class="code" href="group___u_a_r_t___exported___functions.html#gaeaa77ee7d7980d5c556695414c72958d">UART_ReceiveData</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#gaf7cb12b462b4594bd759d1b4e241ec4c">UART</a>, &amp;RxBuffer[RxCount], recv_len);</div><div class="line">        RxCount += recv_len;</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">    <span class="keywordflow">case</span> <a class="code" href="group___u_a_r_t___interrupt___identifier.html#gac2f2821e07a04d862f26efb3ec8d221f">UART_INT_ID_RX_TMEOUT</a>:</div><div class="line">        recv_len = <a class="code" href="group___u_a_r_t___exported___functions.html#ga167746d9eba5c1673de9b86c95bb64e6">UART_GetRxFIFOLen</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#gaf7cb12b462b4594bd759d1b4e241ec4c">UART</a>);</div><div class="line">        <a class="code" href="group___u_a_r_t___exported___functions.html#gaeaa77ee7d7980d5c556695414c72958d">UART_ReceiveData</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#gaf7cb12b462b4594bd759d1b4e241ec4c">UART</a>, &amp;RxBuffer[RxCount], recv_len);</div><div class="line">        RxCount += recv_len;</div><div class="line"></div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* receive line status interrupt */</span></div><div class="line">    <span class="keywordflow">case</span> <a class="code" href="group___u_a_r_t___interrupt___identifier.html#ga490330e24f68658dccc7b1acda69ac83">UART_INT_ID_LINE_STATUS</a>:</div><div class="line">        line_status = <a class="code" href="group___u_a_r_t___exported___functions.html#ga40770d3dd2059fd6c94e4fdefc17491f">UART_GetLineStatus</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#gaf7cb12b462b4594bd759d1b4e241ec4c">UART</a>);</div><div class="line">        IO_PRINT_ERROR1(<span class="stringliteral">&quot;data_uart_handler: line_status 0x%x&quot;</span>, line_status);</div><div class="line">        <a class="code" href="group___u_a_r_t___exported___functions.html#ga221472da4a2c9e2f43fa040cfd048e23">UART_SendByte</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#gaf7cb12b462b4594bd759d1b4e241ec4c">UART</a>, line_status);</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">    <span class="keywordflow">default</span>:</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span>;</div><div class="line">}</div></div><!-- fragment --><div style="page-break-after: always;"></div><h3><a class="anchor" id="UART_Send_Data"></a>
7.10  Send Data</h3>
<p>UART interrupt handle flow as shown in Figure 7-9.</p>
<div class="image">
<img src="UART_Interrupt_Handle_Flow_2.jpg" alt="UART_Interrupt_Handle_Flow_2.jpg"/>
</div>
 <center><div id="figure_7_9"><b>Figure 7-9 UART Interrupt Handle Flow</b></div></center><div style="page-break-after: always;"></div><p>The codes below show UART interrupt handle flow. </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> uart_send_data(uint8_t *buf, uint32_t len)</div><div class="line">{</div><div class="line">    uint32_t tx_len = len &gt; <a class="code" href="group___u_a_r_t___exported___constants.html#ga94b76465adbb4fb96c821ef0866cbd0f">UART_TX_FIFO_SIZE</a> ? <a class="code" href="group___u_a_r_t___exported___constants.html#ga94b76465adbb4fb96c821ef0866cbd0f">UART_TX_FIFO_SIZE</a> : len;</div><div class="line"></div><div class="line">    <a class="code" href="group___u_a_r_t___exported___functions.html#ga3ff7c977dee8a8f4608fcc2cb0bf3843">UART_SendData</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#ga0508661f121639ffdee7de2353a0def2">UART0</a>, buf, tx_len);</div><div class="line"></div><div class="line">    uart_tx_curr_addr = buf + tx_len;</div><div class="line">    uart_tx_len = len - tx_len;</div><div class="line"></div><div class="line">    <a class="code" href="group___u_a_r_t___exported___functions.html#gadbb607b47f810ed2c3314663a5de1201">UART_INTConfig</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#ga0508661f121639ffdee7de2353a0def2">UART0</a>, <a class="code" href="group___u_a_r_t___interrupts___definition.html#ga37ac1ac9f536c1988fe840fbe1f53c06">UART_INT_FIFO_EMPTY</a>, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> uart0_interrupt_handler(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    uint32_t int_status = 0;</div><div class="line"></div><div class="line">    <span class="comment">/* read interrupt id */</span></div><div class="line">    int_status = <a class="code" href="group___u_a_r_t___exported___functions.html#ga486446950ca480ed8915ad7815f50d81">UART_GetIID</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#ga0508661f121639ffdee7de2353a0def2">UART0</a>);</div><div class="line"></div><div class="line">    <span class="keywordflow">switch</span> (int_status)</div><div class="line">    {</div><div class="line">    <span class="comment">/* tx fifo empty */</span></div><div class="line">    <span class="keywordflow">case</span> <a class="code" href="group___u_a_r_t___interrupt___identifier.html#ga90b526d152aa9fd65b059d52d5610770">UART_INT_ID_TX_EMPTY</a>:</div><div class="line">        <a class="code" href="group___u_a_r_t___exported___functions.html#gadbb607b47f810ed2c3314663a5de1201">UART_INTConfig</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#ga0508661f121639ffdee7de2353a0def2">UART0</a>, <a class="code" href="group___u_a_r_t___interrupts___definition.html#ga37ac1ac9f536c1988fe840fbe1f53c06">UART_INT_FIFO_EMPTY</a>, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1ad3a9df141be0ccf10389b640f492b26d">DISABLE</a>);</div><div class="line">        <a class="code" href="group___u_a_r_t___exported___functions.html#ga486446950ca480ed8915ad7815f50d81">UART_GetIID</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#ga0508661f121639ffdee7de2353a0def2">UART0</a>);</div><div class="line">        <span class="keywordflow">if</span> (uart_tx_len)</div><div class="line">        {</div><div class="line">            uart_send_data(uart_tx_curr_addr, uart_tx_len);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* rx data available */</span></div><div class="line">    <span class="keywordflow">case</span> <a class="code" href="group___u_a_r_t___interrupt___identifier.html#gad208fb8d7648a2572e7188a65ac983b8">UART_INT_ID_RX_LEVEL_REACH</a>:</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">    <span class="keywordflow">case</span> <a class="code" href="group___u_a_r_t___interrupt___identifier.html#gac2f2821e07a04d862f26efb3ec8d221f">UART_INT_ID_RX_TMEOUT</a>:</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* receive line status interrupt */</span></div><div class="line">    <span class="keywordflow">case</span> <a class="code" href="group___u_a_r_t___interrupt___identifier.html#ga490330e24f68658dccc7b1acda69ac83">UART_INT_ID_LINE_STATUS</a>:</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">    <span class="keywordflow">default</span>:</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span>;</div><div class="line">}</div></div><!-- fragment --><div style="page-break-after: always;"></div><h2><a class="anchor" id="GDMA"></a>
8  GDMA</h2>
<h3><a class="anchor" id="GDMA_Demo_Code_Support_List"></a>
8.1 GDMA Demo Code Support List</h3>
<center><div id="table_8_1"><b>Table 8-1 GDMA Sample Code 1 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 1  </th><th class="markdownTableHeadNone">gdma_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:250px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:600px">Demonstrate memory to memory by GDMA.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Brief Introduction  </td><td class="markdownTableBodyNone">This sample code demonstrates memory to memory by GDMA.The data in GDMA_SendBuffer is transferred to GDMA_RecvBuffer.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\gdma\memtomem\gdma_demo.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">gdma_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">GDMA <a class="el" href="struct_d_i_r.html">DIR</a>  </td><td class="markdownTableBodyNone">GDMA_DIR_MemoryToMemory   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">GDMA GDMA BufferSize  </td><td class="markdownTableBodyNone">100   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">GDMA SourceInc  </td><td class="markdownTableBodyNone">DMA_SourceInc_Inc   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">GDMA DestinationInc  </td><td class="markdownTableBodyNone">DMA_DestinationInc_Inc   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">GDMA SourceDataSize  </td><td class="markdownTableBodyNone">GDMA_DataSize_Byte   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">GDMA DestinationDataSize  </td><td class="markdownTableBodyNone">GDMA_DataSize_Byte   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">GDMA SourceMsize  </td><td class="markdownTableBodyNone">GDMA_Msize_1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">GDMA DestinationMsize  </td><td class="markdownTableBodyNone">GDMA_Msize_1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">GDMA SourceAddr  </td><td class="markdownTableBodyNone">GDMA_SendBuffer   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">GDMA DestinationAddr  </td><td class="markdownTableBodyNone">GDMA_RecvBuffer   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">1. Press RESET on the EVB.<br />
2. The data in GDMA_RecvBuffer is the same as in GDMA_SendBufferr   </td></tr>
</table>
<center><div id="table_8_2"><b>Table 8-2 GDMA Sample Code 2 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 2  </th><th class="markdownTableHeadNone">dma_multiblock_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:250px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:600px">Demonstrate how GDMA multi-block function works.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Brief Introduction  </td><td class="markdownTableBodyNone">This sample code demonstrates how GDMA multi-block function works.The data in GDMA_SendBuffer is transferred to GDMA_RecvBuffer.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\gdma\multiblock\dma_multiblock_demo.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">dma_multiblock_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">GDMA <a class="el" href="struct_d_i_r.html">DIR</a>  </td><td class="markdownTableBodyNone">GDMA_DIR_MemoryToMemory   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">GDMA BufferSize  </td><td class="markdownTableBodyNone">100   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">GDMA SourceInc  </td><td class="markdownTableBodyNone">DMA_SourceInc_Inc   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">GDMA DestinationInc  </td><td class="markdownTableBodyNone">DMA_DestinationInc_Inc   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">GDMA SourceDataSize  </td><td class="markdownTableBodyNone">GDMA_DataSize_Byte   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">GDMA DestinationDataSize  </td><td class="markdownTableBodyNone">GDMA_DataSize_Byte   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">GDMA SourceMsize  </td><td class="markdownTableBodyNone">GDMA_Msize_1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">GDMA DestinationMsize  </td><td class="markdownTableBodyNone">GDMA_Msize_1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">GDMA SourceAddr  </td><td class="markdownTableBodyNone">GDMA_SendBuffer   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">GDMA DestinationAddr  </td><td class="markdownTableBodyNone">GDMA_RecvBuffer   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">GDMA Multi-Block Mode  </td><td class="markdownTableBodyNone">LLI_TRANSFER   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">1. Press RESET on the EVB.<br />
2. The data in GDMA_RecvBuffer is the same as in GDMA_SendBufferr   </td></tr>
</table>
<center><div id="table_8_3"><b>Table 8-3 GDMA Sample Code 3 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 3  </th><th class="markdownTableHeadNone">dma_scrgar_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:250px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:600px">Demonstrate memory to memory transfer by Scatter/Gather GDMA.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Brief Introduction  </td><td class="markdownTableBodyNone">This sample code demonstrates how GDMA Scatter/Gather function works. <br />
The data in GDMA_SendBuffer_5 is transferred to GDMA_RecvBuffer_5.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\gdma\multiblock\dma_scrgar_demo.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">dma_scrgar_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">GDMA <a class="el" href="struct_d_i_r.html">DIR</a>  </td><td class="markdownTableBodyNone">GDMA_DIR_MemoryToMemory   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">GDMA BufferSize  </td><td class="markdownTableBodyNone">20   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">GDMA SourceInc  </td><td class="markdownTableBodyNone">DMA_SourceInc_Inc   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">GDMA DestinationInc  </td><td class="markdownTableBodyNone">DMA_DestinationInc_Inc   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">GDMA SourceDataSize  </td><td class="markdownTableBodyNone">GDMA_DataSize_Byte   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">GDMA DestinationDataSize  </td><td class="markdownTableBodyNone">GDMA_DataSize_Byte   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">GDMA SourceMsize  </td><td class="markdownTableBodyNone">GDMA_Msize_1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">GDMA DestinationMsize  </td><td class="markdownTableBodyNone">GDMA_Msize_1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">GDMA SourceAddr  </td><td class="markdownTableBodyNone">GDMA_SendBuffer_5   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">GDMA DestinationAddr  </td><td class="markdownTableBodyNone">GDMA_RecvBuffer_5   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">GDMA Scatter Mode  </td><td class="markdownTableBodyNone">ENABLE   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">GDMA Scatter Count  </td><td class="markdownTableBodyNone">4   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">GDMA Scatter Interval  </td><td class="markdownTableBodyNone">4   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">1. Press RESET on the EVB.<br />
2. The data in GDMA_SendBuffer_5 is transferred to GDMA_RecvBuffer_5 in 4-byte packets and with 4-byte interval   </td></tr>
</table>
<div style="page-break-after: always;"></div><center><div id="table_8_4"><b>Table 8-4 GDMA Sample Code 4 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 4  </th><th class="markdownTableHeadNone">uart_rx_dma.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:200px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:650px">Demonstrate how UART receives data by GDMA.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Brief Introduction  </td><td class="markdownTableBodyNone">This sample code demonstrates the communication between chip and PC. PC <br />
transmits some data to chip.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\gdma\uart_idle_rx\uart_rx_dma.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">uart_rx_dma()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">As shown in Figure 7-1.<br />
RTL87X3E: On EVB, TX is connected to M3_0, RX is connected to M3_1, <br />
FT_VIO is connected to VIO1, and CON3 is connected to PC.<br />
RTL87X3D: On EVB, TXD is connected to M3_0, RXD is connected to M3_1, <br />
FT_VIO is connected to VIO1, and P2 is connected to PC.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">UART TX PIN  </td><td class="markdownTableBodyNone">#define UART_TX_PIN P3_1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">UART RX PIN  </td><td class="markdownTableBodyNone">#define UART_RX_PIN P3_0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">UART ID  </td><td class="markdownTableBodyNone">UART0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Baud Rate  </td><td class="markdownTableBodyNone">3000000   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Parity Check  </td><td class="markdownTableBodyNone">No Parity   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Data Format  </td><td class="markdownTableBodyNone">8-bit   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Stop Bit  </td><td class="markdownTableBodyNone">1-bit   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Hardware Flow Control  </td><td class="markdownTableBodyNone">None   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">1. Press RESET on the EVB, string <br />
"### Welcome to use RealTek Bumblebee ###\r\n" will be displayed in UART <br />
debug tool.<br />
2. Use UART debug tool to send data to chip, then data will be stored in <br />
uart_receive_buf array.   </td></tr>
</table>
<div style="page-break-after: always;"></div><center><div id="table_8_5"><b>Table 8-5 GDMA Sample Code 5 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 5  </th><th class="markdownTableHeadNone">uart_tx_gdma.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:200px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:650px">Demonstrate how UART sends data by GDMA.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Brief Introduction  </td><td class="markdownTableBodyNone">This sample code demonstrates the communication between chip and PC. Chip <br />
transmits some data to PC.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\gdma\uart_tx\uart_tx_gdma.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">uart_tx_gdma()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">As shown in Figure 7-1.<br />
RTL87X3E: On EVB, TX is connected to M3_0, RX is connected to M3_1, <br />
FT_VIO is connected to VIO1, and CON3 is connected to PC.<br />
RTL87X3D: On EVB, TXD is connected to M3_0, RXD is connected to M3_1, <br />
FT_VIO is connected to VIO1, and P2 is connected to PC.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">UART TX PIN  </td><td class="markdownTableBodyNone">#define UART_TX_PIN P3_1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">UART RX PIN  </td><td class="markdownTableBodyNone">#define UART_RX_PIN P3_0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">UART ID  </td><td class="markdownTableBodyNone">UART0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Baud Rate  </td><td class="markdownTableBodyNone">115200   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Parity Check  </td><td class="markdownTableBodyNone">No Parity   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Data Format  </td><td class="markdownTableBodyNone">8-bit   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Stop Bit  </td><td class="markdownTableBodyNone">1-bit   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Hardware Flow Control  </td><td class="markdownTableBodyNone">None   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">Press RESET on the EVB, string <br />
"### Welcome to use RealTek Bumblebee ###\r\n" will be displayed in UART <br />
debug tool.   </td></tr>
</table>
<center><div id="table_8_6"><b>Table 8-6 GDMA Sample Code 6 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 6  </th><th class="markdownTableHeadNone">adc_gdma_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:250px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:600px">Demonstrate how ADC samples data in continuous mode by GDMA.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Brief Introduction  </td><td class="markdownTableBodyNone">Use continuous mode of ADC peripheral to measure voltage on P0_0 and <br />
P0_1.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\gdma\adc_dma\adc_gdma_demo.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">adc_gdma_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Pre-Condition  </td><td class="markdownTableBodyNone">Turn off Charger auto enable and Battery detection support on the <br />
McuConfig Tool.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Channel  </td><td class="markdownTableBodyNone">ADC0<br />
ADC1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">External Channel Input Mode  </td><td class="markdownTableBodyNone">ADC0 and ADC1 are divide mode   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">Connect M0_0 and M0_1 of EVB to external DC voltage source. Input <br />
voltage of M0_0 and M0_1 must range from 0 to 3.3V.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">Press RESET on the EVB, ADC starts continuous sampling, and sample <br />
rawdata will be stored in ADC_Buffer array.   </td></tr>
</table>
<div style="page-break-after: always;"></div><center><div id="table_8_7"><b>Table 8-7 GDMA Sample Code 7 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 7  </th><th class="markdownTableHeadNone">i2c_dma_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:250px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:600px">Demonstrate how I2C master and slave work in GDMA mode.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Brief Introduction  </td><td class="markdownTableBodyNone">This sample code demonstrates the communication between i2c master and <br />
slave in GDMA mode. Master will read data from slave.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk+SlaveTx.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">i2c_dma_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">As shown in Figure 9-3.<br />
On EVB, Connect P0_0 to P1_0.<br />
On EVB, Connect P0_1 to P1_1.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">I2C Master SCL PIN  </td><td class="markdownTableBodyNone">#define I2C1_SCL P0_1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">I2C Master SDA PIN  </td><td class="markdownTableBodyNone">#define I2C1_SDA P0_0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">I2C Slave SCL PIN  </td><td class="markdownTableBodyNone">#define I2C0_SCL P1_1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">I2C Slave SDA PIN  </td><td class="markdownTableBodyNone">#define I2C0_SDA P1_0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">I2C Master ID  </td><td class="markdownTableBodyNone">I2C1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">I2C Slave ID  </td><td class="markdownTableBodyNone">I2C0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Clock Speed  </td><td class="markdownTableBodyNone">400000   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Address Mode  </td><td class="markdownTableBodyNone">7 Bit   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Slave Address  </td><td class="markdownTableBodyNone">0x50   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">ACK  </td><td class="markdownTableBodyNone">ACK Enable   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">GDMA <a class="el" href="struct_d_i_r.html">DIR</a>  </td><td class="markdownTableBodyNone">Master: GDMA_DIR_PeripheralToMemory<br />
 Slave: GDMA_DIR_MemoryToPeripheral   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">GDMA BufferSize  </td><td class="markdownTableBodyNone">#define TEST_SIZE 255   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">GDMA SourceInc  </td><td class="markdownTableBodyNone">Master: DMA_SourceInc_Fix<br />
 Slave: DMA_SourceInc_Inc   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">GDMA DestinationInc  </td><td class="markdownTableBodyNone">Master: DMA_DestinationInc_Inc<br />
 Slave: DMA_DestinationInc_Fix   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">GDMA SourceDataSize  </td><td class="markdownTableBodyNone">Master: GDMA_DataSize_Byte<br />
 Slave: GDMA_DataSize_HalfWord   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">GDMA DestinationDataSize  </td><td class="markdownTableBodyNone">Master: GDMA_DataSize_Byte<br />
 Slave: GDMA_DataSize_HalfWord   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">GDMA SourceMsize  </td><td class="markdownTableBodyNone">GDMA_Msize_4   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">GDMA DestinationMsize  </td><td class="markdownTableBodyNone">GDMA_Msize_4   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">GDMA SourceAddr  </td><td class="markdownTableBodyNone">Master: &amp; (I2C1-&gt;IC_DATA_CMD)<br />
 Slave: sendbuf   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">GDMA DestinationAddr  </td><td class="markdownTableBodyNone">Master: readbuf<br />
 Slave: &amp;(I2C0-&gt;IC_DATA_CMD)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">GDMA SourceHandshake  </td><td class="markdownTableBodyNone">Master: GDMA_Handshake_I2C1_RX   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">GDMA DestHandshake  </td><td class="markdownTableBodyNone">Slave: GDMA_Handshake_I2C0_TX   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">1. Press RESET on the EVB.<br />
2. string "i2c0_handler: I2C_INT_RD_REQ", "i2c_tx_dma_handler", <br />
"i2c_rx_dma_handler", "i2c1_handler: I2C1 stop detect" will be displayed <br />
in DebugAnalyzer tool in order   </td></tr>
</table>
<div style="page-break-after: always;"></div><center><div id="table_8_8"><b>Table 8-8 GDMA Sample Code 8 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 8  </th><th class="markdownTableHeadNone">dlps_gdma_recover_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:200px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:650px">Demonstrate how GDMA recover from DLPS.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Brief Introduction  </td><td class="markdownTableBodyNone">This sample code demonstrates how GDMA recovers from DLPS. The UART can <br />
receive data through GDMA when the chip wakes up from DLPS   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\dlps\dlps_gdma_recover_demo.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">dlps_gdma_recover_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">As shown in Figure 8-2.<br />
RTL87X3E: On EVB, TX is connected to M3_0, RX is connected to M3_1, <br />
FT_VIO is connected to VIO1, and CON3 is connected to PC.Wake up pin is <br />
connected to P0_0.<br />
RTL87X3D: On EVB, TXD is connected to M3_0, RXD is connected to M3_1, <br />
FT_VIO is connected to VIO1, and P2 is connected to PC. Wake up pin is <br />
connected to P0_0.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">UART TX PIN  </td><td class="markdownTableBodyNone">#define UART_TX_PIN P3_1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">UART RX PIN  </td><td class="markdownTableBodyNone">#define UART_RX_PIN P3_0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">UART ID  </td><td class="markdownTableBodyNone">UART0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Baud Rate  </td><td class="markdownTableBodyNone">3000000   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Parity Check  </td><td class="markdownTableBodyNone">No Parity   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Data Format  </td><td class="markdownTableBodyNone">8-bit   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Stop Bit  </td><td class="markdownTableBodyNone">1-bit   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Hardware Flow Control  </td><td class="markdownTableBodyNone">None   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">1. Press RESET on the EVB, string <br />
"### Welcome to use RealTek Bumblebee ###\r\n" will be displayed <br />
in UART debug tool.<br />
2. Use UART debug tool to send data to chip, then data will be stored in <br />
uart_receive_buf array.   </td></tr>
</table>
<div style="page-break-after: always;"></div><center><div id="table_8_9"><b>Table 8-9 GDMA Sample Code 9 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 9  </th><th class="markdownTableHeadNone">spi_dma_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:180px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:670px">Demonstrate how SPI sends and receives data in master mode by GDMA.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\gdma\spi_dma\spi_dma_demo.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">spi_dma_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">As shown in Figure 10-4. Connect M0_1 to CS of SPI slave device, connect M0_0 to SCK of SPI slave device, connect M1_0 to MISO of SPI slave device, and connect <br />
M1_1 to MOSI of SPI slave device.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">SPI CS PIN  </td><td class="markdownTableBodyNone">#define PIN_SPI1_CS P0_1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">SPI SCK PIN  </td><td class="markdownTableBodyNone">#define PIN_SPI1_SCK P0_0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">SPI MOSI PIN  </td><td class="markdownTableBodyNone">#define PIN_SPI1_MOSI P1_0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">SPI MISO PIN  </td><td class="markdownTableBodyNone">#define PIN_SPI1_MISO P1_1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">SPI ID  </td><td class="markdownTableBodyNone">SPI1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Mode  </td><td class="markdownTableBodyNone">Master   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Speed  </td><td class="markdownTableBodyNone">400000   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Data Size  </td><td class="markdownTableBodyNone">8-bit   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">1. Press RESET on the EVB, the data in array sendbuf is sent to SPI slave device and print string "spi_tx_dma_handler" in DebugAnalyzer.<br />
2. After slave device receives the data, slave device sends data to chip, chip stores the received data in array readbuf and prints string "spi_rx_dma_handler" in <br />
DebugAnalyzer.   </td></tr>
</table>
<div class="image">
<img src="I2C_GDMA_Hardware_Connection.jpg" alt="I2C_GDMA_Hardware_Connection.jpg"/>
</div>
 <center><div id="figure_8_1"><b>Figure 8-1 I2C GDMA Hardware Connection Diagram</b></div></center><div class="image">
<img src="GDMA_Recover_Hardware_Connection.jpg" alt="GDMA_Recover_Hardware_Connection.jpg"/>
</div>
 <center><div id="figure_8_2"><b>Figure 8-2 GDMA Recover From DLPS Hardware Connection Diagram</b></div></center><h3><a class="anchor" id="GDMA_Function_Description"></a>
8.2  Function Description</h3>
<p>General Direct Memory Access (GDMA) is used to provide high-speed data transfer between peripherals and memory or between memory and memory. Data can be moved quickly through GDMA without CPU intervention, saving CPU resources for other operations. <br />
With DMA, the MCU initiates the transfer first. Then MCU can do other operations while the transfer is in progress, and receives an interrupt from the GDMA controller when the operation is done. <br />
The GDMA controller has 16 channels, and each can handle requests from one or more peripherals for memory access. The GDMA controller has an arbitrator to coordinate the priority of each GDMA request.</p>
<h3><a class="anchor" id="GDMA_Feature_List"></a>
8.3  Feature List</h3>
<ul>
<li>Up to 16 channels</li>
<li>Programmable transfer type for each channel: memory to memory, memory to peripheral, peripheral to memory, peripheral to peripheral</li>
<li>Programmable source and destination addresses for each channel</li>
<li>Address increment, or no change</li>
<li>Programmable enable and disable of DMA channel</li>
<li>Programmable burst transaction size for each channel</li>
<li>Support for disabling channel without data loss</li>
<li>Support for suspension of DMA operation</li>
<li>Programmable channel priority</li>
<li>Independent interrupts and control bit for every channel</li>
<li>Support single-block and multi-block transfer</li>
<li>Support scatter and gather transfer</li>
</ul>
<p><b>Note:</b> RTL87X3D supports 16 channels, if using SPI_HS, please use channel 0 and 1. RTL87X3E supports 9 channels, RTL87X3G supports 8 channels.</p>
<h3><a class="anchor" id="GDMA_Parameter_Significance"></a>
8.4  Parameter Significance</h3>
<h4><a class="anchor" id="GDMA_ChannelNum"></a>
8.4.1  GDMA_ChannelNum</h4>
<p>Channel numbers can be 0 to 15. </p>
<h4><a class="anchor" id="GDMA_DIR"></a>
8.4.2  GDMA_DIR</h4>
<p>The transfer direction can be memory to memory or memory to peripheral or peripheral to memory or peripheral to peripheral. </p>
<h4><a class="anchor" id="GDMA_SourceInc"></a>
8.4.3  GDMA_SourceInc</h4>
<p>Indicates whether to increment the source address on every source transfer </p>
<h4><a class="anchor" id="GDMA_DestinationInc"></a>
8.4.4  GDMA_DestinationInc</h4>
<p>Indicates whether to increment destination address on every destination transfer. </p>
<h4><a class="anchor" id="GDMA_SourceDataSize"></a>
8.4.5  GDMA_SourceDataSize</h4>
<p>Source single transaction size in bytes: <br />
src_single_size_bytes = GDMA_SourceDataSize/8 </p>
<h4><a class="anchor" id="GDMA_DestinationDataSize"></a>
8.4.6  GDMA_DestinationDataSize</h4>
<p>Destination single transaction size in bytes: <br />
src_burst_size_bytes = GDMA_DestinationDataSize*src_single_size_bytes </p>
<h4><a class="anchor" id="GDMA_SourceMsize"></a>
8.4.7  GDMA_SourceMsize</h4>
<p>Source burst transaction size in bytes: <br />
dst_single_size_bytes = GDMA_SourceMsize/8 </p>
<h4><a class="anchor" id="GDMA_DestinationMsize"></a>
8.4.8  GDMA_DestinationMsize</h4>
<p>Destination burst transaction size in bytes <br />
dst_burst_size_bytes = GDMA_DestinationMsize*dst_single_size_bytes </p>
<h4><a class="anchor" id="GDMA_BufferSize"></a>
8.4.9  GDMA_BufferSize</h4>
<p>The total number of bytes to be transferred in a block is: blk_size_bytes_dma = GDMA_BufferSize * src_single_size_bytes</p>
<p><b>Note:</b> The above parameter configuration needs to satisfy the following formula: <br />
GDMA_SourceDataSize*GDMA_SourceMsize = GDMA_DestinationDataSize*GDMA_DestinationMsize</p>
<h3><a class="anchor" id="GDMA_Waterlevel_Setting"></a>
8.5  Waterlevel Setting</h3>
<p>Handshaking interfaces are used at the transaction level to control the flow of single or burst transactions. Waterlevel is mainly divided into TX FIFO Waterlevel and RX FIFO Waterlevel. When the effective data amount in the FIFO reaches the set value of waterlevel, a burst transmission is initiated. The GDMA MSize and peripheral waterlevel setting table is presented below.</p>
<div style="page-break-after: always;"></div><center><div id="table_8_10"><b>Table 8-10 MSize and Peripheral Waterlevel Setting Table</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">IO  </th><th class="markdownTableHeadCenter">Dir  </th><th class="markdownTableHeadCenter">Peripheral <br />
GDMA <br />
waterlevel  </th><th class="markdownTableHeadCenter">GDMA_<br />
SourceMsize  </th><th class="markdownTableHeadCenter">GDMA_<br />
DestinationMsize  </th><th class="markdownTableHeadCenter">GDMA_<br />
SourceDataSize  </th><th class="markdownTableHeadCenter">GDMA_<br />
DestinationDataSize   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:65px">UART</div>  </td><td class="markdownTableBodyCenter"><div style="width:40px">TX</div>  </td><td class="markdownTableBodyCenter"><div style="width:160px">.TxWaterlevel <br />
= 12</div>  </td><td class="markdownTableBodyCenter"><div style="width:125px">1</div>  </td><td class="markdownTableBodyCenter"><div style="width:165px">4</div>  </td><td class="markdownTableBodyCenter"><div style="width:150px">Word</div>  </td><td class="markdownTableBodyCenter"><div style="width:195px">Byte</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter">RX  </td><td class="markdownTableBodyCenter">.RxWaterlevel <br />
= 4  </td><td class="markdownTableBodyCenter">4  </td><td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyCenter">Byte  </td><td class="markdownTableBodyCenter">Word   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">SPI <br />
Master  </td><td class="markdownTableBodyCenter">TX  </td><td class="markdownTableBodyCenter">.SPI_TxWaterlevel <br />
= 24  </td><td class="markdownTableBodyCenter">4  </td><td class="markdownTableBodyCenter">8  </td><td class="markdownTableBodyCenter">Word  </td><td class="markdownTableBodyCenter">HalfWord   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter">RX  </td><td class="markdownTableBodyCenter">.SPI_RxWaterlevel <br />
= 7  </td><td class="markdownTableBodyCenter">8  </td><td class="markdownTableBodyCenter">4  </td><td class="markdownTableBodyCenter">HalfWord  </td><td class="markdownTableBodyCenter">Word   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter">TX  </td><td class="markdownTableBodyCenter">.SPI_TxWaterlevel <br />
= 28  </td><td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyCenter">4  </td><td class="markdownTableBodyCenter">Word  </td><td class="markdownTableBodyCenter">Byte   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter">RX  </td><td class="markdownTableBodyCenter">.SPI_RxWaterlevel <br />
= 3  </td><td class="markdownTableBodyCenter">4  </td><td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyCenter">Byte  </td><td class="markdownTableBodyCenter">Word   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">SPI <br />
Slave  </td><td class="markdownTableBodyCenter">TX  </td><td class="markdownTableBodyCenter">.SPI_TxWaterlevel <br />
= 58  </td><td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyCenter">4  </td><td class="markdownTableBodyCenter">Word  </td><td class="markdownTableBodyCenter">Byte   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter">RX  </td><td class="markdownTableBodyCenter">.SPI_RxWaterlevel <br />
= 3  </td><td class="markdownTableBodyCenter">4  </td><td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyCenter">Byte  </td><td class="markdownTableBodyCenter">Word   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">I2C  </td><td class="markdownTableBodyCenter">TX  </td><td class="markdownTableBodyCenter">.I2C_TxWaterlevel <br />
= 14  </td><td class="markdownTableBodyCenter">4  </td><td class="markdownTableBodyCenter">8  </td><td class="markdownTableBodyCenter">Word  </td><td class="markdownTableBodyCenter">HalfWord   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter">RX  </td><td class="markdownTableBodyCenter">.I2C_RxWaterlevel <br />
= 3  </td><td class="markdownTableBodyCenter">4  </td><td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyCenter">Byte  </td><td class="markdownTableBodyCenter">Word   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">ADC  </td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter">.adcBurstSize <br />
= 8  </td><td class="markdownTableBodyCenter">8  </td><td class="markdownTableBodyCenter">8  </td><td class="markdownTableBodyCenter">HalfWord  </td><td class="markdownTableBodyCenter">HalfWord   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">SPI_HS  </td><td class="markdownTableBodyCenter">TX  </td><td class="markdownTableBodyCenter">.SPI_TxWaterlevel <br />
= 25  </td><td class="markdownTableBodyCenter">32  </td><td class="markdownTableBodyCenter">32  </td><td class="markdownTableBodyCenter">Byte  </td><td class="markdownTableBodyCenter">Byte   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter">RX  </td><td class="markdownTableBodyCenter">.SPI_RxWaterlevel <br />
= 31  </td><td class="markdownTableBodyCenter">32  </td><td class="markdownTableBodyCenter">32  </td><td class="markdownTableBodyCenter">Byte  </td><td class="markdownTableBodyCenter">Byte   </td></tr>
</table>
<p><b>Note:</b> SPI_HS is only supported in rtl87x3D.</p>
<h3><a class="anchor" id="GDMA_Single-Block_Transfer_Initialization_Flow"></a>
8.6  GDMA Single-Block Transfer Initialization Flow</h3>
<p>The initialization flow of GDMA single-block transfer is shown in Figure 8-3.</p>
<div class="image">
<img src="GDMA_Single-Block_Transfer_Operation_Flow_Chart.jpg" alt="GDMA_Single-Block_Transfer_Operation_Flow_Chart.jpg"/>
</div>
 <center><div id="figure_8_3"><b>Figure 8-3 GDMA Single-Block Transfer Initialization Flow Chart</b></div></center><div style="page-break-after: always;"></div><p>The codes below show GDMA single-block transfer. </p><div class="fragment"><div class="line">uint16_t i = 0;</div><div class="line"><a class="code" href="group__x3e___r_c_c___exported___functions.html#ga0ff78e34dcddb1ed9a215ee66ccb2d1b">RCC_PeriphClockCmd</a>(<a class="code" href="group___a_p_b___peripheral___define.html#gaeb8d35478322d35996e4cce867c0fd6b">APBPeriph_GDMA</a>, <a class="code" href="group___r_c_c___peripheral___clock.html#ga1de13be4bcbae35bede3bf7917aecf68">APBPeriph_GDMA_CLOCK</a>, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line"><a class="code" href="struct_g_d_m_a___init_type_def.html">GDMA_InitTypeDef</a> GDMA_InitStruct;</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (!<a class="code" href="group__x3e___p_l_a_t_f_o_r_m___g_d_m_a___exported___functions.html#ga4518ee6f3c3370a11adfc3c1babe230d">GDMA_channel_request</a>(&amp;mem_to_mem_dma_ch_num, demo_dma_handler, <span class="keyword">true</span>))</div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/*--------------initialize test buffer---------------------*/</span></div><div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 100; i++)</div><div class="line">{</div><div class="line">    GDMA_SendBuffer[i] = (i &amp; 0xff);</div><div class="line">}</div><div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 100; i++)</div><div class="line">{</div><div class="line">    GDMA_RecvBuffer[i] = 0;</div><div class="line">}</div><div class="line"></div><div class="line"><a class="code" href="group___g_d_m_a___exported___functions.html#ga0c4386a76f776a50aba1b2ecb6c665c5">GDMA_StructInit</a>(&amp;GDMA_InitStruct);</div><div class="line">GDMA_InitStruct.<a class="code" href="struct_g_d_m_a___init_type_def.html#afa81d74400498ca459fba1bb20101b74">GDMA_ChannelNum</a>      = DEMO_DMA_CHANNEL_NUM;</div><div class="line">GDMA_InitStruct.<a class="code" href="struct_g_d_m_a___init_type_def.html#aee96bc8a1d8ef85f2ffc64d02274fe67">GDMA_DIR</a>             = <a class="code" href="group___g_d_m_a__data__transfer__direction.html#gab1e4811a05bf0ffc711882743cf6c7a7">GDMA_DIR_MemoryToMemory</a>;</div><div class="line">GDMA_InitStruct.<a class="code" href="struct_g_d_m_a___init_type_def.html#a672455687defa33a421d78eea9d8309c">GDMA_BufferSize</a>      = 100;<span class="comment">//determine total transfer size</span></div><div class="line">GDMA_InitStruct.<a class="code" href="struct_g_d_m_a___init_type_def.html#ae185e562e3c1d62fb4a533b2a9af2125">GDMA_SourceInc</a>       = <a class="code" href="group___g_d_m_a__source__incremented__mode.html#ga96d0ea1d643d85940bfdd7df670409bd">DMA_SourceInc_Inc</a>;</div><div class="line">GDMA_InitStruct.<a class="code" href="struct_g_d_m_a___init_type_def.html#a33ccc00cfcca94735c63e6a85d33735b">GDMA_DestinationInc</a>  = <a class="code" href="group___g_d_m_a__destination__incremented__mode.html#ga7ef00ff55b0cdf54a0a64087d6fffcd7">DMA_DestinationInc_Inc</a>;</div><div class="line">GDMA_InitStruct.<a class="code" href="struct_g_d_m_a___init_type_def.html#aa2ab817e5b8f8c9e79f7d07c1afa8069">GDMA_SourceDataSize</a>  = <a class="code" href="group___g_d_m_a__data__size.html#gab1856b5f84dc4af7ac5429110e12e68a">GDMA_DataSize_Byte</a>;</div><div class="line">GDMA_InitStruct.<a class="code" href="struct_g_d_m_a___init_type_def.html#a6e2cad942d5a4b533fec712c06b402e1">GDMA_DestinationDataSize</a> = <a class="code" href="group___g_d_m_a__data__size.html#gab1856b5f84dc4af7ac5429110e12e68a">GDMA_DataSize_Byte</a>;</div><div class="line">GDMA_InitStruct.<a class="code" href="struct_g_d_m_a___init_type_def.html#aca898ef64b30b1eeca934c1dcfad946b">GDMA_SourceMsize</a>      = <a class="code" href="group___g_d_m_a___msize.html#gad3ff1fc80a11967b7ac6feaab6f7bf9f">GDMA_Msize_1</a>;</div><div class="line">GDMA_InitStruct.<a class="code" href="struct_g_d_m_a___init_type_def.html#ab0482d07c0511e055d22a991adce1893">GDMA_DestinationMsize</a> = <a class="code" href="group___g_d_m_a___msize.html#gad3ff1fc80a11967b7ac6feaab6f7bf9f">GDMA_Msize_1</a>;</div><div class="line">GDMA_InitStruct.<a class="code" href="struct_g_d_m_a___init_type_def.html#a32b5468d324eb9b8ea93431393bb0918">GDMA_SourceAddr</a>      = (uint32_t)GDMA_SendBuffer;</div><div class="line">GDMA_InitStruct.<a class="code" href="struct_g_d_m_a___init_type_def.html#a426621ee71bcccf5c85db9678d68a037">GDMA_DestinationAddr</a> = (uint32_t)GDMA_RecvBuffer;</div><div class="line"><a class="code" href="group__x3e___g_d_m_a___exported___functions.html#ga1a3498cf6a9b61faecede7c2181e8c93">GDMA_Init</a>(DEMO_DMA_CHANNEL, &amp;GDMA_InitStruct);</div><div class="line"></div><div class="line"><span class="comment">/*-----------------GDMA IRQ init-------------------*/</span></div><div class="line"><a class="code" href="struct_n_v_i_c___init_type_def.html">NVIC_InitTypeDef</a> nvic_init_struct;</div><div class="line">nvic_init_struct.<a class="code" href="struct_n_v_i_c___init_type_def.html#a921af0ab04e071d7d276c003e0048123">NVIC_IRQChannel</a>         = DEMO_DMA_IRQ;</div><div class="line">nvic_init_struct.<a class="code" href="struct_n_v_i_c___init_type_def.html#a3c5567ef024a0489884083c88f17b4d5">NVIC_IRQChannelCmd</a>      = (<a class="code" href="group__x3d___r_t_l876x___exported__types.html#gac9a7e9a35d2513ec15c3b537aaa4fba1">FunctionalState</a>)<a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>;</div><div class="line">nvic_init_struct.<a class="code" href="struct_n_v_i_c___init_type_def.html#acd582bc2edce30e9d7ab5e0ede400f36">NVIC_IRQChannelPriority</a> = 3;</div><div class="line"><a class="code" href="group__x3e___n_v_i_c___exported___functions.html#ga4e06b4f5c9109d6bc8990adf77e5f8d3">NVIC_Init</a>(&amp;nvic_init_struct);</div><div class="line"></div><div class="line"><a class="code" href="group___g_d_m_a___exported___functions.html#ga4d6b9a94e20aad58fbff8de25c0f5d8c">GDMA_INTConfig</a>(DEMO_DMA_CHANNEL_NUM, <a class="code" href="group___d_m_a__interrupts__definition.html#ga1835acd0c660cf5b6dde4ed91afc34c7">GDMA_INT_Block</a>, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line"><a class="code" href="group__x3e___g_d_m_a___exported___functions.html#ga81023d249b49c999c523b9b5a2c93ade">GDMA_Cmd</a>(DEMO_DMA_CHANNEL_NUM, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div></div><!-- fragment --><div style="page-break-after: always;"></div><h2><a class="anchor" id="I2C"></a>
9  I2C</h2>
<h3><a class="anchor" id="I2C_Demo_Code_Support_List"></a>
9.1 I2C Demo Code Support List</h3>
<center><div id="table_9_1"><b>Table 9-1 I2C Sample Code 1 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 1  </th><th class="markdownTableHeadNone">i2c_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:180px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:670px">Demonstrate how I2C sends and receives data in interrupt mode.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Brief Introduction  </td><td class="markdownTableBodyNone">This sample code demonstrates the communication between chip and i2c slave. Chip <br />
transmits some data to i2c slave and then chip receives data from i2c slave.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\i2c\interrupt\i2c_demo.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">i2c_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">As shown in Figure 9-1.<br />
On EVB, Connect P0_0 to the SCL of the i2c slave.<br />
On EVB, Connect P0_1 to the SDA of the i2c slave.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">I2C SCL PIN  </td><td class="markdownTableBodyNone">#define PIN_I2C0_SCL P0_0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">I2C SDA PIN  </td><td class="markdownTableBodyNone">#define PIN_I2C0_SDA P0_1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">I2C ID  </td><td class="markdownTableBodyNone">I2C0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Clock Speed  </td><td class="markdownTableBodyNone">100000   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Device Mode  </td><td class="markdownTableBodyNone">Master   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Address Mode  </td><td class="markdownTableBodyNone">7 Bit   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Slave Address  </td><td class="markdownTableBodyNone">0x50   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">ACK  </td><td class="markdownTableBodyNone">ACK Enable   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">1. Press RESET on the EVB, i2c slave will receive data 0xaa and 0xbb, and chip will <br />
receive four bytes from i2c slave.<br />
2. When the I2C transmission ends, string "i2c0_handler: I2C0 stop detect" will <br />
be displayed in DebugAnalyzer tool   </td></tr>
</table>
<div style="page-break-after: always;"></div><center><div id="table_9_2"><b>Table 9-2 I2C Sample Code 2 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 2  </th><th class="markdownTableHeadNone">i2c_mw_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:180px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:670px">Demonstrate how I2C master expert write function.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Brief Introduction  </td><td class="markdownTableBodyNone">This sample code demonstrates the I2C master write function. Chip transmits some <br />
data to the i2c slave.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\i2c\master_write\i2c_mw_demo.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">i2c_mw_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">As shown in Figure 9-1.<br />
On EVB, Connect P0_0 to the SCL of the i2c slave.<br />
On EVB, Connect P0_1 to the SDA of the i2c slave.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">I2C SCL PIN  </td><td class="markdownTableBodyNone">#define PIN_I2C1_SCL P0_0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">I2C SDA PIN  </td><td class="markdownTableBodyNone">#define PIN_I2C1_SDA P0_1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">I2C ID  </td><td class="markdownTableBodyNone">I2C1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Clock Speed  </td><td class="markdownTableBodyNone">400000   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Device Mode  </td><td class="markdownTableBodyNone">Master   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Address Mode  </td><td class="markdownTableBodyNone">7 Bit   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Slave Address  </td><td class="markdownTableBodyNone">#define ADDR 0x08   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">ACK  </td><td class="markdownTableBodyNone">ACK Enable   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">1. Press RESET on the EVB, i2c slave will receive data 0xaa, 0xbb, 0x66, 0x68, <br />
0x77, 0x88.<br />
2. If the I2C transfers failed, string "i2c_mw_demo: Send failed" will be displayed <br />
in DebugAnalyzer tool   </td></tr>
</table>
<div style="page-break-after: always;"></div><center><div id="table_9_3"><b>Table 9-3 I2C Sample Code 3 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 3  </th><th class="markdownTableHeadNone">i2c_polling_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:180px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:670px">Demonstrate how I2C sends and receives data in polling mode.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Brief Introduction  </td><td class="markdownTableBodyNone">This sample code demonstrates the communication between chip and i2c slave. Chip <br />
transmits some data to i2c slave and then chip receives data from i2c slave.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\i2c\polling\i2c_polling_demo.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">i2c_polling_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">As shown in Figure 9-1.<br />
On EVB, Connect P0_0 to the SCL of the i2c slave.<br />
On EVB, Connect P0_1 to the SDA of the i2c slave.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">I2C SCL PIN  </td><td class="markdownTableBodyNone">#define PIN_I2C1_SCL P0_0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">I2C SDA PIN  </td><td class="markdownTableBodyNone">#define PIN_I2C1_SDA P0_1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">I2C ID  </td><td class="markdownTableBodyNone">I2C1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Clock Speed  </td><td class="markdownTableBodyNone">400000   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Device Mode  </td><td class="markdownTableBodyNone">Master   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Address Mode  </td><td class="markdownTableBodyNone">7 Bit   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Slave Address  </td><td class="markdownTableBodyNone">#define ADDR 0x08   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">ACK  </td><td class="markdownTableBodyNone">ACK Enable   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">1. Press RESET on the EVB, i2c slave will receive data 0xaa and 0xbb, and chip will <br />
receive four bytes from i2c slave.<br />
2. If the I2C transfers failed, string "i2c_polling_demo: Send failed" will be displayed in DebugAnalyzer tool   </td></tr>
</table>
<center><div id="table_9_4"><b>Table 9-4 I2C Sample Code 4 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 4  </th><th class="markdownTableHeadNone">i2c_slave_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:180px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:670px">Demonstrate how I2C slave works.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Brief Introduction  </td><td class="markdownTableBodyNone">This sample code demonstrates the communication between chip and i2c master. <br />
Chip could receive data from i2c master and send data to i2c master.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\i2c\slave\i2c_slave_demo.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">i2c_slave_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">As shown in Figure 9-2.<br />
On EVB, Connect P0_0 to the SCL of the i2c master.<br />
On EVB, Connect P0_1 to the SDA of the i2c master.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">I2C SCL PIN  </td><td class="markdownTableBodyNone">#define PIN_I2C1_SCL P0_0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">I2C SDA PIN  </td><td class="markdownTableBodyNone">#define PIN_I2C1_SDA P0_1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">I2C ID  </td><td class="markdownTableBodyNone">I2C1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Clock Speed  </td><td class="markdownTableBodyNone">100000   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Device Mode  </td><td class="markdownTableBodyNone">Slave   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Address Mode  </td><td class="markdownTableBodyNone">7 Bit   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Slave Address  </td><td class="markdownTableBodyNone">0x50   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">ACK  </td><td class="markdownTableBodyNone">ACK Enable   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">1. Press RESET on the EVB.<br />
2. If the i2c master sends read request, the master will receive data 0x66.<br />
3. If the i2c master sends write cmd, the received data will be displayed in <br />
DebugAnalyzer tool   </td></tr>
</table>
<div class="image">
<img src="I2C_Demo_Hardware_Connection_Diagram_1.jpg" alt="I2C_Demo_Hardware_Connection_Diagram_1.jpg"/>
</div>
 <center><div id="figure_9_1"><b>Figure 9-1 I2C Demo1/2/3 Hardware Connection Diagram</b></div></center><div class="image">
<img src="I2C_Demo_Hardware_Connection_Diagram_2.jpg" alt="I2C_Demo_Hardware_Connection_Diagram_2.jpg"/>
</div>
 <center><div id="figure_9_2"><b>Figure 9-2 I2C Demo4 Hardware Connection Diagram</b></div></center><h3><a class="anchor" id="I2C_Function_Description"></a>
9.2  Function Description</h3>
<p>The I2C is a configurable, synthesizable, and programmable control bus that provides support for the communications link between integrated circuits in a system. It is a simple two-wire bus with a software-defined protocol for system control, which is used in temperature sensors and voltage level translators to EEPROMs, general-purpose I/O, A/D and D/A converters, CODECs, and many types of microprocessors. <br />
The I2C bus is a two-wire serial interface, consisting of a serial data line (SDA) and a serial clock (SCL). These wires carry information between the devices connected to the bus. Each device is recognized by a unique address and can operate as either a transmitter or receiver, depending on the function of the device. Devices can also be considered masters or slaves when performing data transfers. A master is a device that initiates a data transfer on the bus and generates the clock signals to permit that transfer. At that time, any device addressed is considered a slave.</p>
<h3><a class="anchor" id="I2C_Feature_List"></a>
9.3  Feature List</h3>
<ul>
<li>Up to 3 I2C</li>
<li>Two-wire I2C serial interface - consists of a serial data line (SDA) and a serial clock (SCL)</li>
<li>Support master and slave mode</li>
<li>Support 7/10-bit addressing mode</li>
<li>Support standard mode(0 to 100Kb/s)</li>
<li>Support fast mode(less than or equal to 400Kb/s) or fast mode plus(less than or equal to 1000Kb/s)</li>
<li>Interrupt or polled-mode operation</li>
<li>Support GDMA</li>
</ul>
<p><b>Note:</b> RTL87X3D and RTL87X3E support 3 I2C, RTL87X3G supports 1 I2C.</p>
<h3><a class="anchor" id="I2C_Transfer_Protocol"></a>
9.4  I2C Transfer Protocol</h3>
<p>Each byte sent on the SDA line must be 8 bits, there is no limit to the number of bytes that can be sent per transfer, and each byte must be followed by a response bit. The most significant bit (MSB) of the data is transmitted first. If the slave needs to complete some other functions, such as an internal interrupt service routine, it can receive or send the next complete data byte. The clock line SCL can be kept low to force the master to enter the wait state, when the slave is ready to receive the next data byte and release the clock line SCL, the data transfer continues.</p>
<div class="image">
<img src="Schematic_Diagram_of_I2C_Transmission_Protocol.jpg" alt="Schematic_Diagram_of_I2C_Transmission_Protocol.jpg"/>
</div>
 <center><div id="figure_9_3"><b>Figure 9-3 Schematic Diagram of I2C Transmission Protocol</b></div></center><h3><a class="anchor" id="I2C_Master_Mode"></a>
9.5  Master Mode</h3>
<h4><a class="anchor" id="I2C_7-Bit_Addressing_Mode"></a>
9.5.1  7-Bit Addressing Mode</h4>
<h4><a class="anchor" id="I2C_7-Bit_Master_Write"></a>
9.5.1.1  Master Write</h4>
<p>Master-transmitter transmits to slave-receiver with a 7-bit slave address. The transfer direction is not changed. All data is transmitted in byte format, with no limit on the number of bytes transferred per data transfer. After the master sends the address and Read/Write bit or the master transmits a byte of data to the slave, the slave-receiver must respond with the acknowledge signal (ACK). When a slave-receiver does not respond with an ACK pulse, the master aborts the transfer by issuing a Stop condition. The slave must leave the SDA line high so that the master can abort the transfer.</p>
<div class="image">
<img src="Master_Write_in_7-bit_Addressing_Mode.jpg" alt="Master_Write_in_7-bit_Addressing_Mode.jpg"/>
</div>
 <center><div id="figure_9_4"><b>Figure 9-4 Master Write in 7-bit Addressing Mode</b></div></center><h4><a class="anchor" id="I2C_7-Bit_Master_Read"></a>
9.5.1.2  Master Read</h4>
<p>In the first response, master-transmitter becomes master-receiver, and slave-receiver becomes slave-transmitter, and the first response is still generated by the slave. If the master is receiving data as shown in Figure 9-3, then the master responds to the slave-transmitter with an acknowledge pulse after a byte of data has been received, except for the last byte. This (NACK) is the way the master-receiver notifies the slave-transmitter that this is the last byte. The slave-transmitter relinquishes the SDA line after detecting the No Acknowledge (NACK) so that the master can issue a STOP condition.</p>
<div class="image">
<img src="Master_Read_in_7-bit_Addressing_Mode.jpg" alt="Master_Read_in_7-bit_Addressing_Mode.jpg"/>
</div>
 <center><div id="figure_9_5"><b>Figure 9-5 Master Read in 7-bit Addressing Mode</b></div></center><h4><a class="anchor" id="I2C_7-Bit_Master_Repeat_Read"></a>
9.5.1.3  Master Repeat Read</h4>
<p>When performing a write-before-read operation, both the start condition and the slave address are sent repeatedly, but the Read/Write bit is reversed.</p>
<div class="image">
<img src="Master_Repeat_Read_in_7-bit_Addressing_Mode.jpg" alt="Master_Repeat_Read_in_7-bit_Addressing_Mode.jpg"/>
</div>
 <center><div id="figure_9_6"><b>Figure 9-6 Master Repeat Read in 7-bit Addressing Mode</b></div></center><h4><a class="anchor" id="I2C_10-Bit_Addressing_Mode"></a>
9.5.2  10-Bit Addressing Mode</h4>
<h4><a class="anchor" id="I2C_10-Bit_Master_Write"></a>
9.5.2.1  Master Write</h4>
<p>Master-transmitter transmits to slave-receiver with a 10-bit slave address. The transfer direction is not changed.</p>
<div class="image">
<img src="Master_Write_in_10-bit_Addressing_Mode.jpg" alt="Master_Write_in_10-bit_Addressing_Mode.jpg"/>
</div>
 <center><div id="figure_9_7"><b>Figure 9-7 Master Write in 10-bit Addressing Mode</b></div></center><h4><a class="anchor" id="I2C_10-Bit_Master_Read"></a>
9.5.2.2  Master Read</h4>
<p>Master-transmitter transmits to slave-receiver with a 10-bit slave address. The transfer direction is changed after the second Read/Write bit, master-transmitter becomes master-receiver, and slave-receiver becomes slave-transmitter.</p>
<div class="image">
<img src="Master_Read_in_10-bit_Addressing_Mode.jpg" alt="Master_Read_in_10-bit_Addressing_Mode.jpg"/>
</div>
 <center><div id="figure_9_8"><b>Figure 9-8 Master Read in 10-bit Addressing Mode</b></div></center><h4><a class="anchor" id="I2C_10-Bit_Master_Repeat_Read"></a>
9.5.2.3  Master Repeat Read</h4>
<p>The master sends data to the slave and then reads data from the same slave. The transfer direction is changed after the second Read/Write bit.</p>
<div class="image">
<img src="Master_Repeat_Read_in_10-bit_Addressing_Mode.jpg" alt="Master_Repeat_Read_in_10-bit_Addressing_Mode.jpg"/>
</div>
 <center><div id="figure_9_9"><b>Figure 9-9 Master Repeat Read in 10-bit Addressing Mode</b></div></center><h3><a class="anchor" id="I2C_Master_Mode_Initialization_Flow"></a>
9.6  Master Mode Initialization Flow</h3>
<p>I2C master mode initialization flow is shown in Figure 9-10.</p>
<div class="image">
<img src="I2C_Master_Write_Operation_Flow_Chart.jpg" alt="I2C_Master_Write_Operation_Flow_Chart.jpg"/>
</div>
 <center><div id="figure_9_10"><b>Figure 9-10 I2C Master Mode Initialization Flow Chart</b></div></center><div style="page-break-after: always;"></div><p>The codes below show I2C master mode initialization flow. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> driver_i2c_init(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group__x3e___r_c_c___exported___functions.html#ga0ff78e34dcddb1ed9a215ee66ccb2d1b">RCC_PeriphClockCmd</a>(<a class="code" href="group___a_p_b___peripheral___define.html#gaa28d93ee4e795c9417fb4c94ff1cd6bc">APBPeriph_I2C1</a>, <a class="code" href="group___r_c_c___peripheral___clock.html#ga7f1b15bc8e5ef1f59fcc99e15ff73c67">APBPeriph_I2C1_CLOCK</a>, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line"></div><div class="line">    <a class="code" href="struct_i2_c___init_type_def.html">I2C_InitTypeDef</a>  I2C_InitStructure;</div><div class="line">    <a class="code" href="group___i2_c___exported__functions.html#ga08582aca6d7d7910cd5cbff0d9def350">I2C_StructInit</a>(&amp;I2C_InitStructure);</div><div class="line"></div><div class="line">    I2C_InitStructure.<a class="code" href="struct_i2_c___init_type_def.html#af8d72d15cd29b7e69591ce3edab497f6">I2C_ClockSpeed</a> = 400000;</div><div class="line">    I2C_InitStructure.<a class="code" href="struct_i2_c___init_type_def.html#ad690b252a8b6a57c94c082971ed2301b">I2C_DeviveMode</a> = <a class="code" href="group___i2_c__device__mode.html#gaa6200a6c2bfdb55fad698d3d02335249">I2C_DeviveMode_Master</a>;</div><div class="line">    I2C_InitStructure.<a class="code" href="struct_i2_c___init_type_def.html#a391fcdd3b1fdb7b9fb05923f829f69bc">I2C_AddressMode</a> = <a class="code" href="group___i2_c__address__mode.html#ga2d7d185bfd58bd24e088e5aab681564a">I2C_AddressMode_7BIT</a>;</div><div class="line">    I2C_InitStructure.<a class="code" href="struct_i2_c___init_type_def.html#ab6fc01a70cbea27aa7dfc53eb0dcc10a">I2C_SlaveAddress</a> = ADDR;</div><div class="line">    I2C_InitStructure.<a class="code" href="struct_i2_c___init_type_def.html#ab21d61d68d06e97d7c0ab90c8e396464">I2C_Ack</a> = <a class="code" href="group___i2_c__acknowledgement.html#ga616466f8ef5a47237cdbf7ac578ec507">I2C_Ack_Enable</a>;</div><div class="line"></div><div class="line">    <a class="code" href="group___i2_c___exported__functions.html#gaac29465bca70fbc91c2f922ab67bb88e">I2C_Init</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#gab45d257574da6fe1f091cc45b7eda6cc">I2C1</a>, &amp;I2C_InitStructure);</div><div class="line"></div><div class="line">    <a class="code" href="group___i2_c___exported__functions.html#ga7e1323c9133c2cb424dfb5b10b7d2f0b">I2C_Cmd</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#gab45d257574da6fe1f091cc45b7eda6cc">I2C1</a>, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="I2C_Slave_Mode_Initialization_Flow"></a>
9.7  Slave Mode Initialization Flow</h3>
<p>I2C slave mode initialization flow is shown in Figure 9-11.</p>
<div class="image">
<img src="I2C_Slave_Mode_Initialization_Flow_Chart.jpg" alt="I2C_Slave_Mode_Initialization_Flow_Chart.jpg"/>
</div>
 <center><div id="figure_9_11"><b>Figure 9-11 I2C Slave Mode Initialization Flow Chart</b></div></center><div style="page-break-after: always;"></div><p>The codes below show I2C slave mode initialization flow. </p><div class="fragment"><div class="line"><a class="code" href="group__x3e___r_c_c___exported___functions.html#ga0ff78e34dcddb1ed9a215ee66ccb2d1b">RCC_PeriphClockCmd</a>(<a class="code" href="group___a_p_b___peripheral___define.html#gaa28d93ee4e795c9417fb4c94ff1cd6bc">APBPeriph_I2C1</a>, <a class="code" href="group___r_c_c___peripheral___clock.html#ga7f1b15bc8e5ef1f59fcc99e15ff73c67">APBPeriph_I2C1_CLOCK</a>, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line"></div><div class="line"><a class="code" href="struct_i2_c___init_type_def.html">I2C_InitTypeDef</a>  I2C_InitStructure;</div><div class="line"><a class="code" href="group___i2_c___exported__functions.html#ga08582aca6d7d7910cd5cbff0d9def350">I2C_StructInit</a>(&amp;I2C_InitStructure);</div><div class="line"></div><div class="line">I2C_InitStructure.<a class="code" href="struct_i2_c___init_type_def.html#af8d72d15cd29b7e69591ce3edab497f6">I2C_ClockSpeed</a> = 100000;</div><div class="line">I2C_InitStructure.<a class="code" href="struct_i2_c___init_type_def.html#ad690b252a8b6a57c94c082971ed2301b">I2C_DeviveMode</a> = <a class="code" href="group___i2_c__device__mode.html#gad0fefeca147df15d05e7e7da24446f54">I2C_DeviveMode_Slave</a>;</div><div class="line">I2C_InitStructure.<a class="code" href="struct_i2_c___init_type_def.html#a391fcdd3b1fdb7b9fb05923f829f69bc">I2C_AddressMode</a> = <a class="code" href="group___i2_c__address__mode.html#ga2d7d185bfd58bd24e088e5aab681564a">I2C_AddressMode_7BIT</a>;</div><div class="line">I2C_InitStructure.<a class="code" href="struct_i2_c___init_type_def.html#ab6fc01a70cbea27aa7dfc53eb0dcc10a">I2C_SlaveAddress</a> = 0x50;</div><div class="line">I2C_InitStructure.<a class="code" href="struct_i2_c___init_type_def.html#ab21d61d68d06e97d7c0ab90c8e396464">I2C_Ack</a> = <a class="code" href="group___i2_c__acknowledgement.html#ga616466f8ef5a47237cdbf7ac578ec507">I2C_Ack_Enable</a>;</div><div class="line"></div><div class="line"><a class="code" href="group___i2_c___exported__functions.html#gaac29465bca70fbc91c2f922ab67bb88e">I2C_Init</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#gab45d257574da6fe1f091cc45b7eda6cc">I2C1</a>, &amp;I2C_InitStructure);</div><div class="line"></div><div class="line"><span class="comment">/* Config I2C interrupt */</span></div><div class="line"><a class="code" href="group___i2_c___exported__functions.html#ga2a4ec92ed117a6e4abf1c076e4330c6c">I2C_INTConfig</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#gab45d257574da6fe1f091cc45b7eda6cc">I2C1</a>, <a class="code" href="group___i2_c__interrupts__definition.html#ga530342bfad66bc17010a5e6ddf0f0f15">I2C_INT_RD_REQ</a> | <a class="code" href="group___i2_c__interrupts__definition.html#ga56a1983722862345c550f890d9af3a9e">I2C_INT_RX_FULL</a> | <a class="code" href="group___i2_c__interrupts__definition.html#ga03747def7365f8f484aa1944bb964f88">I2C_INT_STOP_DET</a>, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line"></div><div class="line"><a class="code" href="struct_n_v_i_c___init_type_def.html">NVIC_InitTypeDef</a> NVIC_InitStruct;</div><div class="line">NVIC_InitStruct.<a class="code" href="struct_n_v_i_c___init_type_def.html#a921af0ab04e071d7d276c003e0048123">NVIC_IRQChannel</a> = <a class="code" href="group__x3e___r_t_l876x___exported__types.html#gga666eb0caeb12ec0e281415592ae89083af651b1769e03e4653b1a4a7c88132398">I2C1_IRQn</a>;</div><div class="line">NVIC_InitStruct.<a class="code" href="struct_n_v_i_c___init_type_def.html#acd582bc2edce30e9d7ab5e0ede400f36">NVIC_IRQChannelPriority</a> = 3;</div><div class="line">NVIC_InitStruct.<a class="code" href="struct_n_v_i_c___init_type_def.html#a3c5567ef024a0489884083c88f17b4d5">NVIC_IRQChannelCmd</a> = <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>;</div><div class="line"><a class="code" href="group__x3e___n_v_i_c___exported___functions.html#ga4e06b4f5c9109d6bc8990adf77e5f8d3">NVIC_Init</a>(&amp;NVIC_InitStruct);</div><div class="line"></div><div class="line"><a class="code" href="group___i2_c___exported__functions.html#ga7e1323c9133c2cb424dfb5b10b7d2f0b">I2C_Cmd</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#gab45d257574da6fe1f091cc45b7eda6cc">I2C1</a>, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div></div><!-- fragment --><h3><a class="anchor" id="I2C_Master_Write"></a>
9.8  Master Write</h3>
<p>The codes below show the operation flow of I2C sending data in master mode. </p><div class="fragment"><div class="line">uint8_t I2C_WriteBuf[16] = {0xaa, 0xbb, 0x66, 0x68, 0x77, 0x88};</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (<a class="code" href="group__x3e___i2_c___status.html#gga83856d8d3bffc5ca50b8a296ae73cc45aeb3572e237cca649b4ef5172dcfb16b5">I2C_Success</a> != <a class="code" href="group___i2_c___exported__functions.html#gab3a174cc953dc34ae01384641bc19903">I2C_MasterWrite</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#gab45d257574da6fe1f091cc45b7eda6cc">I2C1</a>, I2C_WriteBuf, 6))</div><div class="line">{</div><div class="line">    IO_PRINT_ERROR0(<span class="stringliteral">&quot;i2c_mw_demo: Send failed&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">//Check Event</span></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group___i2_c___exported__functions.html#gaf3b8882cc364dde2b1c673e0cbe29fee">I2C_CheckEvent</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#gab45d257574da6fe1f091cc45b7eda6cc">I2C1</a>, <a class="code" href="group___i2_c__transmit___abort___source.html#ga7f675554226f480ca3b13e1a314b655f">ABRT_7B_ADDR_NOACK</a>) == <a class="code" href="group__x3e___r_t_l876x___exported__types.html#gga89136caac2e14c55151f527ac02daaffab44c8101cc294c074709ec1b14211792">SET</a>)</div><div class="line">    {</div><div class="line">        IO_PRINT_ERROR0(<span class="stringliteral">&quot;i2c_mw_demo: Wrong addr&quot;</span>);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group___i2_c___exported__functions.html#gaf3b8882cc364dde2b1c673e0cbe29fee">I2C_CheckEvent</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#gab45d257574da6fe1f091cc45b7eda6cc">I2C1</a>, <a class="code" href="group___i2_c__transmit___abort___source.html#gaa3359550f878c3a06964291f9bb66ab0">ABRT_GCALL_NOACK</a>) == <a class="code" href="group__x3e___r_t_l876x___exported__types.html#gga89136caac2e14c55151f527ac02daaffab44c8101cc294c074709ec1b14211792">SET</a>)</div><div class="line">    {</div><div class="line">        IO_PRINT_ERROR0(<span class="stringliteral">&quot;i2c_mw_demo: General call nack&quot;</span>);</div><div class="line">    }</div><div class="line">    <a class="code" href="group___i2_c___exported__functions.html#ga89e547206a6b782746460cd34af2e06d">I2C_SendCmd</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#gab45d257574da6fe1f091cc45b7eda6cc">I2C1</a>, <a class="code" href="group___i2_c__send__command.html#gaf382c97af7bef7e8f86160f31fc8fdf4">I2C_WRITE_CMD</a>, 0, <a class="code" href="group___i2_c__send__stop.html#gafef62745db0b4b6282863c40f7ae6fc0">I2C_STOP_ENABLE</a>);</div><div class="line">    <a class="code" href="group___i2_c___exported__functions.html#ga7e1323c9133c2cb424dfb5b10b7d2f0b">I2C_Cmd</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#gab45d257574da6fe1f091cc45b7eda6cc">I2C1</a>, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1ad3a9df141be0ccf10389b640f492b26d">DISABLE</a>);</div><div class="line">    <a class="code" href="group___i2_c___exported__functions.html#ga7e1323c9133c2cb424dfb5b10b7d2f0b">I2C_Cmd</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#gab45d257574da6fe1f091cc45b7eda6cc">I2C1</a>, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line">    <a class="code" href="group___i2_c___exported__functions.html#gab3a174cc953dc34ae01384641bc19903">I2C_MasterWrite</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#gab45d257574da6fe1f091cc45b7eda6cc">I2C1</a>, I2C_WriteBuf, 6);</div><div class="line">}</div></div><!-- fragment --><div style="page-break-after: always;"></div><h3><a class="anchor" id="I2C_Master_Repeat_Read"></a>
9.9  Master Repeat Read</h3>
<p>The codes below show the operation flow of I2C send and receive data in master mode. </p><div class="fragment"><div class="line">uint8_t I2C_WriteBuf[16] = {0xaa, 0xbb, 0x66, 0x68, 0x77, 0x88};</div><div class="line">uint8_t I2C_ReadBuf[16] = {0, 0, 0, 0};</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (<a class="code" href="group__x3e___i2_c___status.html#gga83856d8d3bffc5ca50b8a296ae73cc45aeb3572e237cca649b4ef5172dcfb16b5">I2C_Success</a> != <a class="code" href="group___i2_c___exported__functions.html#ga61511bc5b156d983851c372fdba8d6e2">I2C_RepeatRead</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#gab45d257574da6fe1f091cc45b7eda6cc">I2C1</a>, I2C_WriteBuf, 2, I2C_ReadBuf, 4))</div><div class="line">{</div><div class="line">    IO_PRINT_ERROR0(<span class="stringliteral">&quot;i2c_polling_demo: Send failed&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">//Check Event</span></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group___i2_c___exported__functions.html#gaf3b8882cc364dde2b1c673e0cbe29fee">I2C_CheckEvent</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#gab45d257574da6fe1f091cc45b7eda6cc">I2C1</a>, <a class="code" href="group___i2_c__transmit___abort___source.html#ga7f675554226f480ca3b13e1a314b655f">ABRT_7B_ADDR_NOACK</a>) == <a class="code" href="group__x3e___r_t_l876x___exported__types.html#gga89136caac2e14c55151f527ac02daaffab44c8101cc294c074709ec1b14211792">SET</a>)</div><div class="line">    {</div><div class="line">        IO_PRINT_ERROR0(<span class="stringliteral">&quot;i2c_polling_demo: Wrong addr&quot;</span>);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group___i2_c___exported__functions.html#gaf3b8882cc364dde2b1c673e0cbe29fee">I2C_CheckEvent</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#gab45d257574da6fe1f091cc45b7eda6cc">I2C1</a>, <a class="code" href="group___i2_c__transmit___abort___source.html#gaa3359550f878c3a06964291f9bb66ab0">ABRT_GCALL_NOACK</a>) == <a class="code" href="group__x3e___r_t_l876x___exported__types.html#gga89136caac2e14c55151f527ac02daaffab44c8101cc294c074709ec1b14211792">SET</a>)</div><div class="line">    {</div><div class="line">        IO_PRINT_ERROR0(<span class="stringliteral">&quot;i2c_polling_demo: General call nack&quot;</span>);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><div style="page-break-after: always;"></div><h2><a class="anchor" id="SPI"></a>
10  SPI</h2>
<h3><a class="anchor" id="SPI_Demo_Code_Support_List"></a>
10.1 SPI Demo Code Support List</h3>
<center><div id="table_10_1"><b>Table 10-1 SPI Sample Code 1 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 1  </th><th class="markdownTableHeadNone">spi_switchcs_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:180px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:670px">Demonstrate how SPI dynamically switches CS signals.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\spi\dynamic_switch_cs\spi_switchcs_demo.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">spi_switchcs_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">As shown in Figure 10-1. Connect M1_3 to CS of SPI slave device 0, connect M1_4 <br />
to CS of SPI slave device 1, connect M1_5 to CS of SPI slave device 2, connect <br />
M1_0 to SCK of SPI slave device 0/1/2, connect M1_1 to MISO of SPI slave <br />
device 0/1/2, and connect M1_2 to MOSI of SPI slave device 0/1/2.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">SPI CS0 PIN  </td><td class="markdownTableBodyNone">#define PIN_SPI1_CS0 P1_3   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">SPI CS1 PIN  </td><td class="markdownTableBodyNone">#define PIN_SPI1_CS1 P1_4   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">SPI CS2 PIN  </td><td class="markdownTableBodyNone">#define PIN_SPI1_CS2 P1_5   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">SPI SCK PIN  </td><td class="markdownTableBodyNone">#define PIN_SPI1_SCK P1_0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">SPI MOSI PIN  </td><td class="markdownTableBodyNone">#define PIN_SPI1_MOSI P1_1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">SPI MISO PIN  </td><td class="markdownTableBodyNone">#define PIN_SPI1_MISO P1_2   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">SPI ID  </td><td class="markdownTableBodyNone">SPI1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Mode  </td><td class="markdownTableBodyNone">Master   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Speed  </td><td class="markdownTableBodyNone">400000   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Data Size  </td><td class="markdownTableBodyNone">8-bit   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">1. Press RESET on the EVB, the data in array SPI_WriteBuf is sent to SPI slave <br />
device 0.<br />
2. Then the data in array SPI_WriteBuf is sent to SPI slave device 1.<br />
3. Then the data in array SPI_WriteBuf is sent to SPI slave device 2.   </td></tr>
</table>
<center><div id="table_10_2"><b>Table 10-2 SPI Sample Code 2 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 2  </th><th class="markdownTableHeadNone">spi_master_eeprom_mode_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:180px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:670px">Demonstrate how SPI receives data with EEPROM mode by DMA in master mode.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\spi\eeprom\spi_master_eeprom_mode_demo.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">spi_master_eeprom_mode_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">As shown in Figure 10-2. Connect M0_3 to CS of SPI slave device, connect M0_0 to SCK of SPI slave device, connect M0_1 to MISO of SPI slave device, and connect <br />
M0_2 to MOSI of SPI slave device.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">SPI CS PIN  </td><td class="markdownTableBodyNone">#define PIN_SPI_CS P0_3   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">SPI SCK PIN  </td><td class="markdownTableBodyNone">#define PIN_SPI_SCK P0_0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">SPI MOSI PIN  </td><td class="markdownTableBodyNone">#define PIN_SPI_MOSI P0_1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">SPI MISO PIN  </td><td class="markdownTableBodyNone">#define PIN_SPI_MISO P0_2   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">SPI ID  </td><td class="markdownTableBodyNone">SPI1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Mode  </td><td class="markdownTableBodyNone">Master   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Speed  </td><td class="markdownTableBodyNone">400000   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Data Size  </td><td class="markdownTableBodyNone">8-bit   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">Print string "spi_master_rx_dma_handler" and the received data in DebugAnalyzer.   </td></tr>
</table>
<center><div id="table_10_3"><b>Table 10-3 SPI Sample Code 3 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 3  </th><th class="markdownTableHeadNone">external_flash.c<br />
external_flash.h<br />
external_flash_t   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:180px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:670px">Demonstrate how chip communicates with external flash by SPI.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\spi\external_flash\external_flash.c<br />
sdk\src\sample\io_demo\spi\external_flash\external_flash.h<br />
sdk\src\sample\io_demo\spi\external_flash\external_flash_test.c<br />
sdk\src\sample\io_demo\spi\external_flash\external_flash_test.h   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">ext_flash_spi_test_code()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">As shown in Figure 10-3. Connect M5_1 to CS of external flash, connect M5_0 to <br />
SCK of external flash, connect M5_3 to MISO of external flash, and connect M5_2 <br />
to MOSI of external flash, connect M5_5 to HOLD of external flash   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">SPI CS PIN  </td><td class="markdownTableBodyNone">#define FLASH_CS P5_1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">SPI SCK PIN  </td><td class="markdownTableBodyNone">#define FLASH_SCK P5_0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">SPI MOSI PIN  </td><td class="markdownTableBodyNone">#define FLASH_MOSI P5_2   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">SPI MISO PIN  </td><td class="markdownTableBodyNone">#define FLASH_MISO P5_3   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">FLASH HOLD PIN  </td><td class="markdownTableBodyNone">#define FLASH_HOLD P5_5   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">SPI ID  </td><td class="markdownTableBodyNone">SPI0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Mode  </td><td class="markdownTableBodyNone">Master   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Speed  </td><td class="markdownTableBodyNone">400000   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Data Size  </td><td class="markdownTableBodyNone">8-bit   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">1. Print string "flash_test_task: test_case 1 success" in DebugAnalyzer.<br />
2. Print string "flash_test_task: test_case 2 success" in DebugAnalyzer.<br />
3. Print string "flash_test_task: test_case 3 success" in DebugAnalyzer.   </td></tr>
</table>
<div style="page-break-after: always;"></div><center><div id="table_10_4"><b>Table 10-4 SPI Sample Code 4 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 4  </th><th class="markdownTableHeadNone">spi_master_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:180px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:670px">Demonstrate how SPI sends data by polling and receives data by interrupt in <br />
master mode.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\spi\interrupt\spi_master_demo.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">spi_master_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">As shown in Figure 10-4. Connect M0_1 to CS of SPI slave device, connect M0_0 to SCK of SPI slave device, connect M1_0 to MISO of SPI slave device, and connect <br />
M1_1 to MOSI of SPI slave device.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">SPI CS PIN  </td><td class="markdownTableBodyNone">#define PIN_SPI1_CS P0_1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">SPI SCK PIN  </td><td class="markdownTableBodyNone">#define PIN_SPI1_SCK P0_0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">SPI MOSI PIN  </td><td class="markdownTableBodyNone">#define PIN_SPI1_MOSI P1_0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">SPI MISO PIN  </td><td class="markdownTableBodyNone">#define PIN_SPI1_MISO P1_1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">SPI ID  </td><td class="markdownTableBodyNone">SPI1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Mode  </td><td class="markdownTableBodyNone">Master   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Speed  </td><td class="markdownTableBodyNone">400000   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Data Size  </td><td class="markdownTableBodyNone">8-bit   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">1. Press RESET on the EVB, the data in array SPI_WriteBuf is sent to SPI slave <br />
device.<br />
2. After slave device receives the data, slave device sends data to chip, chip stores the received data in array SPI_ReadINTBuf.   </td></tr>
</table>
<center><div id="table_10_5"><b>Table 10-5 SPI Sample Code 5 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 5  </th><th class="markdownTableHeadNone">spi_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:180px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:670px">Demonstrate how SPI sends and receives data by polling in master mode.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\spi\polling\spi_demo.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">spi_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">As shown in Figure 10-5. Connect M1_5 to CS of SPI slave device, connect M1_2 to SCK of SPI slave device, connect M1_3 to MISO of SPI slave device, and connect <br />
M1_4 to MOSI of SPI slave device.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">SPI CS PIN  </td><td class="markdownTableBodyNone">#define PIN_SPI1_CS P1_5   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">SPI SCK PIN  </td><td class="markdownTableBodyNone">#define PIN_SPI1_SCK P1_2   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">SPI MOSI PIN  </td><td class="markdownTableBodyNone">#define PIN_SPI1_MOSI P1_3   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">SPI MISO PIN  </td><td class="markdownTableBodyNone">#define PIN_SPI1_MISO P1_4   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">SPI ID  </td><td class="markdownTableBodyNone">SPI1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Mode  </td><td class="markdownTableBodyNone">Master   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Speed  </td><td class="markdownTableBodyNone">400000   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Data Size  </td><td class="markdownTableBodyNone">8-bit   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">1. Press RESET on the EVB, the data in array SPI_WriteBuf is sent to SPI slave <br />
device.<br />
2. After slave device receives the data, slave device sends data to chip, chip stores the received data in array SPI_ReadBuf.   </td></tr>
</table>
<div style="page-break-after: always;"></div><center><div id="table_10_6"><b>Table 10-6 SPI Sample Code 6 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 6  </th><th class="markdownTableHeadNone">spi_master_rx_only_mode_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:180px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:670px">Demonstrate how SPI receives data with RX-only mode by DMA in master mode.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\spi\receive_only\spi_master_rx_only_mode_demo.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">spi_master_rx_only_mode_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">As shown in Figure 10-2. Connect M0_3 to CS of SPI slave device, connect M0_0 to SCK of SPI slave device, connect M0_1 to MISO of SPI slave device, and connect <br />
M0_2 to MOSI of SPI slave device.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">SPI CS PIN  </td><td class="markdownTableBodyNone">#define PIN_SPI_CS P0_3   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">SPI SCK PIN  </td><td class="markdownTableBodyNone">#define PIN_SPI_SCK P0_0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">SPI MOSI PIN  </td><td class="markdownTableBodyNone">#define PIN_SPI_MOSI P0_1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">SPI MISO PIN  </td><td class="markdownTableBodyNone">#define PIN_SPI_MISO P0_2   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">SPI ID  </td><td class="markdownTableBodyNone">SPI1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Mode  </td><td class="markdownTableBodyNone">Master   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Speed  </td><td class="markdownTableBodyNone">400000   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Data Size  </td><td class="markdownTableBodyNone">8-bit   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">Print string "spi_master_rx_dma_handler" and the received data in DebugAnalyzer.   </td></tr>
</table>
<center><div id="table_10_7"><b>Table 10-7 SPI Sample Code 7 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 7  </th><th class="markdownTableHeadNone">spi_slave_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:180px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:670px">Demonstrate how SPI receives data by interrupt in slave mode.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\spi\slave\spi_slave_demo.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">spi_slave_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">As shown in Figure 10-6. Connect MIC2_N to CS of SPI master device, connect <br />
MIC1_P to SCK of SPI master device, connect MIC2_P to MISO of SPI master <br />
device, and connect MIC1_N to MOSI of SPI master device.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">SPI CS PIN  </td><td class="markdownTableBodyNone">#define PIN_SPI0_CS MIC2_N   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">SPI SCK PIN  </td><td class="markdownTableBodyNone">#define PIN_SPI0_SCK MIC1_P   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">SPI MOSI PIN  </td><td class="markdownTableBodyNone">#define PIN_SPI0_MOSI MIC2_P   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">SPI MISO PIN  </td><td class="markdownTableBodyNone">#define PIN_SPI0_MISO MIC1_N   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">SPI ID  </td><td class="markdownTableBodyNone">SPI0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Mode  </td><td class="markdownTableBodyNone">Slave   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Data Size  </td><td class="markdownTableBodyNone">8-bit   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">Master device sends data to chip, chip stores the received data in array <br />
SPI_ReadINTBuf and prints the received data in DebugAnalyzer.   </td></tr>
</table>
<div style="page-break-after: always;"></div><center><div id="table_10_8"><b>Table 10-8 SPI Sample Code 8 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 8  </th><th class="markdownTableHeadNone">spi_slave_gpio_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:180px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:670px">Demonstrate how SPI sends data in slave mode by interrupt.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\spi\slave\spi_slave_gpio_demo.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">spi_slave_gpio_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">As shown in Figure 10-7. Connect M1_4 to M1_0, connect M1_7 to M1_3, connect M1_5 to M1_2, connect M1_6 to M1_1, and connect M2_3 to M2_4.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">SPI0 CS PIN  </td><td class="markdownTableBodyNone">#define SPI0_CS P1_3   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">SPI0 SCK PIN  </td><td class="markdownTableBodyNone">#define SPI0_SCK P1_0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">SPI0 MOSI PIN  </td><td class="markdownTableBodyNone">#define SPI0_MOSI P1_1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">SPI0 MISO PIN  </td><td class="markdownTableBodyNone">#define SPI0_MISO P1_2   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">SPI1 CS PIN  </td><td class="markdownTableBodyNone">#define SPI1_CS P1_7   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">SPI1 SCK PIN  </td><td class="markdownTableBodyNone">#define SPI1_SCK P1_4   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">SPI1 MOSI PIN  </td><td class="markdownTableBodyNone">#define SPI1_MOSI P1_5   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">SPI1 MISO PIN  </td><td class="markdownTableBodyNone">#define SPI1_MISO P1_6   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">SPI ID  </td><td class="markdownTableBodyNone">SPI0<br />
SPI1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Mode  </td><td class="markdownTableBodyNone">SPI1 is master, SPI0 is slave.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Speed  </td><td class="markdownTableBodyNone">100000   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Data Size  </td><td class="markdownTableBodyNone">8-bit   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">1. Master device sends data to slave, slave stores the received data in array <br />
SPI_ReadINTBuf and prints the received data in DebugAnalyzer. <br />
2. Slave device sends data to master, master stores the received data in array <br />
SPI1_ReadINTBuf and prints the received data in DebugAnalyzer.   </td></tr>
</table>
<div style="page-break-after: always;"></div><center><div id="table_10_9"><b>Table 10-9 SPI Sample Code 9 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 9  </th><th class="markdownTableHeadNone">spi_slave_write_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:180px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:670px">Demonstrate how SPI sends data in slave mode by GDMA.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\spi\slave\spi_slave_write_demo.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">spi_slave_write_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">As shown in Figure 10-8. Connect M2_2 to CS of SPI master device, connect M1_0 <br />
to SCK of SPI master device, connect M1_1 to MISO of SPI master device, and <br />
connect M2_1 to MOSI of SPI master device.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">SPI CS PIN  </td><td class="markdownTableBodyNone">#define PIN_SPI_CS P2_2   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">SPI SCK PIN  </td><td class="markdownTableBodyNone">#define PIN_SPI_SCK P1_0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">SPI MOSI PIN  </td><td class="markdownTableBodyNone">#define PIN_SPI_MOSI P1_1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">SPI MISO PIN  </td><td class="markdownTableBodyNone">#define PIN_SPI_MISO P2_1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">SPI ID  </td><td class="markdownTableBodyNone">SPI0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Mode  </td><td class="markdownTableBodyNone">Slave   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Data Size  </td><td class="markdownTableBodyNone">8-bit   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">1. The data in array sendbuf is sent to SPI master device and prints string <br />
"spi_slave_tx_dma_handler" in DebugAnalyzer.<br />
2. When master device sends data to chip, chip stores the received data in array <br />
SPI_ReadINTBuf and prints string "spi_slave_handler" and the received data <br />
in DebugAnalyzer.   </td></tr>
</table>
<center><div id="table_10_10"><b>Table 10-10 SPI Sample Code 10 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 10  </th><th class="markdownTableHeadNone">spi0_hs_dma_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:180px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:670px">Demonstrate how SPI0 sends and receives data in high-speed mode.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\spi\spi0_hs\spi0_hs_dma_demo.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">spi0_hs_dma_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">As shown in Figure 10-9. Connect M1_2 to CS of SPI slave device, connect M1_3 <br />
to SCK of SPI slave device, connect M1_4 to MISO of SPI slave device, and connect M1_5 to MOSI of SPI slave device.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">SPI CS PIN  </td><td class="markdownTableBodyNone">#define SPI0_HS_CS P1_2   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">SPI SCK PIN  </td><td class="markdownTableBodyNone">#define SPI0_HS_SCK P1_3   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">SPI MOSI PIN  </td><td class="markdownTableBodyNone">#define SPI0_HS_MOSI P1_4   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">SPI MISO PIN  </td><td class="markdownTableBodyNone">#define SPI0_HS_MISO P1_5   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">SPI ID  </td><td class="markdownTableBodyNone">SPI0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Mode  </td><td class="markdownTableBodyNone">Master   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Speed  </td><td class="markdownTableBodyNone">40MHz   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Data Size  </td><td class="markdownTableBodyNone">8-bit   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">1. Press RESET on the EVB and the data in array sendbuf is sent to SPI slave device and print string "spi_tx_dma_handler" in DebugAnalyzer.<br />
2. After slave device receives the data, slave device sends data to chip, chip stores the received data in array readbuf and prints string "spi_rx_dma_handler" and the <br />
received data in DebugAnalyzer.   </td></tr>
</table>
<div style="page-break-after: always;"></div><center><div id="table_10_11"><b>Table 10-11 SPI Sample Code 11 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 11  </th><th class="markdownTableHeadNone">spi2spi_auto_reload_dma.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:180px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:670px">Demonstrate how SPI0 reads data and SPI1 sends data by GDMA.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\spi\spi2spi_auto_reload_dma\spi2spi_auto_reload_dma.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">spi2spi_auto_reload_dma()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">As shown in Figure 10-10. Connect M1_7 to CS of SPI slave device 0, connect M1_4 to SCK of SPI slave device 0, connect M1_5 to MISO of SPI slave device 0, and <br />
connect M1_6 to MOSI of SPI slave device 0. Connect M2_5 to CS of SPI slave <br />
device 1, connect M2_2 to SCK of SPI slave device 1, connect M2_3 to MISO of <br />
SPI slave device 1, and connect M2_4 to MOSI of SPI slave device 1.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">SPI0 CS PIN  </td><td class="markdownTableBodyNone">#define PIN_SPI0_CS P1_7   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">SPI0 SCK PIN  </td><td class="markdownTableBodyNone">#define PIN_SPI0_SCK P1_4   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">SPI0 MOSI PIN  </td><td class="markdownTableBodyNone">#define PIN_SPI0_MOSI P1_5   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">SPI0 MISO PIN  </td><td class="markdownTableBodyNone">#define PIN_SPI0_MISO P1_6   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">SPI1 CS PIN  </td><td class="markdownTableBodyNone">#define PIN_SPI1_CS P2_5   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">SPI1 SCK PIN  </td><td class="markdownTableBodyNone">#define PIN_SPI1_SCK P2_2   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">SPI1 MOSI PIN  </td><td class="markdownTableBodyNone">#define PIN_SPI1_MOSI P2_3   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">SPI1 MISO PIN  </td><td class="markdownTableBodyNone">#define PIN_SPI1_MISO P2_4   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">SPI ID  </td><td class="markdownTableBodyNone">SPI0<br />
SPI1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Mode  </td><td class="markdownTableBodyNone">master   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Speed  </td><td class="markdownTableBodyNone">400000   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Data Size  </td><td class="markdownTableBodyNone">8-bit   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">SPI0 reads data from SPI slave device 0 and SPI1 sends the same data to SPI slave <br />
device 1.   </td></tr>
</table>
<div style="page-break-after: always;"></div><center><div id="table_10_12"><b>Table 10-12 SPI Sample Code 12 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 12  </th><th class="markdownTableHeadNone">spi2spi_dma_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:180px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:670px">Demonstrate how SPI0 reads data and SPI1 sends data by auto-reload GDMA.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\spi\spi2spi_dma\spi2spi_dma_demo.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">spi2spi_dma_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">As shown in Figure 10-10. Connect M1_7 to CS of SPI slave device 0, connect M1_4 to SCK of SPI slave device 0, connect M1_5 to MISO of SPI slave device 0, and <br />
connect M1_6 to MOSI of SPI slave device 0. Connect M2_5 to CS of SPI slave <br />
device 1, connect M2_2 to SCK of SPI slave device 1, connect M2_3 to MISO of <br />
SPI slave device 1, and connect M2_4 to MOSI of SPI slave device 1.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">SPI0 CS PIN  </td><td class="markdownTableBodyNone">#define PIN_SPI0_CS P1_7   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">SPI0 SCK PIN  </td><td class="markdownTableBodyNone">#define PIN_SPI0_SCK P1_4   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">SPI0 MOSI PIN  </td><td class="markdownTableBodyNone">#define PIN_SPI0_MOSI P1_5   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">SPI0 MISO PIN  </td><td class="markdownTableBodyNone">#define PIN_SPI0_MISO P1_6   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">SPI1 CS PIN  </td><td class="markdownTableBodyNone">#define PIN_SPI1_CS P2_5   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">SPI1 SCK PIN  </td><td class="markdownTableBodyNone">#define PIN_SPI1_SCK P2_2   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">SPI1 MOSI PIN  </td><td class="markdownTableBodyNone">#define PIN_SPI1_MOSI P2_3   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">SPI1 MISO PIN  </td><td class="markdownTableBodyNone">#define PIN_SPI1_MISO P2_4   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">SPI ID  </td><td class="markdownTableBodyNone">SPI0<br />
SPI1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Mode  </td><td class="markdownTableBodyNone">master   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Speed  </td><td class="markdownTableBodyNone">400000   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Data Size  </td><td class="markdownTableBodyNone">8-bit   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">SPI0 reads data from SPI slave device 0 and SPI1 sends the same data to SPI slave <br />
device 1.   </td></tr>
</table>
<div style="page-break-after: always;"></div><center><div id="table_10_13"><b>Table 10-13 SPI Sample Code 13 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 13  </th><th class="markdownTableHeadNone">spi_slave_rx_dma_hs_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:180px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:670px">Demonstrate how SPI0 slave reads data for high speed by dma mode.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\spi\slave\spi_slave_rx_dma_hs_demo.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">spi_slave_rx_dma_hs_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">As shown in Figure 10-11. Connect M1_1 to CS of SPI master device, connect M0_0 <br />
to SCK of SPI master device, connect M0_1 to MISO of SPI master device, and <br />
connect M1_0 to MOSI of SPI master device.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">SPI CS PIN  </td><td class="markdownTableBodyNone">#define PIN_SPI_CS P1_1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">SPI SCK PIN  </td><td class="markdownTableBodyNone">#define PIN_SPI_SCK P0_0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">SPI MOSI PIN  </td><td class="markdownTableBodyNone">#define PIN_SPI_MOSI P1_0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">SPI MISO PIN  </td><td class="markdownTableBodyNone">#define PIN_SPI_MISO P0_1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">SPI ID  </td><td class="markdownTableBodyNone">SPI0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Mode  </td><td class="markdownTableBodyNone">Slave   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Speed  </td><td class="markdownTableBodyNone">10MHz   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Data Size  </td><td class="markdownTableBodyNone">8-bit   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">Print string "spi_slave_rx_dma_handler! rx_len_all 1000" and the received <br />
data in DebugAnalyzer.   </td></tr>
</table>
<center><div id="table_10_14"><b>Table 10-14 SPI Sample Code 14 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 14  </th><th class="markdownTableHeadNone">spi_slave_tx_dma_hs_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:180px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:670px">Demonstrate how SPI0 slave sends data for high speed by dma mode.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\spi\slave\spi_slave_tx_dma_hs_demo.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">spi_slave_tx_dma_hs_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">As shown in Figure 10-11. Connect M1_1 to CS of SPI master device, connect M0_0 <br />
to SCK of SPI master device, connect M0_1 to MISO of SPI master device, and <br />
connect M1_0 to MOSI of SPI master device.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">SPI CS PIN  </td><td class="markdownTableBodyNone">#define PIN_SPI_CS P1_1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">SPI SCK PIN  </td><td class="markdownTableBodyNone">#define PIN_SPI_SCK P0_0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">SPI MOSI PIN  </td><td class="markdownTableBodyNone">#define PIN_SPI_MOSI P1_0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">SPI MISO PIN  </td><td class="markdownTableBodyNone">#define PIN_SPI_MISO P0_1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">SPI ID  </td><td class="markdownTableBodyNone">SPI0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Mode  </td><td class="markdownTableBodyNone">Slave   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Speed  </td><td class="markdownTableBodyNone">10MHz   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Data Size  </td><td class="markdownTableBodyNone">8-bit   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">The data in array sendbuf is sent to SPI master device and prints string <br />
"spi_slave_tx_dma_handler! tx_len_all 1000" in DebugAnalyzer.   </td></tr>
</table>
<div style="page-break-after: always;"></div><center><div id="table_10_15"><b>Table 10-15 SPI Sample Code 15 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 15  </th><th class="markdownTableHeadNone">spi_rgb_polling_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:180px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:670px">Demonstrate how SPI1 as one data line to control LED by polling mode.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\spi\polling\spi_rgb_polling_demo.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">spi_rgb_polling_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">Connect M1_0 to LED controller.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">SPI MOSI PIN  </td><td class="markdownTableBodyNone">#define PIN_SPI1_MOSI P1_0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">SPI ID  </td><td class="markdownTableBodyNone">SPI1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Mode  </td><td class="markdownTableBodyNone">Master   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Speed  </td><td class="markdownTableBodyNone">10MHz   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Data Size  </td><td class="markdownTableBodyNone">8-bit   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">Press RESET on the EVB, the data in array SPI_WriteBuf is sent to LED controller. <br />
Adjust rgb_data to light up different lights.   </td></tr>
</table>
<center><div id="table_10_16"><b>Table 10-16 SPI Sample Code 16 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 16  </th><th class="markdownTableHeadNone">spi_rgb_interrupt_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:180px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:670px">Demonstrate how SPI1 as one data line to control LED by interrupt mode.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\spi\interrupt\spi_rgb_interrupt_demo.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">spi_rgb_interrupt_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">Connect M1_0 to LED controller.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">SPI MOSI PIN  </td><td class="markdownTableBodyNone">#define PIN_SPI_MOSI P1_0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">SPI ID  </td><td class="markdownTableBodyNone">SPI1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Mode  </td><td class="markdownTableBodyNone">Master   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Speed  </td><td class="markdownTableBodyNone">10MHz   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Data Size  </td><td class="markdownTableBodyNone">8-bit   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">Press RESET on the EVB, the data in array SPI_WriteBuf is sent to LED controller. <br />
And print string "spi_tx_handler: SPI TX FIFO Empty" in DebugAnalyzer. <br />
Adjust rgb_data to light up different lights.   </td></tr>
</table>
<center><div id="table_10_17"><b>Table 10-17 SPI Sample Code 17 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 17  </th><th class="markdownTableHeadNone">spi_rgb_dma_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:180px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:670px">Demonstrate how SPI1 as one data line to control LED by dma mode.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\gdma\spi_dma\spi_rgb_dma_demo.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">spi_rgb_dma_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">Connect M1_0 to LED controller.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">SPI MOSI PIN  </td><td class="markdownTableBodyNone">#define PIN_SPI_MOSI P1_0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">SPI ID  </td><td class="markdownTableBodyNone">SPI1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Mode  </td><td class="markdownTableBodyNone">Master   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Speed  </td><td class="markdownTableBodyNone">10MHz   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Data Size  </td><td class="markdownTableBodyNone">8-bit   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">Press RESET on the EVB, the data in array SPI_WriteBuf is sent to LED controller. <br />
And print string "spi_tx_dma_handler" in DebugAnalyzer. Adjust rgb_data to light <br />
up different lights.   </td></tr>
</table>
<div class="image">
<img src="SPI_Demo_1_Hardware_Connection_Diagram.jpg" alt="SPI_Demo_1_Hardware_Connection_Diagram.jpg"/>
</div>
 <center><div id="figure_10_1"><b>Figure 10-1 SPI Demo 1 Hardware Connection Diagram</b></div></center><div class="image">
<img src="SPI_Demo_2_Hardware_Connection_Diagram.jpg" alt="SPI_Demo_2_Hardware_Connection_Diagram.jpg"/>
</div>
 <center><div id="figure_10_2"><b>Figure 10-2 SPI Demo 2/6 Hardware Connection Diagram</b></div></center><div class="image">
<img src="SPI_Demo_3_Hardware_Connection_Diagram.jpg" alt="SPI_Demo_3_Hardware_Connection_Diagram.jpg"/>
</div>
 <center><div id="figure_10_3"><b>Figure 10-3 SPI Demo 3 Hardware Connection Diagram</b></div></center><div class="image">
<img src="SPI_Demo_4_Hardware_Connection_Diagram.jpg" alt="SPI_Demo_4_Hardware_Connection_Diagram.jpg"/>
</div>
 <center><div id="figure_10_4"><b>Figure 10-4 SPI Demo 4 Hardware Connection Diagram</b></div></center><div class="image">
<img src="SPI_Demo_5_Hardware_Connection_Diagram.jpg" alt="SPI_Demo_5_Hardware_Connection_Diagram.jpg"/>
</div>
 <center><div id="figure_10_5"><b>Figure 10-5 SPI Demo 5 Hardware Connection Diagram</b></div></center><div class="image">
<img src="SPI_Demo_7_Hardware_Connection_Diagram.jpg" alt="SPI_Demo_7_Hardware_Connection_Diagram.jpg"/>
</div>
 <center><div id="figure_10_6"><b>Figure 10-6 SPI Demo 7 Hardware Connection Diagram</b></div></center><div class="image">
<img src="SPI_Demo_8_Hardware_Connection_Diagram.jpg" alt="SPI_Demo_8_Hardware_Connection_Diagram.jpg"/>
</div>
 <center><div id="figure_10_7"><b>Figure 10-7 SPI Demo 8 Hardware Connection Diagram</b></div></center><div class="image">
<img src="SPI_Demo_9_Hardware_Connection_Diagram.jpg" alt="SPI_Demo_9_Hardware_Connection_Diagram.jpg"/>
</div>
 <center><div id="figure_10_8"><b>Figure 10-8 SPI Demo 9 Hardware Connection Diagram</b></div></center><div class="image">
<img src="SPI_Demo_10_Hardware_Connection_Diagram.jpg" alt="SPI_Demo_10_Hardware_Connection_Diagram.jpg"/>
</div>
 <center><div id="figure_10_9"><b>Figure 10-9 SPI Demo 10 Hardware Connection Diagram</b></div></center><div class="image">
<img src="SPI_Demo_11_Hardware_Connection_Diagram.jpg" alt="SPI_Demo_11_Hardware_Connection_Diagram.jpg"/>
</div>
 <center><div id="figure_10_10"><b>Figure 10-10 SPI Demo 11/12 Hardware Connection Diagram</b></div></center><div class="image">
<img src="SPI_Demo_12_Hardware_Connection_Diagram.jpg" alt="SPI_Demo_12_Hardware_Connection_Diagram.jpg"/>
</div>
 <center><div id="figure_10_11"><b>Figure 10-11 SPI Demo 13/14 Hardware Connection Diagram</b></div></center><h3><a class="anchor" id="SPI_Function_Description"></a>
10.2  Function Description</h3>
<p>SPI allows the chip to communicate with external devices in half/full duplex, synchronous, and serial. This interface can be configured in master or slave mode and provides the communication clock (SCK) for external slave devices. <br />
Up to three SPIs can communicate at speeds of up to 20 Mbits/s in master mode in full-duplex and simplex communication modes, and the frame can be configured to be 4 bits or 32 bits. The 16-bit prescaler gives the configurable frequencies. <br />
The speed of up to 5 Mbits/s in slave mode is supported in SPI0, and the frame can be configured to be 4 bits or 16 bits. <br />
The SPIs may also interface with the GDMA Controller using an optional set of GDMA signals, which can be selected at configuration time.</p>
<h3><a class="anchor" id="SPI_Feature_List"></a>
10.3  Feature List</h3>
<ul>
<li>Up to 3 SPI</li>
<li>Support master and slave mode</li>
<li>4 transfer modes: transmit and receive, transmit only, receive only, EEPROM read</li>
<li>Support 4-bit to 32-bit data size in master mode</li>
<li>Support 4-bit to 16-bit data size in slave mode</li>
<li>Support multi-slave mode</li>
<li>Support up to 3 slave devices in master mode</li>
<li>Support DMA</li>
</ul>
<p><b>Note:</b> RTL87X3D and RTL87X3E support 3 SPI, SPI0 supports master mode and slave mode, SPI1 and SPI2 only support master mode. RTL87X3G supports 1 SPI, only master mode is supported.</p>
<p><b>Note:</b> SPI0 and SPI1 support 3 slave devices in master mode, and SPI2 support 1 slave device in master mode.</p>
<p><b>Note:</b> If the user needs to operate flash and read data from flash, it is recommended to use <b>SPI_Direction_EEPROM</b> mode. In this mode, the SPI controller will automatically supplement the padding bits needed for reading back. Set the read data length by <a class="el" href="group___s_p_i___exported__functions.html#gabb6f4d9fd43ab1c1dbd07fb83e52a9fb" title="set read Data length only in EEPROM mode through the SPIx peripheral,which enables you to receive up ...">SPI_SetReadLen()</a> before reading from flash, then the result of <a class="el" href="group___s_p_i___exported__functions.html#ga7cd0e453b360b4e63cc14fc76d88bf23" title="read data length in Rx FIFO through the SPIx peripheral. ">SPI_GetRxFIFOLen()</a> will equal this value. If <b>SPI_Direction_FullDuplex</b> mode is used when operating flash, it needs to supplement the padding bits manually and the number of bytes should be equal to the read data length. In this way, the result of <a class="el" href="group___s_p_i___exported__functions.html#ga7cd0e453b360b4e63cc14fc76d88bf23" title="read data length in Rx FIFO through the SPIx peripheral. ">SPI_GetRxFIFOLen()</a> is the total length of padding bits and data to read. <a class="el" href="group___s_p_i___exported__functions.html#gabb6f4d9fd43ab1c1dbd07fb83e52a9fb" title="set read Data length only in EEPROM mode through the SPIx peripheral,which enables you to receive up ...">SPI_SetReadLen()</a> is just for SPI_Direction_EEPROM mode.</p>
<p><b>Note:</b> The SPI slave does not support TX underflow conditions. The tx FIFO needs to be filled in with data before SPI master sends and reads. There are these methods to avoid this issue: <br />
 (1) sending data to slave tx fifo before transmission, and toggle a GPIO to notify master to send data. For the specific implementation, please refer to the demo code in sdk/src/sample/io_demo/spi/slave/spi_slave_gpio_demo.c <br />
 (2) using GDMA for SPI slave to send data.</p>
<p><b>Note:</b> The SPI slave needs to adjust slow clk to support high speed, as shown in Table 10-18 and Table 10-19. For details, please refer to the demo code in sdk/src/sample/io_demo/spi/slave/spi_slave_tx_dma_hs_demo.c and sdk/src/sample/io_demo/spi/slave/spi_slave_rx_dma_hs_demo.c</p>
<center><div id="table_10_18"><b>Table 10-18 SPI Slow Clk Settings in RTL87X3E</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">spi clk div  </th><th class="markdownTableHeadCenter">spi clk  </th><th class="markdownTableHeadCenter">slave rx slow clk  </th><th class="markdownTableHeadCenter">slave tx slow clk   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">16  </td><td class="markdownTableBodyCenter">2.5MHz  </td><td class="markdownTableBodyCenter">/  </td><td class="markdownTableBodyCenter">1.25MHz   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">10  </td><td class="markdownTableBodyCenter">4MHz  </td><td class="markdownTableBodyCenter">/  </td><td class="markdownTableBodyCenter">1.25MHz   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">8  </td><td class="markdownTableBodyCenter">5MHz  </td><td class="markdownTableBodyCenter">/  </td><td class="markdownTableBodyCenter">2.5MHz   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">4  </td><td class="markdownTableBodyCenter">10MHz  </td><td class="markdownTableBodyCenter">2.5M  </td><td class="markdownTableBodyCenter">4MHz   </td></tr>
</table>
<center><div id="table_10_19"><b>Table 10-19 SPI Slow Clk Settings in RTL87X3D</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">spi clk div  </th><th class="markdownTableHeadCenter">spi clk  </th><th class="markdownTableHeadCenter">slave tx slow clk   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">8  </td><td class="markdownTableBodyCenter">5MHz  </td><td class="markdownTableBodyCenter">2.5MHz   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">4  </td><td class="markdownTableBodyCenter">10MHz  </td><td class="markdownTableBodyCenter">5MHz   </td></tr>
</table>
<h3><a class="anchor" id="SPI_Communication_Sequence_Diagram"></a>
10.4  SPI Communication Sequence Diagram</h3>
<p>To transmit data, both SPI peripherals must have identical serial clock phase (SCPH) and clock polarity (SCPOL) values. <br />
The clock polarity (SCPOL) configuration parameter determines whether the inactive state of the serial clock is high or low. <br />
When the configuration parameter SCPH = 0, data transmission begins on the falling edge of the slave select signal. The first data bit is captured by the master and slave peripherals on the first edge of the serial clock. Therefore, valid data must be present on the MOSI and MISO lines before the first serial clock edge. <br />
When the configuration parameter SCPH = 1, both master and slave peripherals begin transmitting data on the first serial clock edge after the slave select line is activated. The first data bit is captured on the second serial clock edge. Data is propagated by the master and slave peripherals on the leading edge of the serial clock.</p>
<div class="image">
<img src="SPI_Communication_Sequence_Diagram_SCPH_0.jpg" alt="SPI_Communication_Sequence_Diagram_SCPH_0.jpg"/>
</div>
 <center><div id="figure_10_11"><b>Figure 10-11 SPI Communication Sequence Diagram (SCPH = 0)</b></div></center><div class="image">
<img src="SPI_Communication_Sequence_Diagram_SCPH_1.jpg" alt="SPI_Communication_Sequence_Diagram_SCPH_1.jpg"/>
</div>
 <center><div id="figure_10_12"><b>Figure 10-12 SPI Communication Sequence Diagram (SCPH = 1)</b></div></center><h3><a class="anchor" id="SPI_Initialization_Flow"></a>
10.5  SPI Initialization Flow</h3>
<p>SPI initialization flow is shown in Figure 10-13.</p>
<div class="image">
<img src="SPI_Initialization_Flow_Chart.jpg" alt="SPI_Initialization_Flow_Chart.jpg"/>
</div>
 <center><div id="figure_10_13"><b>Figure 10-13 SPI Initialization Flow Chart</b></div></center><p>The codes below show SPI initialization flow. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> driver_spi_init(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* turn on SPI clock */</span></div><div class="line">    <a class="code" href="group__x3e___r_c_c___exported___functions.html#ga0ff78e34dcddb1ed9a215ee66ccb2d1b">RCC_PeriphClockCmd</a>(<a class="code" href="group___a_p_b___peripheral___define.html#ga3f53d9e6b397b3ef7704b30526cee10a">APBPeriph_SPI1</a>, <a class="code" href="group___r_c_c___peripheral___clock.html#ga157950b836be7785bbdfaac097e4cf6b">APBPeriph_SPI1_CLOCK</a>, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line"></div><div class="line">    <a class="code" href="struct_s_p_i___init_type_def.html">SPI_InitTypeDef</a>  SPI_InitStructure;</div><div class="line">    <a class="code" href="group___s_p_i___exported__functions.html#ga9a0116f88cc2c4478c270f05608703f1">SPI_StructInit</a>(&amp;SPI_InitStructure);</div><div class="line"></div><div class="line">    SPI_InitStructure.<a class="code" href="struct_s_p_i___init_type_def.html#a485dbba7798a7ff3d00dfabba19584b8">SPI_Direction</a>   = <a class="code" href="group___s_p_i__data__direction.html#gaab502be666b226fbdfb8297b50512d72">SPI_Direction_FullDuplex</a>;</div><div class="line">    SPI_InitStructure.<a class="code" href="struct_s_p_i___init_type_def.html#aeddd33e224d56672843782c105ed82e4">SPI_Mode</a>        = <a class="code" href="group___s_p_i__mode.html#gaa9e47fb7c1d6c4655b72a00ed1f3b651">SPI_Mode_Master</a>;</div><div class="line">    SPI_InitStructure.<a class="code" href="struct_s_p_i___init_type_def.html#a541e4cbd533e4102ffeffbe8388a38d6">SPI_DataSize</a>    = <a class="code" href="group___s_p_i__data__size.html#ga56721814a935922b6ca7c49060509765">SPI_DataSize_8b</a>;</div><div class="line">    SPI_InitStructure.<a class="code" href="struct_s_p_i___init_type_def.html#ae8d27aca088402c07e34e5a2ab4902d9">SPI_CPOL</a>        = <a class="code" href="group___s_p_i___clock___polarity.html#ga4431f2edf42f8298d5bbe693351edbb0">SPI_CPOL_High</a>;</div><div class="line">    SPI_InitStructure.<a class="code" href="struct_s_p_i___init_type_def.html#a120f808113ce7d69e2ec1ea65abed627">SPI_CPHA</a>        = <a class="code" href="group___s_p_i___clock___phase.html#gaade9d9555fac8a302bde5c94da9c7292">SPI_CPHA_1Edge</a>;</div><div class="line">    SPI_InitStructure.<a class="code" href="struct_s_p_i___init_type_def.html#acc626f49e8642f9e6807576b6f342217">SPI_BaudRatePrescaler</a>  = 100;</div><div class="line">    SPI_InitStructure.<a class="code" href="struct_s_p_i___init_type_def.html#a1be6bfbb58bbb72d54c90910f22d7c1b">SPI_FrameFormat</a> = <a class="code" href="group___s_p_i__frame__format.html#gaa52039a1a5915c451290d7c6a7eb69a1">SPI_Frame_Motorola</a>;</div><div class="line"></div><div class="line">    <a class="code" href="group___s_p_i___exported__functions.html#ga8dacc1dc48bf08c0f12da409f4889037">SPI_Init</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#gad483be344a28ac800be8f03654a9612f">SPI1</a>, &amp;SPI_InitStructure);</div><div class="line">    <a class="code" href="group___s_p_i___exported__functions.html#gaa31357879a65ee1ed7223f3b9114dcf3">SPI_Cmd</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#gad483be344a28ac800be8f03654a9612f">SPI1</a>, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="SPI_External_Flash"></a>
10.6  SPI External Flash</h3>
<p>This section introduces how to communicate with external flash by SPI. Please refer to <a href="#table_10_3">Table 10-3 SPI Sample Code 3 Description</a> for demo code and refer to <a href="#figure_10_3">Figure 10-3 SPI Demo 3 Hardware Connection Diagram</a> for hardware connection.</p>
<h4><a class="anchor" id="SPI_Hardware_Connection"></a>
10.6.1  Hardware Connection</h4>
<p>Users need to modify the pin related to external flash in the code according to the hardware design. The macro definition below shows the pin defined in code.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define FLASH_SCK                   P5_0</span></div><div class="line"><span class="preprocessor">#define FLASH_MOSI                  P5_2</span></div><div class="line"><span class="preprocessor">#define FLASH_MISO                  P5_3</span></div><div class="line"><span class="preprocessor">#define FLASH_CS                    P5_1</span></div><div class="line"><span class="preprocessor">#define FLASH_HOLD                  P5_5</span></div></div><!-- fragment --><h4><a class="anchor" id="External_Flash_Demo_Code"></a>
10.6.2  Demo Code</h4>
<p>Users can implement functions to communicate with external flash by referring to the demo code in <a href="#table_10_3">Table 10-3 SPI Sample Code 3 Description</a>.</p>
<p><a class="anchor" id="invalid"></a></p><h5>10.6.2.1 Commands For External Flash</h5>
<p>Different flash models may have different commands, users can modify the following definitions according to flash spec. </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span></div><div class="line">{</div><div class="line">    EXT_FLASH_WRITE_STATUS_CMD      = 0x01,</div><div class="line">    EXT_FLASH_PROGRAM_CMD           = 0x02,</div><div class="line">    EXT_FLASH_READ_CMD              = 0x03,</div><div class="line">    EXT_FLASH_WRITE_DISABLE_CMD     = 0x04,</div><div class="line">    EXT_FLASH_READ_STATUS_CMD       = 0x05,</div><div class="line">    EXT_FLASH_WRITE_ENABLE_CMD      = 0x06,</div><div class="line">    EXT_FLASH_SECTOR_ERASE_CMD      = 0x20,</div><div class="line">    EXT_FLASH_BLOCK_ERASE_32_CMD    = 0x52,</div><div class="line">    EXT_FLASH_CHIP_ERASE_CMD        = 0x60,</div><div class="line">    EXT_FLASH_BLOCK_ERASE_64_CMD    = 0xd8,</div><div class="line">    EXT_FLASH_READ_ID_CMD           = 0x9F,</div><div class="line">    EXT_FLASH_RELEASE_DEEP_SLEEP    = 0xAB,</div><div class="line">    EXT_FLASH_DEEP_SLEEP            = 0xB9,</div><div class="line">    EXT_FLASH_SOFTWARE_RESET_ENABLE = 0x66,</div><div class="line">    EXT_FLASH_SOFTWARE_RESET        = 0x99,</div><div class="line">} EXT_FLASH_OPERATION_CMD;</div></div><!-- fragment --><p><a class="anchor" id="invalid"></a></p><h5>10.6.2.2 Initialization Of External Flash</h5>
<p>Users can refer to the following function to initialize external flash. In this function, it will initialize SPI and reset external flash. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> ext_flash_spi_init(<span class="keywordtype">void</span>)</div></div><!-- fragment --><p><a class="anchor" id="invalid"></a></p><h5>10.6.2.3 Erase External Flash</h5>
<p>Users can refer to the following function to erase external flash. Sector, block, and chip are the three common erase commands used for flash. </p><div class="fragment"><div class="line">EXT_FLASH_SPI_OPERATION_STATUS ext_flash_spi_erase(uint32_t address, EXT_FLASH_OPERATION_CMD mode)</div></div><!-- fragment --><p><a class="anchor" id="invalid"></a></p><h5>10.6.2.4 Write External Flash</h5>
<p>Users can refer to the following function to write external flash by polling mode. </p><div class="fragment"><div class="line">EXT_FLASH_SPI_OPERATION_STATUS ext_flash_spi_page_program(uint32_t address, uint8_t *psendBuf, uint16_t len)</div></div><!-- fragment --><p>Users can refer to the following function to write external flash by interrupt mode. </p><div class="fragment"><div class="line">EXT_FLASH_SPI_OPERATION_STATUS ext_flash_spi_page_program_by_interrupt(uint32_t address, uint8_t *psendBuf, uint16_t len)</div></div><!-- fragment --><p>Users can refer to the following function to write external flash by DMA mode. </p><div class="fragment"><div class="line">EXT_FLASH_SPI_OPERATION_STATUS ext_flash_spi_page_program_by_dma(uint32_t address, uint8_t *psendBuf, uint16_t len)</div></div><!-- fragment --><p><a class="anchor" id="invalid"></a></p><h5>10.6.2.5 Read External Flash</h5>
<p>Users can refer to the following function to read external flash by polling mode. </p><div class="fragment"><div class="line">EXT_FLASH_SPI_OPERATION_STATUS ext_flash_spi_read(uint32_t address, uint8_t *pStoreBuf, uint16_t len)</div></div><!-- fragment --><p>Users can refer to the following function to read external flash by interrupt mode. </p><div class="fragment"><div class="line">EXT_FLASH_SPI_OPERATION_STATUS ext_flash_spi_read_by_interrupt(uint32_t address, uint8_t *pStoreBuf, uint16_t len)</div></div><!-- fragment --><p>Users can refer to the following function to read external flash by DMA mode. </p><div class="fragment"><div class="line">EXT_FLASH_SPI_OPERATION_STATUS ext_flash_spi_read_by_dma(uint32_t address, uint8_t *pStoreBuf, uint16_t len)</div></div><!-- fragment --><div style="page-break-after: always;"></div><h2><a class="anchor" id="IR"></a>
11  IR</h2>
<h3><a class="anchor" id="IR_Demo_Code_Support_List"></a>
11.1 IR Demo Code Support List</h3>
<center><div id="table_11_1"><b>Table 11-1 IR Sample Code 1 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 1  </th><th class="markdownTableHeadNone">ir_send_polling_mode_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:180px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:670px">Demonstrate how IR sends data by polling.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\ir\send\ir_send_polling_mode_demo.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">ir_send_polling_mode_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">Connect M2_2 to channel0 of logic analyzer.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">The waveform displayed by channel 0 of the logic analyzer is shown in Figure 11-1.   </td></tr>
</table>
<center><div id="table_11_2"><b>Table 11-2 IR Sample Code 2 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 2  </th><th class="markdownTableHeadNone">ir_send_interrupt_demo.c<br />
ir_nec_protocol.c<br />
ir_nec_   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:180px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:670px">Demonstrate how IR sends data by interrupt.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\ir\send\ir_send_interrupt_demo.c<br />
sdk\src\sample\io_demo\ir\protocol\ir_nec_protocol.c<br />
sdk\src\sample\io_demo\ir\protocol\ir_nec_protocol.h   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">ir_send_interrupt_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">Connect M2_2 to channel 0 of logic analyzer.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">The waveform displayed by channel 0 of the logic analyzer is shown in Figure 11-2.   </td></tr>
</table>
<center><div id="table_11_3"><b>Table 11-3 IR Sample Code 3 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 3  </th><th class="markdownTableHeadNone">ir_receive_demo.c<br />
ir_nec_protocol.c<br />
ir_nec_protoco   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:180px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:670px">Demonstrate how IR receives data by interrupt.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\ir\receive\ir_receive_demo.c<br />
sdk\src\sample\io_demo\ir\protocol\ir_nec_protocol.c<br />
sdk\src\sample\io_demo\ir\protocol\ir_nec_protocol.h   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">ir_receive_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">Connect M0_2 to receiving end of IR transceiver module, connect VCC of EVB to <br />
VCC of IR transceiver module, and connect GND of EVB to GND of IR transceiver <br />
module.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">Send IR data to IR transceiver module by IR remote control. The received data is <br />
stored in array IR_DataStruct.irBuf.   </td></tr>
</table>
<div style="page-break-after: always;"></div><center><div id="table_11_4"><b>Table 11-4 IR Sample Code 4 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 4  </th><th class="markdownTableHeadNone">ir_pulse_detection_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:180px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:670px">Demonstrate IR pulse detection.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\ir\pulse_detection\ir_pulse_detection_demo.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">ir_pulse_detection_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">Connect M2_1 to PWM output.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">Print PWM frequency, high level count, and low level count information in <br />
DebugAnalyser.   </td></tr>
</table>
<div class="image">
<img src="IR_Demo_1_Expected_Result_Diagram.jpg" alt="IR_Demo_1_Expected_Result_Diagram.jpg"/>
</div>
 <center><div id="figure_11_1"><b>Figure 11-1 IR Demo 1 Expected Result Diagram</b></div></center><div class="image">
<img src="IR_Demo_2_Expected_Result_Diagram.jpg" alt="IR_Demo_2_Expected_Result_Diagram.jpg"/>
</div>
 <center><div id="figure_11_2"><b>Figure 11-2 IR Demo 2 Expected Result Diagram</b></div></center><h3><a class="anchor" id="IR_Function_Description"></a>
11.2  Function Description</h3>
<p>The infrared module can realize infrared wireless communication with adjacent devices.</p>
<p><b>Note:</b> RTL87X3D and RTL87X3E support IR, RTL87X3G doesn't support IR.</p>
<div class="image">
<img src="Schematic_Diagram_of_IR_Module.jpg" alt="Schematic_Diagram_of_IR_Module.jpg"/>
</div>
 <center><div id="figure_11_3"><b>Figure 11-3 Schematic Diagram of IR Module</b></div></center><h3><a class="anchor" id="IR_Feature_List"></a>
11.3  Feature List</h3>
<ul>
<li>Configurable carrier frequency</li>
<li>Configurable carrier duty cycle</li>
<li>Configurable carrier ON/OFF time</li>
<li>Hardware Controlled Waveform Output</li>
<li>Support any infrared communication protocol</li>
<li>Support GDMA</li>
<li>RX mode and TX mode cannot work at the same time</li>
<li>IR module must be reset when switching between RX mode and TX mode</li>
</ul>
<h3><a class="anchor" id="IR_TX"></a>
11.4  IR TX</h3>
<p>The schematic diagram of IR TX is shown in the figure below.</p>
<div class="image">
<img src="Schematic_Diagram_of_IR_TX.jpg" alt="Schematic_Diagram_of_IR_TX.jpg"/>
</div>
 <center><div id="figure_11_4"><b>Figure 11-4 Schematic Diagram of IR TX</b></div></center><h3><a class="anchor" id="IR_TX_Operation_Flow"></a>
11.5  Send Data Operation Flow</h3>
<h4><a class="anchor" id="IR_TX_Initialization_Flow"></a>
11.5.1  IR Initialization Flow</h4>
<p>IR initialization flow is shown in Figure 11-5.</p>
<div class="image">
<img src="IR_Initialization_Flow_Chart.jpg" alt="IR_Initialization_Flow_Chart.jpg"/>
</div>
 <center><div id="figure_11_5"><b>Figure 11-5 IR Initialization Flow Chart</b></div></center><div style="page-break-after: always;"></div><p>The codes below show IR initialization flow. </p><div class="fragment"><div class="line"><span class="comment">/* Enable IR clock */</span></div><div class="line"><a class="code" href="group__x3e___r_c_c___exported___functions.html#ga0ff78e34dcddb1ed9a215ee66ccb2d1b">RCC_PeriphClockCmd</a>(<a class="code" href="group___a_p_b___peripheral___define.html#ga3f923565574d0287bc5ecb7205c54202">APBPeriph_IR</a>, <a class="code" href="group___r_c_c___peripheral___clock.html#ga091ed613a522f265331710a8a132e7d0">APBPeriph_IR_CLOCK</a>, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line"></div><div class="line"><span class="comment">/* Initialize IR */</span></div><div class="line"><a class="code" href="struct_i_r___init_type_def.html">IR_InitTypeDef</a> IR_InitStruct;</div><div class="line"><a class="code" href="group___i_r___exported___functions.html#gaeb4d63c4b589f27b0d4078d709d5a720">IR_StructInit</a>(&amp;IR_InitStruct);</div><div class="line">IR_InitStruct.<a class="code" href="struct_i_r___init_type_def.html#a8968c93e28cbccf581075933327180cc">IR_Freq</a>           = 38;</div><div class="line">IR_InitStruct.<a class="code" href="struct_i_r___init_type_def.html#a502f637a541e47e550a7c3a45054646b">IR_DutyCycle</a>      = 2; <span class="comment">/* !&lt; 1/2 duty cycle */</span></div><div class="line">IR_InitStruct.<a class="code" href="struct_i_r___init_type_def.html#a01fe3780fbd7c70b50b6fe508317a63a">IR_Mode</a>           = <a class="code" href="group___i_r___mode.html#ga5acc9c2dbf5114f93857996feaeba701">IR_MODE_TX</a>;</div><div class="line">IR_InitStruct.<a class="code" href="struct_i_r___init_type_def.html#af71977d89e04a5815d1b50f54ff4645e">IR_TxInverse</a>      = <a class="code" href="group___i_r___t_x___data___type.html#ga934063bdc25f0cdb6873be9c650ed070">IR_TX_DATA_NORMAL</a>;</div><div class="line">IR_InitStruct.<a class="code" href="struct_i_r___init_type_def.html#a8281ef8c138726b99d23f8e5902e4cd6">IR_TxIdleLevel</a>    = <a class="code" href="group___i_r___idle___status.html#ga4dcc88863575d21a44666d62c204a4ac">IR_IDLE_OUTPUT_LOW</a>;</div><div class="line">IR_InitStruct.<a class="code" href="struct_i_r___init_type_def.html#a5be73bb821a3a77ad77781261627f70b">IR_TxFIFOThrLevel</a> = IR_TX_FIFO_THR_LEVEL;</div><div class="line"><a class="code" href="group___i_r___exported___functions.html#gaf6abc176153d12a5d09f89896492f230">IR_Init</a>(&amp;IR_InitStruct);</div><div class="line"></div><div class="line"><span class="comment">/* Configure NVIC */</span></div><div class="line"><a class="code" href="struct_n_v_i_c___init_type_def.html">NVIC_InitTypeDef</a> NVIC_InitStruct;</div><div class="line">NVIC_InitStruct.<a class="code" href="struct_n_v_i_c___init_type_def.html#a921af0ab04e071d7d276c003e0048123">NVIC_IRQChannel</a> = <a class="code" href="group__x3e___r_t_l876x___exported__types.html#gga666eb0caeb12ec0e281415592ae89083abeeba60b6f454bd82431ed946d20c4f6">IR_IRQn</a>;</div><div class="line">NVIC_InitStruct.<a class="code" href="struct_n_v_i_c___init_type_def.html#acd582bc2edce30e9d7ab5e0ede400f36">NVIC_IRQChannelPriority</a> = 2;</div><div class="line">NVIC_InitStruct.<a class="code" href="struct_n_v_i_c___init_type_def.html#a3c5567ef024a0489884083c88f17b4d5">NVIC_IRQChannelCmd</a> = <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>;</div><div class="line"><a class="code" href="group__x3e___n_v_i_c___exported___functions.html#ga4e06b4f5c9109d6bc8990adf77e5f8d3">NVIC_Init</a>(&amp;NVIC_InitStruct);</div></div><!-- fragment --><h4><a class="anchor" id="IR_Send_Data_Operation_Flow"></a>
11.5.2  IR Send Data Operation Flow</h4>
<p>IR Send Data Operation flow is shown in Figure 11-6.</p>
<div class="image">
<img src="IR_Send_Data_Operation_Flow_Chart.jpg" alt="IR_Send_Data_Operation_Flow_Chart.jpg"/>
</div>
 <center><div id="figure_11_6"><b>Figure 11-6 IR Send Data Operation Flow Chart</b></div></center><div style="page-break-after: always;"></div><p>The codes below show IR sends data operation flow. </p><div class="fragment"><div class="line"><span class="comment">/* Buffer which stores encoded data */</span></div><div class="line">IR_DataTypeDef IR_DataStruct;</div><div class="line"><span class="comment">/* Number of data which has been sent */</span></div><div class="line">uint8_t tx_count = 0;</div><div class="line"></div><div class="line"><span class="comment">/* Data to send */</span></div><div class="line">uint8_t ir_code[2] = {0x16, 0x28};</div><div class="line"></div><div class="line"><span class="comment">/* Make sure TX fifo is empty */</span></div><div class="line"><a class="code" href="group___i_r___exported___functions.html#gafa6c03a3fb16b51509a0c11aac52bbdc">IR_ClearTxFIFO</a>();</div><div class="line"></div><div class="line"><span class="comment">/* Encode by NEC protocol */</span></div><div class="line">IR_NECEncode(38, ir_code[0], ir_code[1], &amp;IR_DataStruct);</div><div class="line"></div><div class="line"><span class="comment">/* Start to send first bytes data of encoded data */</span></div><div class="line"><a class="code" href="group___i_r___exported___functions.html#gab24d44506e374ce140c23092c1f6cbff">IR_SendBuf</a>(IR_DataStruct.irBuf, <a class="code" href="group___i_r___exported___constants.html#ga25a8d10b69c9c47d837ba5e0298ffc12">IR_TX_FIFO_SIZE</a>, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1ad3a9df141be0ccf10389b640f492b26d">DISABLE</a>);</div><div class="line"></div><div class="line"><span class="comment">/* Record number which has been sent */</span></div><div class="line">tx_count = <a class="code" href="group___i_r___exported___constants.html#ga25a8d10b69c9c47d837ba5e0298ffc12">IR_TX_FIFO_SIZE</a>;</div><div class="line"></div><div class="line"><span class="comment">/* Enable IR threshold interrupt. when TX FIFO offset &lt;= threshold value, trigger interrupt*/</span></div><div class="line"><a class="code" href="group___i_r___exported___functions.html#ga3ca7c9e503d98d65e01cf27428bda385">IR_INTConfig</a>(<a class="code" href="group___i_r___interrupts___definition.html#ga8b4c235c4e2de1ec5b1628a3b55ae7d4">IR_INT_TF_LEVEL</a>, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line"></div><div class="line"><span class="comment">/* Must fill TX FIFO first */</span></div><div class="line"><a class="code" href="group___i_r___exported___functions.html#gaa35fd88ec9b71d495943f18684e282ea">IR_Cmd</a>(<a class="code" href="group___i_r___mode.html#ga5acc9c2dbf5114f93857996feaeba701">IR_MODE_TX</a>, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div></div><!-- fragment --><h4><a class="anchor" id="IR_TX_Interrupt_Handle_Flow"></a>
11.5.3  IR Interrupt Handle Flow</h4>
<p>IR interrupt handle flow is shown in Figure 11-7.</p>
<div class="image">
<img src="IR_send_flow_in_interrupt_handler.jpg" alt="IR_send_flow_in_interrupt_handler.jpg"/>
</div>
 <center><div id="figure_11_7"><b>Figure 11-7 IR Interrupt Handle Flow Chart</b></div></center><div style="page-break-after: always;"></div><p>The codes below show IR interrupt handle flow. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> ir_handler(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* Continue to send by interrupt */</span></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group___i_r___exported___functions.html#ga48cc1b5be366b891292535718d9d5073">IR_GetINTStatus</a>(<a class="code" href="group___i_r___interrupts___definition.html#ga8b4c235c4e2de1ec5b1628a3b55ae7d4">IR_INT_TF_LEVEL</a>) == <a class="code" href="group__x3e___r_t_l876x___exported__types.html#gga89136caac2e14c55151f527ac02daaffab44c8101cc294c074709ec1b14211792">SET</a>)</div><div class="line">    {</div><div class="line">        <a class="code" href="group___i_r___exported___functions.html#ga742c175219d9579d4df6f7a1fc269676">IR_MaskINTConfig</a>(<a class="code" href="group___i_r___interrupts___definition.html#ga8b4c235c4e2de1ec5b1628a3b55ae7d4">IR_INT_TF_LEVEL</a>, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line">        <span class="comment">/* The remaining data is larger than the TX FIFO length */</span></div><div class="line">        <span class="keywordflow">if</span> ((NEC_LENGTH - tx_count) &gt;= <a class="code" href="group___i_r___exported___constants.html#ga25a8d10b69c9c47d837ba5e0298ffc12">IR_TX_FIFO_SIZE</a>)</div><div class="line">        {</div><div class="line">            <a class="code" href="group___i_r___exported___functions.html#gab24d44506e374ce140c23092c1f6cbff">IR_SendBuf</a>(IR_DataStruct.irBuf + tx_count, (<a class="code" href="group___i_r___exported___constants.html#ga25a8d10b69c9c47d837ba5e0298ffc12">IR_TX_FIFO_SIZE</a> - IR_TX_FIFO_THR_LEVEL), <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1ad3a9df141be0ccf10389b640f492b26d">DISABLE</a>);</div><div class="line">            tx_count += (<a class="code" href="group___i_r___exported___constants.html#ga25a8d10b69c9c47d837ba5e0298ffc12">IR_TX_FIFO_SIZE</a> - IR_TX_FIFO_THR_LEVEL);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((NEC_LENGTH - tx_count) &gt; 0)</div><div class="line">        {</div><div class="line">            <span class="comment">/* The remaining data is less than the TX FIFO length */</span></div><div class="line"></div><div class="line">            <span class="comment">/*  Configure TX threshold level to zero and trigger interrupt when TX FIFO is empty */</span></div><div class="line">            <a class="code" href="group___i_r___exported___functions.html#ga1a73def354b85412d7986856a4443ab4">IR_SetTxThreshold</a>(0);</div><div class="line">            <a class="code" href="group___i_r___exported___functions.html#gab24d44506e374ce140c23092c1f6cbff">IR_SendBuf</a>(IR_DataStruct.irBuf + tx_count, NEC_LENGTH - tx_count, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line">            tx_count += (NEC_LENGTH - tx_count);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">            <span class="comment">/* Tx completed */</span></div><div class="line">            uint8_t <span class="keyword">event</span> = IO_DEMO_EVENT_IR_TX;</div><div class="line">            <span class="comment">/* Disable IR tx empty interrupt */</span></div><div class="line">            <a class="code" href="group___i_r___exported___functions.html#ga3ca7c9e503d98d65e01cf27428bda385">IR_INTConfig</a>(<a class="code" href="group___i_r___interrupts___definition.html#ga8b4c235c4e2de1ec5b1628a3b55ae7d4">IR_INT_TF_LEVEL</a>, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1ad3a9df141be0ccf10389b640f492b26d">DISABLE</a>);</div><div class="line">            tx_count = 0;</div><div class="line">            <span class="keywordflow">if</span> (<a class="code" href="group___o_s__87x3d___message.html#gaaa510b44bebf45ba68bd83820dfc6456">os_msg_send</a>(<a class="code" href="group___p_e_r_i_p_h___a_p_p___t_a_s_k.html#gab16d5e105b1c246220eda8b551cdeb67">io_queue_handle</a>, &amp;event, 0) == <span class="keyword">false</span>)</div><div class="line">            {</div><div class="line">                IO_PRINT_ERROR0(<span class="stringliteral">&quot;ir_handler: Send queue error&quot;</span>);</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">/* Clear threshold interrupt */</span></div><div class="line">        <a class="code" href="group___i_r___exported___functions.html#ga589dc6b6d731bd90a5dea2b3fd0f5462">IR_ClearINTPendingBit</a>(<a class="code" href="group___i_r___interrupts___clear___flag.html#gaabf63847425c7507bc24b123251751de">IR_INT_TF_LEVEL_CLR</a>);</div><div class="line">        <span class="comment">/* Unmask IR interrupt */</span></div><div class="line">        <a class="code" href="group___i_r___exported___functions.html#ga742c175219d9579d4df6f7a1fc269676">IR_MaskINTConfig</a>(<a class="code" href="group___i_r___interrupts___definition.html#ga8b4c235c4e2de1ec5b1628a3b55ae7d4">IR_INT_TF_LEVEL</a>, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1ad3a9df141be0ccf10389b640f492b26d">DISABLE</a>);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="IR_RX_Operation_Flow"></a>
11.6  Receive Data Operation Flow</h3>
<h4><a class="anchor" id="IR_RX_Initialization_Flow"></a>
11.6.1  IR Initialization Flow</h4>
<p>IR initialization flow is shown in Figure 11-8.</p>
<div style="page-break-after: always;"></div><div class="image">
<img src="IR_Initialization_Flow_Chart_2.jpg" alt="IR_Initialization_Flow_Chart_2.jpg"/>
</div>
 <center><div id="figure_11_8"><b>Figure 11-8 IR Initialization Flow Chart</b></div></center><div style="page-break-after: always;"></div><p>The codes below show IR initialization operation flow. </p><div class="fragment"><div class="line"><span class="comment">/* Enable IR clock */</span></div><div class="line"><a class="code" href="group__x3e___r_c_c___exported___functions.html#ga0ff78e34dcddb1ed9a215ee66ccb2d1b">RCC_PeriphClockCmd</a>(<a class="code" href="group___a_p_b___peripheral___define.html#ga3f923565574d0287bc5ecb7205c54202">APBPeriph_IR</a>, <a class="code" href="group___r_c_c___peripheral___clock.html#ga091ed613a522f265331710a8a132e7d0">APBPeriph_IR_CLOCK</a>, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line"></div><div class="line"><span class="comment">/* Initialize IR */</span></div><div class="line"><a class="code" href="struct_i_r___init_type_def.html">IR_InitTypeDef</a> IR_InitStruct;</div><div class="line"><a class="code" href="group___i_r___exported___functions.html#gaeb4d63c4b589f27b0d4078d709d5a720">IR_StructInit</a>(&amp;IR_InitStruct);</div><div class="line"></div><div class="line">IR_InitStruct.<a class="code" href="struct_i_r___init_type_def.html#a8968c93e28cbccf581075933327180cc">IR_Freq</a>               = 38;<span class="comment">/* IR carrier freqency is 38KHz */</span></div><div class="line">IR_InitStruct.<a class="code" href="struct_i_r___init_type_def.html#a502f637a541e47e550a7c3a45054646b">IR_DutyCycle</a>          = 2;<span class="comment">/* Duty ratio = 1/IR_DutyCycle */</span></div><div class="line">IR_InitStruct.<a class="code" href="struct_i_r___init_type_def.html#a01fe3780fbd7c70b50b6fe508317a63a">IR_Mode</a>               = <a class="code" href="group___i_r___mode.html#gad89153d65178210e6a2c81c85eb6759f">IR_MODE_RX</a>;<span class="comment">/* IR receiving mode */</span></div><div class="line">IR_InitStruct.<a class="code" href="struct_i_r___init_type_def.html#acf9abb125c368d4f13e352ee1239dd5e">IR_RxStartMode</a>        = <a class="code" href="group___i_r___rx___start___mode.html#ga69aceeb62d279fa0fa88f95818c58700">IR_RX_AUTO_MODE</a>;</div><div class="line">IR_InitStruct.<a class="code" href="struct_i_r___init_type_def.html#a85744548dc0d702b43593783e1e5cf88">IR_RxFIFOThrLevel</a>     = IR_RX_FIFO_THR_LEVEL; <span class="comment">/* Configure RX FIFO threshold level to trigger IR_INT_RF_LEVEL interrupt */</span></div><div class="line">IR_InitStruct.<a class="code" href="struct_i_r___init_type_def.html#a93e43986d305553ae61a4f4fcd33d147">IR_RxFIFOFullCtrl</a>     = <a class="code" href="group___i_r___r_x___f_i_f_o___d_i_s_c_a_r_d___s_e_t_t_i_n_g.html#gab7ba23ee15c6e10ff40a0eec63ec7129">IR_RX_FIFO_FULL_DISCARD_NEWEST</a>;<span class="comment">/* Discard the lastest received data if RX FIFO is full */</span></div><div class="line">IR_InitStruct.<a class="code" href="struct_i_r___init_type_def.html#a264a2869fa42d5a851b1cebc5ddf1608">IR_RxTriggerMode</a>      = <a class="code" href="group___i_r___r_x___trigger___mode.html#ga01b74c9bf80e3a8f629d91c6e653d693">IR_RX_RISING_EDGE</a>;<span class="comment">/* Configure trigger type */</span></div><div class="line">IR_InitStruct.<a class="code" href="struct_i_r___init_type_def.html#a13cc0d3374b4ff6e359665fed0f15747">IR_RxFilterTime</a>       = <a class="code" href="group___i_r___r_x___filter___time.html#ga9df98a0d996f3c9e85cfba3b66795326">IR_RX_FILTER_TIME_50ns</a>;<span class="comment">/* If high to low or low to high transition time &lt;= 50ns, Filter out it. */</span></div><div class="line">IR_InitStruct.<a class="code" href="struct_i_r___init_type_def.html#a80ca54dd5bbeb693e12a4e70d7ff2ef1">IR_RxCntThrType</a>       = <a class="code" href="group___i_r___r_x___c_o_u_n_t_e_r___t_h_r_e_s_h_o_l_d___t_y_p_e.html#ga3db4c6a315a4f417a95592a956df8383">IR_RX_Count_Low_Level</a>;<span class="comment">/* IR_RX_Count_Low_Level is counting low level */</span></div><div class="line">IR_InitStruct.<a class="code" href="struct_i_r___init_type_def.html#a989ff2d6754765d5d647a0d10176e198">IR_RxCntThr</a>           = 0x23a;<span class="comment">/* Configure RX counter threshold. You can use it to decide to stop receiving IR data */</span></div><div class="line"><a class="code" href="group___i_r___exported___functions.html#gaf6abc176153d12a5d09f89896492f230">IR_Init</a>(&amp;IR_InitStruct);</div><div class="line"></div><div class="line"><span class="comment">/* Enable IR threshold interrupt. when RX FIFO offset &gt;= threshold value, trigger interrupt*/</span></div><div class="line"><span class="comment">/* Enable IR counter threshold interrupt to stop receiving data */</span></div><div class="line"><a class="code" href="group___i_r___exported___functions.html#ga3ca7c9e503d98d65e01cf27428bda385">IR_INTConfig</a>(<a class="code" href="group___i_r___interrupts___definition.html#gad5bdf868b14f494160c5bbb3ed59ba90">IR_INT_RF_LEVEL</a> | <a class="code" href="group___i_r___interrupts___definition.html#ga9107e9107205ee7714c76320f631a2b3">IR_INT_RX_CNT_THR</a>, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line"><a class="code" href="group___i_r___exported___functions.html#ga742c175219d9579d4df6f7a1fc269676">IR_MaskINTConfig</a>(<a class="code" href="group___i_r___interrupts___definition.html#gad5bdf868b14f494160c5bbb3ed59ba90">IR_INT_RF_LEVEL</a> | <a class="code" href="group___i_r___interrupts___definition.html#ga9107e9107205ee7714c76320f631a2b3">IR_INT_RX_CNT_THR</a>, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1ad3a9df141be0ccf10389b640f492b26d">DISABLE</a>);</div><div class="line"></div><div class="line"><span class="comment">/* Configure NVIC */</span></div><div class="line"><a class="code" href="struct_n_v_i_c___init_type_def.html">NVIC_InitTypeDef</a> NVIC_InitStruct;</div><div class="line">NVIC_InitStruct.<a class="code" href="struct_n_v_i_c___init_type_def.html#a921af0ab04e071d7d276c003e0048123">NVIC_IRQChannel</a> = <a class="code" href="group__x3e___r_t_l876x___exported__types.html#gga666eb0caeb12ec0e281415592ae89083abeeba60b6f454bd82431ed946d20c4f6">IR_IRQn</a>;</div><div class="line">NVIC_InitStruct.<a class="code" href="struct_n_v_i_c___init_type_def.html#acd582bc2edce30e9d7ab5e0ede400f36">NVIC_IRQChannelPriority</a> = 2;</div><div class="line">NVIC_InitStruct.<a class="code" href="struct_n_v_i_c___init_type_def.html#a3c5567ef024a0489884083c88f17b4d5">NVIC_IRQChannelCmd</a> = <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>;</div><div class="line"><a class="code" href="group__x3e___n_v_i_c___exported___functions.html#ga4e06b4f5c9109d6bc8990adf77e5f8d3">NVIC_Init</a>(&amp;NVIC_InitStruct);</div><div class="line"></div><div class="line"><a class="code" href="group___i_r___exported___functions.html#ga3ed11706a9eda2ff8550f51fb62670b0">IR_ClearRxFIFO</a>();</div><div class="line"><a class="code" href="group___i_r___exported___functions.html#gaa35fd88ec9b71d495943f18684e282ea">IR_Cmd</a>(<a class="code" href="group___i_r___mode.html#gad89153d65178210e6a2c81c85eb6759f">IR_MODE_RX</a>, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div></div><!-- fragment --><h4><a class="anchor" id="IR_Receive_Data_Operation_Flow"></a>
11.6.2  IR Receive Data Operation Flow</h4>
<p>IR receive data operation flow is shown in Figure 11-9.</p>
<div class="image">
<img src="IR_Receive_Data_Operation_Flow_Chart.jpg" alt="IR_Receive_Data_Operation_Flow_Chart.jpg"/>
</div>
 <center><div id="figure_11_9"><b>Figure 11-9 IR Receive Data Operation Flow Chart</b></div></center><p>The codes below show IR receives data operation flow. </p><div class="fragment"><div class="line"><span class="comment">/* Wait for receiving the whole IR packets */</span></div><div class="line"><span class="comment">/* This is just a demo. You can send message from IR interrupt handler */</span></div><div class="line"><span class="keywordflow">while</span> (rx_count &lt;= NEC_LENGTH - 5) {;};</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (IR_SUCCEED != IR_NECDecode(38, &amp;address, &amp;cmd, &amp;IR_DataStruct))</div><div class="line">{</div><div class="line">    <span class="comment">// Decoding error!</span></div><div class="line">}</div><div class="line"><span class="keywordflow">else</span></div><div class="line">{</div><div class="line">    <span class="comment">// Decoding success!</span></div><div class="line">}</div></div><!-- fragment --><h4><a class="anchor" id="IR_RX_Interrupt_Handle_Flow"></a>
11.6.3  IR Interrupt Handle Flow</h4>
<p>IR interrupt handle flow is shown in Figure 11-10.</p>
<div class="image">
<img src="IR_receive_flow_in_interrupt_handler.jpg" alt="IR_receive_flow_in_interrupt_handler.jpg"/>
</div>
 <center><div id="figure_11_10"><b>Figure 11-10 IR Interrupt Handle Flow Chart</b></div></center><p>The codes below show IR interrupt handle flow. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> ir_handler(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    uint16_t len = 0;</div><div class="line"></div><div class="line">    <span class="comment">/* Receive by interrupt */</span></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group___i_r___exported___functions.html#ga48cc1b5be366b891292535718d9d5073">IR_GetINTStatus</a>(<a class="code" href="group___i_r___interrupts___definition.html#gad5bdf868b14f494160c5bbb3ed59ba90">IR_INT_RF_LEVEL</a>) == <a class="code" href="group__x3e___r_t_l876x___exported__types.html#gga89136caac2e14c55151f527ac02daaffab44c8101cc294c074709ec1b14211792">SET</a>)</div><div class="line">    {</div><div class="line">        <a class="code" href="group___i_r___exported___functions.html#ga742c175219d9579d4df6f7a1fc269676">IR_MaskINTConfig</a>(<a class="code" href="group___i_r___interrupts___definition.html#gad5bdf868b14f494160c5bbb3ed59ba90">IR_INT_RF_LEVEL</a>, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line">        len = <a class="code" href="group___i_r___exported___functions.html#ga0632c0b6b1937f01016c876327a9eed6">IR_GetRxDataLen</a>();</div><div class="line">        <a class="code" href="group___i_r___exported___functions.html#ga57e8062508f0d96187fd0f404f94fcb7">IR_ReceiveBuf</a>(IR_DataStruct.irBuf + rx_count, len);</div><div class="line">        IR_DataStruct.bufLen += len;</div><div class="line">        rx_count += len;</div><div class="line">        <a class="code" href="group___i_r___exported___functions.html#ga589dc6b6d731bd90a5dea2b3fd0f5462">IR_ClearINTPendingBit</a>(<a class="code" href="group___i_r___interrupts___clear___flag.html#ga4c33e926c4f0a286649932c550fd136b">IR_INT_RF_LEVEL_CLR</a>);</div><div class="line">        <a class="code" href="group___i_r___exported___functions.html#ga742c175219d9579d4df6f7a1fc269676">IR_MaskINTConfig</a>(<a class="code" href="group___i_r___interrupts___definition.html#gad5bdf868b14f494160c5bbb3ed59ba90">IR_INT_RF_LEVEL</a>, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1ad3a9df141be0ccf10389b640f492b26d">DISABLE</a>);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Stop to receive IR data */</span></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group___i_r___exported___functions.html#ga48cc1b5be366b891292535718d9d5073">IR_GetINTStatus</a>(<a class="code" href="group___i_r___interrupts___definition.html#ga9107e9107205ee7714c76320f631a2b3">IR_INT_RX_CNT_THR</a>) == <a class="code" href="group__x3e___r_t_l876x___exported__types.html#gga89136caac2e14c55151f527ac02daaffab44c8101cc294c074709ec1b14211792">SET</a>)</div><div class="line">    {</div><div class="line">        <a class="code" href="group___i_r___exported___functions.html#ga742c175219d9579d4df6f7a1fc269676">IR_MaskINTConfig</a>(<a class="code" href="group___i_r___interrupts___definition.html#ga9107e9107205ee7714c76320f631a2b3">IR_INT_RX_CNT_THR</a>, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line">        <span class="comment">/* Read remaining data */</span></div><div class="line">        len = <a class="code" href="group___i_r___exported___functions.html#ga0632c0b6b1937f01016c876327a9eed6">IR_GetRxDataLen</a>();</div><div class="line">        <a class="code" href="group___i_r___exported___functions.html#ga57e8062508f0d96187fd0f404f94fcb7">IR_ReceiveBuf</a>(IR_DataStruct.irBuf + rx_count, len);</div><div class="line">        IR_DataStruct.bufLen += len;</div><div class="line">        rx_count += len;</div><div class="line">        <a class="code" href="group___i_r___exported___functions.html#ga589dc6b6d731bd90a5dea2b3fd0f5462">IR_ClearINTPendingBit</a>(<a class="code" href="group___i_r___interrupts___clear___flag.html#ga62fc79f04b86125728bf6f8acfe9bd5e">IR_INT_RX_CNT_THR_CLR</a>);</div><div class="line">        <a class="code" href="group___i_r___exported___functions.html#ga742c175219d9579d4df6f7a1fc269676">IR_MaskINTConfig</a>(<a class="code" href="group___i_r___interrupts___definition.html#ga9107e9107205ee7714c76320f631a2b3">IR_INT_RX_CNT_THR</a>, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1ad3a9df141be0ccf10389b640f492b26d">DISABLE</a>);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><div style="page-break-after: always;"></div><h2><a class="anchor" id="RTC"></a>
12  RTC</h2>
<h3><a class="anchor" id="RTC_Demo_Code_Support_List"></a>
12.1 RTC Demo Code Support List</h3>
<center><div id="table_12_1"><b>Table 12-1 RTC Sample Code 1 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 1  </th><th class="markdownTableHeadNone">rtc_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:180px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:670px">Demonstrate RTC comparator function.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\rtc\comparator\rtc_demo.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">rtc_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">Print string "rtc_handler" in DebugAnalyzer every 1536ms.   </td></tr>
</table>
<center><div id="table_12_2"><b>Table 12-2 RTC Sample Code 2 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 2  </th><th class="markdownTableHeadNone">rtc_overflow_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:180px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:670px">Demonstrate RTC count overflow function.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\rtc\overflow\rtc_overflow_demo.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">rtc_overflow_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">For RTL87X3D, rtc_handler function is executed everry 134217.728s. For <br />
RTL87X3E, rtc_handler function is executed everry 524.288s.   </td></tr>
</table>
<center><div id="table_12_3"><b>Table 12-3 RTC Sample Code 3 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 3  </th><th class="markdownTableHeadNone">rtc_tick_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:180px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:670px">Demonstrate RTC tick function.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\rtc\tick\rtc_tick_demo.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">rtc_tick_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">rtc_handler function is executed everry 31.25us.   </td></tr>
</table>
<center><div id="table_12_4"><b>Table 12-4 RTC Sample Code 4 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 4  </th><th class="markdownTableHeadNone">rtc_clock_demo.c<br />
rtc_clock_demo.h   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:180px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:670px">Demonstrate RTC calendar functionality.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\rtc\clock\rtc_clock_demo.c<br />
sdk\src\sample\io_demo\rtc\clock\rtc_clock_demo.h   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">rtc_clock_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">1. Press RESET on the EVB, string <br />
"rtc_clock_sys_update: year 2022, month 9, day 29, hour 0, minute 1, second 0" <br />
will be printed in DebugAnalyzer.<br />
2. Print the time information log in DebugAnalyzer every one minute.   </td></tr>
</table>
<div style="page-break-after: always;"></div><center><div id="table_12_5"><b>Table 12-5 RTC Sample Code 5 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 5  </th><th class="markdownTableHeadNone">rtc_in_power_down_mode.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:180px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:670px">Demonstrate RTC work in power down mode.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\rtc\power_down\rtc_in_power_down_mode.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">rtc_in_power_down_mode()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">1. When system is in idle state, it will enter power down mode automatically and <br />
print string "app_dlps_enter_callback: 10 sec" in DebugAnalyzer.<br />
2. After 10 seconds, the system wakes up and prints string <br />
"rtc_handler: RTC_INT_CMP0" and string "rtc_handler: RTC_INT_CMP_1" <br />
in DebugAnalyzer.   </td></tr>
</table>
<h3><a class="anchor" id="RTC_Function_Description"></a>
12.2  Function Description</h3>
<p>Real-time clock (RTC) is an independent timer. RTC has a set of continuous counting counters to provide a calendar clock. It can be converted into the current time and date of the system by querying the counter value.</p>
<h3><a class="anchor" id="RTC_Feature_List"></a>
12.3  Feature List</h3>
<ul>
<li>32KHz clock source</li>
<li>24-bit read-only counter(RTL87X3E and RTL87X3G), 32-bit read-only counter(RTL87X3D)</li>
<li>12-bit prescaler</li>
<li>Support 4 comparator interrupts</li>
<li>Support overflow interrupt, indicating that the counter overflows and wraps around to 0</li>
<li>Support tick interrupt</li>
<li>Support wake-up system from low power mode</li>
<li>Support 8 comparators</li>
<li>4 comparators can only be used to trigger wake-up</li>
<li>4 comparators can be used to trigger wake-up and CPU NVIC</li>
</ul>
<h3><a class="anchor" id="RTC_Comparator_Function_Operation_Flow"></a>
12.4  Comparator Function Operation Flow</h3>
<p>RTC comparator function initialization flow is shown in Figure 12-1.</p>
<div class="image">
<img src="RTC_Comparator_Function_Initialization_Flow_Chart.jpg" alt="RTC_Comparator_Function_Initialization_Flow_Chart.jpg"/>
</div>
 <center><div id="figure_12_1"><b>Figure 12-1 RTC Comparator Function Initialization Flow Chart</b></div></center><p>The codes below show RTC comparator function initialization flow. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> driver_rtc_init(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_t_c___exported___functions.html#gaff0c9fef0c90de5f25dc02b7ec887d63">RTC_DeInit</a>();</div><div class="line">    <a class="code" href="group___r_t_c___exported___functions.html#ga78305b1b2fb01763cfe349e38d1b9043">RTC_SetPrescaler</a>(RTC_PRESCALER_VALUE);</div><div class="line">    <a class="code" href="group___r_t_c___exported___functions.html#gaf2396e690da70f435c48e74c005513a5">RTC_SetComp</a>(RTC_COMP_INDEX, RTC_COMP_VALUE);</div><div class="line">    <a class="code" href="group___r_t_c___exported___functions.html#ga1d2c4f816a09a508d122b0f99ae05cce">RTC_MaskINTConfig</a>(RTC_INT_CMP_1, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1ad3a9df141be0ccf10389b640f492b26d">DISABLE</a>);</div><div class="line">    <a class="code" href="group___r_t_c___exported___functions.html#ga0fdb7d1c0de66186948dc0ad29559b97">RTC_CompINTConfig</a>(RTC_INT_CMP_1, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line">    <a class="code" href="group___h_a_l___vector_table.html#ga1ddcc6c785e2655f5de7b7edf1f4302d">RamVectorTableUpdate</a>(RTC_VECTORn, RTC_Handler);</div><div class="line"></div><div class="line">    <span class="comment">/* Config RTC interrupt */</span></div><div class="line">    <a class="code" href="struct_n_v_i_c___init_type_def.html">NVIC_InitTypeDef</a> NVIC_InitStruct;</div><div class="line">    NVIC_InitStruct.<a class="code" href="struct_n_v_i_c___init_type_def.html#a921af0ab04e071d7d276c003e0048123">NVIC_IRQChannel</a> = <a class="code" href="group__x3e___r_t_l876x___exported__types.html#gga666eb0caeb12ec0e281415592ae89083adcc0f2770f7f57f75fac3d8bcac0e858">RTC_IRQn</a>;</div><div class="line">    NVIC_InitStruct.<a class="code" href="struct_n_v_i_c___init_type_def.html#acd582bc2edce30e9d7ab5e0ede400f36">NVIC_IRQChannelPriority</a> = 3;</div><div class="line">    NVIC_InitStruct.<a class="code" href="struct_n_v_i_c___init_type_def.html#a3c5567ef024a0489884083c88f17b4d5">NVIC_IRQChannelCmd</a> = <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>;</div><div class="line">    <a class="code" href="group__x3e___n_v_i_c___exported___functions.html#ga4e06b4f5c9109d6bc8990adf77e5f8d3">NVIC_Init</a>(&amp;NVIC_InitStruct);</div><div class="line"></div><div class="line">    <span class="comment">/* Start RTC */</span></div><div class="line">    <a class="code" href="group___r_t_c___exported___functions.html#gad05087f04a4a19207bc0ff1e719fae14">RTC_SystemWakeupConfig</a>(<a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line">    <a class="code" href="group___r_t_c___exported___functions.html#gab167a070c253189cfe88a3f6934e64ae">RTC_RunCmd</a>(<a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line">}</div></div><!-- fragment --><p>RTC interrupt handle flow is shown in Figure 12-2.</p>
<div class="image">
<img src="RTC_Interrupt_Handle_Flow_Chart_1.jpg" alt="RTC_Interrupt_Handle_Flow_Chart_1.jpg"/>
</div>
 <center><div id="figure_12_2"><b>Figure 12-2 RTC Interrupt Handle Flow Chart</b></div></center><div style="page-break-after: always;"></div><p>The codes below show RTC interrupt handle flow. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> rtc_handler(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    IO_PRINT_TRACE0(<span class="stringliteral">&quot;rtc_handler&quot;</span>);</div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group___r_t_c___exported___functions.html#gaf0882e8e9c8976e95425cc26fa76ea9b">RTC_GetINTStatus</a>(RTC_INT_CMP_1) == <a class="code" href="group__x3e___r_t_l876x___exported__types.html#gga89136caac2e14c55151f527ac02daaffab44c8101cc294c074709ec1b14211792">SET</a>)</div><div class="line">    {</div><div class="line">        <a class="code" href="group___r_t_c___exported___functions.html#gaf2396e690da70f435c48e74c005513a5">RTC_SetComp</a>(RTC_COMP_INDEX, <a class="code" href="group___r_t_c___exported___functions.html#gacffdea3ecb76d14da83dddcbae5aca6c">RTC_GetCounter</a>() + RTC_COMP_VALUE);</div><div class="line">        <a class="code" href="group___r_t_c___exported___functions.html#ga2730fcc0fcdf69931dc74afde0eeadd9">RTC_ClearCompINT</a>(RTC_COMP_INDEX);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="RTC_Overflow_Function_Operation_Flow"></a>
12.5  Overflow Function Operation Flow</h3>
<p>RTC overflow function initialization flow is shown in Figure 12-3.</p>
<div class="image">
<img src="RTC_Overflow_Function_Initialization_Flow_Chart.jpg" alt="RTC_Overflow_Function_Initialization_Flow_Chart.jpg"/>
</div>
 <center><div id="figure_12_3"><b>Figure 12-3 RTC Overflow Function Initialization Flow Chart</b></div></center><div style="page-break-after: always;"></div><p>The codes below show RTC overflow function initialization flow. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> driver_rtc_init(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_t_c___exported___functions.html#gaff0c9fef0c90de5f25dc02b7ec887d63">RTC_DeInit</a>();</div><div class="line">    <a class="code" href="group___r_t_c___exported___functions.html#ga78305b1b2fb01763cfe349e38d1b9043">RTC_SetPrescaler</a>(RTC_PRESCALER_VALUE);</div><div class="line">    <a class="code" href="group___r_t_c___exported___functions.html#ga1d2c4f816a09a508d122b0f99ae05cce">RTC_MaskINTConfig</a>(RTC_INT_OVF, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1ad3a9df141be0ccf10389b640f492b26d">DISABLE</a>);</div><div class="line"></div><div class="line">    <span class="comment">/* Config RTC interrupt */</span></div><div class="line">    <a class="code" href="struct_n_v_i_c___init_type_def.html">NVIC_InitTypeDef</a> NVIC_InitStruct;</div><div class="line">    NVIC_InitStruct.<a class="code" href="struct_n_v_i_c___init_type_def.html#a921af0ab04e071d7d276c003e0048123">NVIC_IRQChannel</a> = <a class="code" href="group__x3e___r_t_l876x___exported__types.html#gga666eb0caeb12ec0e281415592ae89083adcc0f2770f7f57f75fac3d8bcac0e858">RTC_IRQn</a>;</div><div class="line">    NVIC_InitStruct.<a class="code" href="struct_n_v_i_c___init_type_def.html#acd582bc2edce30e9d7ab5e0ede400f36">NVIC_IRQChannelPriority</a> = 2;</div><div class="line">    NVIC_InitStruct.<a class="code" href="struct_n_v_i_c___init_type_def.html#a3c5567ef024a0489884083c88f17b4d5">NVIC_IRQChannelCmd</a> = <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>;</div><div class="line">    <a class="code" href="group__x3e___n_v_i_c___exported___functions.html#ga4e06b4f5c9109d6bc8990adf77e5f8d3">NVIC_Init</a>(&amp;NVIC_InitStruct);</div><div class="line"></div><div class="line">    <span class="comment">/* Start RTC */</span></div><div class="line">    <a class="code" href="group___r_t_c___exported___functions.html#gab167a070c253189cfe88a3f6934e64ae">RTC_RunCmd</a>(<a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line">}</div></div><!-- fragment --><p>RTC interrupt handle flow is shown in Figure 12-4.</p>
<div class="image">
<img src="RTC_Interrupt_Handle_Flow_Chart_2.jpg" alt="RTC_Interrupt_Handle_Flow_Chart_2.jpg"/>
</div>
 <center><div id="figure_12_4"><b>Figure 12-4 RTC Interrupt Handle Flow Chart</b></div></center><div style="page-break-after: always;"></div><p>The codes below show RTC interrupt handle flow. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> rtc_handler(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* RTC overflow interrupt handle */</span></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group___r_t_c___exported___functions.html#gaf0882e8e9c8976e95425cc26fa76ea9b">RTC_GetINTStatus</a>(RTC_INT_OVF) == <a class="code" href="group__x3e___r_t_l876x___exported__types.html#gga89136caac2e14c55151f527ac02daaffab44c8101cc294c074709ec1b14211792">SET</a>)</div><div class="line">    {</div><div class="line">        <span class="comment">// Add application code here</span></div><div class="line"></div><div class="line">        <a class="code" href="group___r_t_c___exported___functions.html#gaf6e85a704956ae5d88379c5b97708f06">RTC_ClearOverFlowINT</a>();</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="RTC_Tick_Function_Operation_Flow"></a>
12.6  Tick Function Operation Flow</h3>
<p>RTC tick function initialization flow is shown in Figure 12-5.</p>
<div class="image">
<img src="RTC_Tick_Function_Initialization_Flow_Chart.jpg" alt="RTC_Tick_Function_Initialization_Flow_Chart.jpg"/>
</div>
 <center><div id="figure_12_5"><b>Figure 12-5 RTC Tick Function Initialization Flow Chart</b></div></center><p>The codes below show RTC tick function initialization flow. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> driver_rtc_init(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_t_c___exported___functions.html#gaff0c9fef0c90de5f25dc02b7ec887d63">RTC_DeInit</a>();</div><div class="line">    <a class="code" href="group___r_t_c___exported___functions.html#ga78305b1b2fb01763cfe349e38d1b9043">RTC_SetPrescaler</a>(RTC_PRESCALER_VALUE);</div><div class="line">    <a class="code" href="group___r_t_c___exported___functions.html#ga1d2c4f816a09a508d122b0f99ae05cce">RTC_MaskINTConfig</a>(RTC_INT_TICK, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1ad3a9df141be0ccf10389b640f492b26d">DISABLE</a>);</div><div class="line">    <a class="code" href="group___r_t_c___exported___functions.html#ga88ee89f0f5af07acc4cea9c7be814ee8">RTC_TickINTConfig</a>(<a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line"></div><div class="line">    <span class="comment">/* Config RTC interrupt */</span></div><div class="line">    <a class="code" href="struct_n_v_i_c___init_type_def.html">NVIC_InitTypeDef</a> NVIC_InitStruct;</div><div class="line">    NVIC_InitStruct.<a class="code" href="struct_n_v_i_c___init_type_def.html#a921af0ab04e071d7d276c003e0048123">NVIC_IRQChannel</a> = <a class="code" href="group__x3e___r_t_l876x___exported__types.html#gga666eb0caeb12ec0e281415592ae89083adcc0f2770f7f57f75fac3d8bcac0e858">RTC_IRQn</a>;</div><div class="line">    NVIC_InitStruct.<a class="code" href="struct_n_v_i_c___init_type_def.html#acd582bc2edce30e9d7ab5e0ede400f36">NVIC_IRQChannelPriority</a> = 2;</div><div class="line">    NVIC_InitStruct.<a class="code" href="struct_n_v_i_c___init_type_def.html#a3c5567ef024a0489884083c88f17b4d5">NVIC_IRQChannelCmd</a> = <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>;</div><div class="line">    <a class="code" href="group__x3e___n_v_i_c___exported___functions.html#ga4e06b4f5c9109d6bc8990adf77e5f8d3">NVIC_Init</a>(&amp;NVIC_InitStruct);</div><div class="line"></div><div class="line">    <span class="comment">/* Start RTC */</span></div><div class="line">    <a class="code" href="group___r_t_c___exported___functions.html#gab167a070c253189cfe88a3f6934e64ae">RTC_RunCmd</a>(<a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line">}</div></div><!-- fragment --><p>RTC interrupt handle flow is shown in Figure 12-6.</p>
<div class="image">
<img src="RTC_Interrupt_Handle_Flow_Chart_3.jpg" alt="RTC_Interrupt_Handle_Flow_Chart_3.jpg"/>
</div>
 <center><div id="figure_12_6"><b>Figure 12-6 RTC Interrupt Handle Flow Chart</b></div></center><p>The codes below show RTC interrupt handle flow. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> rtc_handler(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* RTC overflow interrupt handle */</span></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group___r_t_c___exported___functions.html#gaf0882e8e9c8976e95425cc26fa76ea9b">RTC_GetINTStatus</a>(RTC_INT_TICK) == <a class="code" href="group__x3e___r_t_l876x___exported__types.html#gga89136caac2e14c55151f527ac02daaffab44c8101cc294c074709ec1b14211792">SET</a>)</div><div class="line">    {</div><div class="line">        <span class="comment">// Add application code here</span></div><div class="line"></div><div class="line">        <a class="code" href="group___r_t_c___exported___functions.html#gaa7d4dc9db13bd1ee31ce487257524686">RTC_ClearTickINT</a>();</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><div style="page-break-after: always;"></div><h2><a class="anchor" id="LPC"></a>
13  LPC</h2>
<h3><a class="anchor" id="LPC_Demo_Code_Support_List"></a>
13.1 LPC Demo Code Support List</h3>
<center><div id="table_13_1"><b>Table 13-1 LPC Sample Code 1 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 1  </th><th class="markdownTableHeadNone">lpc_comparator_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:180px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:670px">Demonstrate LPC comparator function.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\lpc\comparator\lpc_comparator_demo.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">lpc_comparator_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">Connect M0_0 of EVB to external DC voltage source.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">Adjust DC voltage source repeatedly, when the input voltage on M0_0 is detected to be higher than 400mV for 4 times, string "lpc_rtc_handler: lpc_counter_value 4" <br />
will be printed on DebugAnalyser.   </td></tr>
</table>
<center><div id="table_13_2"><b>Table 13-2 LPC Sample Code 2 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 2  </th><th class="markdownTableHeadNone">lpc_peri_vol_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:180px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:670px">Demonstrate LPC voltage detection function.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\lpc\voltage_detection\lpc_peri_vol_demo.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">lpc_peri_vol_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">Connect M0_0 of EVB to external DC voltage source.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">Adjust DC voltage source, when the input voltage on M0_0 is detected to be lower <br />
than 800mV for 6 times, string "lpc_handler: lpc_counter_value 6" will be printed on DebugAnalyser.   </td></tr>
</table>
<center><div id="table_13_3"><b>Table 13-3 LPC Sample Code 3 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 3  </th><th class="markdownTableHeadNone">lpc_rtc_vol_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:180px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:670px">Demonstrate LPC voltage detection function.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\lpc\voltage_detection\lpc_rtc_vol_demo.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">lpc_rtc_vol_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">Connect M0_0 of EVB to external DC voltage source.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">Adjust DC voltage source, when the input voltage on M0_0 is detected to be higher <br />
than 1200mV for 5 times, string "lpc_rtc_handler: lpc_counter_value 5" <br />
will be printed on DebugAnalyser.   </td></tr>
</table>
<h3><a class="anchor" id="LPC_Function_Description"></a>
13.2  Function Description</h3>
<p>LPC can be used for voltage detection and counting. When the LPC detects that the input voltage exceeds the set voltage threshold, the system will always trigger the LPC interrupt. LPC can be used to count the number of times the input voltage exceeds the set voltage threshold. When the count value exceeds the set value of the comparator, RTC interrupt will be triggered.</p>
<p><b>Note:</b> RTL87X3D and RTL87X3E support LPC, RTL87X3G doesn't support LPC.</p>
<h3><a class="anchor" id="LPC_Comparator_Function_Operation_Flow"></a>
13.3  Comparator Function Operation Flow</h3>
<p>LPC comparator function initialization flow is shown in Figure 13-1.</p>
<div class="image">
<img src="LPC_Comparator_Function_Initialization_Flow_Chart.jpg" alt="LPC_Comparator_Function_Initialization_Flow_Chart.jpg"/>
</div>
 <center><div id="figure_13_1"><b>Figure 13-1 LPC Comparator Function Initialization Flow Chart</b></div></center><p>The codes below show LPC comparator function initialization flow. </p><div class="fragment"><div class="line"><a class="code" href="struct_l_p_c___init_type_def.html">LPC_InitTypeDef</a> LPC_InitStruct;</div><div class="line"><a class="code" href="group___l_p_c___exported___functions.html#gafca43652d85c7605229079444a8ae057">LPC_StructInit</a>(&amp;LPC_InitStruct);</div><div class="line">LPC_InitStruct.<a class="code" href="struct_l_p_c___init_type_def.html#a1b942c80f3a7499ff28e79635fb6f247">LPC_Channel</a>   = LPC_CAPTURE_PIN;</div><div class="line">LPC_InitStruct.<a class="code" href="struct_l_p_c___init_type_def.html#a1514eabc8b8bfd2c718e7a981c5e5bba">LPC_Edge</a>      = <a class="code" href="group___l_p_c___edge.html#ga70820b94fe6f1ed1af1849e25045e4a1">LPC_Vin_Over_Vth</a>;</div><div class="line">LPC_InitStruct.<a class="code" href="struct_l_p_c___init_type_def.html#acd7dc195155b85525d6b112bc00c320c">LPC_Threshold</a> = <a class="code" href="group___l_p_c___threshold.html#gaf48d74f824e8cf19b3b447a55d446068">LPC_400_mV</a>;</div><div class="line"><a class="code" href="group___l_p_c___exported___functions.html#ga584719584a468b8d3a37059fee53558d">LPC_Init</a>(&amp;LPC_InitStruct);</div><div class="line"><a class="code" href="group___l_p_c___exported___functions.html#gace4f0d02ae7ebad93943d2e66fb2e013">LPC_CounterReset</a>();</div><div class="line"><a class="code" href="group___l_p_c___exported___functions.html#ga958f29f61db1ca7ddfe2de9741afe377">LPC_WriteComparator</a>(LPC_COMP_VALUE);</div><div class="line"><a class="code" href="group___l_p_c___exported___functions.html#ga14b459893c76a2aa69e1eff7b9f204d8">LPC_INTConfig</a>(<a class="code" href="group___l_p_c__interrupts__definition.html#ga1cfe472811bbb403051a914f985b1c8d">LPC_INT_COUNT_COMP</a>, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line"><span class="preprocessor">#if (TARGET_RTL8753EFE == 1)</span></div><div class="line"><a class="code" href="group___r_t_c___exported___functions.html#gaef72a569c7f8f541299d0ab008f3d45a">RTC_CpuNVICEnable</a>(<a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line"><a class="code" href="group___h_a_l___vector_table.html#ga1ddcc6c785e2655f5de7b7edf1f4302d">RamVectorTableUpdate</a>(RTC_VECTORn, lpc_rtc_handler);</div><div class="line"><span class="comment">/* Config LPC interrupt */</span></div><div class="line"><a class="code" href="struct_n_v_i_c___init_type_def.html">NVIC_InitTypeDef</a> NVIC_InitStruct;</div><div class="line">NVIC_InitStruct.<a class="code" href="struct_n_v_i_c___init_type_def.html#a921af0ab04e071d7d276c003e0048123">NVIC_IRQChannel</a> = <a class="code" href="group__x3e___r_t_l876x___exported__types.html#gga666eb0caeb12ec0e281415592ae89083adcc0f2770f7f57f75fac3d8bcac0e858">RTC_IRQn</a>;</div><div class="line">NVIC_InitStruct.<a class="code" href="struct_n_v_i_c___init_type_def.html#acd582bc2edce30e9d7ab5e0ede400f36">NVIC_IRQChannelPriority</a> = 3;</div><div class="line">NVIC_InitStruct.<a class="code" href="struct_n_v_i_c___init_type_def.html#a3c5567ef024a0489884083c88f17b4d5">NVIC_IRQChannelCmd</a> = <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>;</div><div class="line"><a class="code" href="group__x3e___n_v_i_c___exported___functions.html#ga4e06b4f5c9109d6bc8990adf77e5f8d3">NVIC_Init</a>(&amp;NVIC_InitStruct);</div><div class="line"><span class="preprocessor">#else</span></div><div class="line"><a class="code" href="group___l_p_c___exported___functions.html#ga14b459893c76a2aa69e1eff7b9f204d8">LPC_INTConfig</a>(<a class="code" href="group___l_p_c__interrupts__definition.html#ga3040081fd6aa23c8c289efc88409f2b6">LPC_INT_VOLTAGE_COMP</a>, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line"><a class="code" href="group___h_a_l___vector_table.html#ga1ddcc6c785e2655f5de7b7edf1f4302d">RamVectorTableUpdate</a>(LPCOMP_VECTORn, lpc_rtc_handler);</div><div class="line"><span class="comment">/* Config LPC interrupt */</span></div><div class="line"><a class="code" href="struct_n_v_i_c___init_type_def.html">NVIC_InitTypeDef</a> NVIC_InitStruct;</div><div class="line">NVIC_InitStruct.<a class="code" href="struct_n_v_i_c___init_type_def.html#a921af0ab04e071d7d276c003e0048123">NVIC_IRQChannel</a> = <a class="code" href="group__x3e___r_t_l876x___exported__types.html#gga666eb0caeb12ec0e281415592ae89083af7f33fa618072c354353e433d357124e">LPCOMP_IRQn</a>;</div><div class="line">NVIC_InitStruct.<a class="code" href="struct_n_v_i_c___init_type_def.html#acd582bc2edce30e9d7ab5e0ede400f36">NVIC_IRQChannelPriority</a> = 3;</div><div class="line">NVIC_InitStruct.<a class="code" href="struct_n_v_i_c___init_type_def.html#a3c5567ef024a0489884083c88f17b4d5">NVIC_IRQChannelCmd</a> = <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>;</div><div class="line"><a class="code" href="group__x3e___n_v_i_c___exported___functions.html#ga4e06b4f5c9109d6bc8990adf77e5f8d3">NVIC_Init</a>(&amp;NVIC_InitStruct);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"><a class="code" href="group___l_p_c___exported___functions.html#ga6b8978c76c4cf135b9cd6ce49004209e">LPC_Cmd</a>(<a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line"><a class="code" href="group___l_p_c___exported___functions.html#ga387c97ae20d3dd7fc346e737e67e04c6">LPC_CounterCmd</a>(<a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div></div><!-- fragment --><p>LPC comparator function interrupt handle flow is shown in Figure 13-2.</p>
<div class="image">
<img src="LPC_Comparator_Function_Interrupt_Handle_Flow_Chart.jpg" alt="LPC_Comparator_Function_Interrupt_Handle_Flow_Chart.jpg"/>
</div>
 <center><div id="figure_13_2"><b>Figure 13-2 LPC Comparator Function Interrupt Handle Flow Chart</b></div></center><p>The codes below show LPC comparator function interrupt handle flow. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> lpc_rtc_handler(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    uint16_t lpc_counter_value = 0;</div><div class="line"></div><div class="line">    IO_PRINT_INFO0(<span class="stringliteral">&quot;lpc_rtc_handler&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">/* LPC counter comparator interrupt */</span></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group___l_p_c___exported___functions.html#gae4943fb5970a780db4e41e4fb725d133">LPC_GetINTStatus</a>(<a class="code" href="group___l_p_c__interrupts__definition.html#ga1cfe472811bbb403051a914f985b1c8d">LPC_INT_COUNT_COMP</a>) == <a class="code" href="group__x3e___r_t_l876x___exported__types.html#gga89136caac2e14c55151f527ac02daaffab44c8101cc294c074709ec1b14211792">SET</a>)</div><div class="line">    {</div><div class="line">        lpc_counter_value = <a class="code" href="group___l_p_c___exported___functions.html#ga314732fd430bc086f7b1a0b0ceb87fcd">LPC_ReadCounter</a>();</div><div class="line">        IO_PRINT_INFO1(<span class="stringliteral">&quot;lpc_rtc_handler: lpc_counter_value %d&quot;</span>, lpc_counter_value);</div><div class="line"></div><div class="line">        <a class="code" href="group___l_p_c___exported___functions.html#ga958f29f61db1ca7ddfe2de9741afe377">LPC_WriteComparator</a>(lpc_counter_value + LPC_COMP_VALUE);</div><div class="line">        <a class="code" href="group___l_p_c___exported___functions.html#ga18a5dae3ccc9068d22c06585f3ba37a0">LPC_ClearINTPendingBit</a>(<a class="code" href="group___l_p_c__interrupts__definition.html#ga1cfe472811bbb403051a914f985b1c8d">LPC_INT_COUNT_COMP</a>);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><div style="page-break-after: always;"></div><h3><a class="anchor" id="LPC_Voltage_Detection_Function_Operation_Flow"></a>
13.4  Voltage Detection Function Operation Flow</h3>
<p>The codes below show LPC voltage detection function initialization flow. </p><div class="fragment"><div class="line"><a class="code" href="struct_l_p_c___init_type_def.html">LPC_InitTypeDef</a> LPC_InitStruct;</div><div class="line"><a class="code" href="group___l_p_c___exported___functions.html#gafca43652d85c7605229079444a8ae057">LPC_StructInit</a>(&amp;LPC_InitStruct);</div><div class="line">LPC_InitStruct.<a class="code" href="struct_l_p_c___init_type_def.html#a1b942c80f3a7499ff28e79635fb6f247">LPC_Channel</a>   = LPC_CAPTURE_PIN;</div><div class="line">LPC_InitStruct.<a class="code" href="struct_l_p_c___init_type_def.html#a1514eabc8b8bfd2c718e7a981c5e5bba">LPC_Edge</a>      = <a class="code" href="group___l_p_c___edge.html#ga55ba90be55188e0197bf83cb9d75a358">LPC_Vin_Below_Vth</a>;</div><div class="line">LPC_InitStruct.<a class="code" href="struct_l_p_c___init_type_def.html#acd7dc195155b85525d6b112bc00c320c">LPC_Threshold</a> = <a class="code" href="group___l_p_c___threshold.html#ga9d34609906973abf76efb3fb93abd64d">LPC_800_mV</a>;</div><div class="line"><a class="code" href="group___l_p_c___exported___functions.html#ga584719584a468b8d3a37059fee53558d">LPC_Init</a>(&amp;LPC_InitStruct);</div><div class="line"></div><div class="line"><a class="code" href="group___l_p_c___exported___functions.html#gace4f0d02ae7ebad93943d2e66fb2e013">LPC_CounterReset</a>();</div><div class="line"><a class="code" href="group___l_p_c___exported___functions.html#ga958f29f61db1ca7ddfe2de9741afe377">LPC_WriteComparator</a>(LPC_COMP_VALUE);</div><div class="line"><a class="code" href="group___l_p_c___exported___functions.html#ga14b459893c76a2aa69e1eff7b9f204d8">LPC_INTConfig</a>(<a class="code" href="group___l_p_c__interrupts__definition.html#ga1cfe472811bbb403051a914f985b1c8d">LPC_INT_COUNT_COMP</a>, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line"></div><div class="line"><span class="preprocessor">#if (TARGET_RTL8753EFE == 1)</span></div><div class="line"><a class="code" href="group___r_t_c___exported___functions.html#gaef72a569c7f8f541299d0ab008f3d45a">RTC_CpuNVICEnable</a>(<a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line"><a class="code" href="group___h_a_l___vector_table.html#ga1ddcc6c785e2655f5de7b7edf1f4302d">RamVectorTableUpdate</a>(RTC_VECTORn, lpc_handler);</div><div class="line"><span class="comment">/* Config LPC interrupt */</span></div><div class="line"><a class="code" href="struct_n_v_i_c___init_type_def.html">NVIC_InitTypeDef</a> NVIC_InitStruct;</div><div class="line">NVIC_InitStruct.<a class="code" href="struct_n_v_i_c___init_type_def.html#a921af0ab04e071d7d276c003e0048123">NVIC_IRQChannel</a> = <a class="code" href="group__x3e___r_t_l876x___exported__types.html#gga666eb0caeb12ec0e281415592ae89083adcc0f2770f7f57f75fac3d8bcac0e858">RTC_IRQn</a>;</div><div class="line">NVIC_InitStruct.<a class="code" href="struct_n_v_i_c___init_type_def.html#acd582bc2edce30e9d7ab5e0ede400f36">NVIC_IRQChannelPriority</a> = 3;</div><div class="line">NVIC_InitStruct.<a class="code" href="struct_n_v_i_c___init_type_def.html#a3c5567ef024a0489884083c88f17b4d5">NVIC_IRQChannelCmd</a> = <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>;</div><div class="line"><a class="code" href="group__x3e___n_v_i_c___exported___functions.html#ga4e06b4f5c9109d6bc8990adf77e5f8d3">NVIC_Init</a>(&amp;NVIC_InitStruct);</div><div class="line"><span class="preprocessor">#else</span></div><div class="line"><a class="code" href="group___l_p_c___exported___functions.html#ga14b459893c76a2aa69e1eff7b9f204d8">LPC_INTConfig</a>(<a class="code" href="group___l_p_c__interrupts__definition.html#ga3040081fd6aa23c8c289efc88409f2b6">LPC_INT_VOLTAGE_COMP</a>, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line"><a class="code" href="group___h_a_l___vector_table.html#ga1ddcc6c785e2655f5de7b7edf1f4302d">RamVectorTableUpdate</a>(LPCOMP_VECTORn, lpc_handler);</div><div class="line"><span class="comment">/* Config LPC interrupt */</span></div><div class="line"><a class="code" href="struct_n_v_i_c___init_type_def.html">NVIC_InitTypeDef</a> NVIC_InitStruct;</div><div class="line">NVIC_InitStruct.<a class="code" href="struct_n_v_i_c___init_type_def.html#a921af0ab04e071d7d276c003e0048123">NVIC_IRQChannel</a> = <a class="code" href="group__x3e___r_t_l876x___exported__types.html#gga666eb0caeb12ec0e281415592ae89083af7f33fa618072c354353e433d357124e">LPCOMP_IRQn</a>;</div><div class="line">NVIC_InitStruct.<a class="code" href="struct_n_v_i_c___init_type_def.html#acd582bc2edce30e9d7ab5e0ede400f36">NVIC_IRQChannelPriority</a> = 3;</div><div class="line">NVIC_InitStruct.<a class="code" href="struct_n_v_i_c___init_type_def.html#a3c5567ef024a0489884083c88f17b4d5">NVIC_IRQChannelCmd</a> = <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>;</div><div class="line"><a class="code" href="group__x3e___n_v_i_c___exported___functions.html#ga4e06b4f5c9109d6bc8990adf77e5f8d3">NVIC_Init</a>(&amp;NVIC_InitStruct);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><a class="code" href="group___l_p_c___exported___functions.html#ga6b8978c76c4cf135b9cd6ce49004209e">LPC_Cmd</a>(<a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line"><a class="code" href="group___l_p_c___exported___functions.html#ga387c97ae20d3dd7fc346e737e67e04c6">LPC_CounterCmd</a>(<a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div></div><!-- fragment --><p>The codes below show LPC voltage detection function interrupt handle flow. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> lpc_handler(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group___l_p_c___exported___functions.html#gae4943fb5970a780db4e41e4fb725d133">LPC_GetINTStatus</a>(<a class="code" href="group___l_p_c__interrupts__definition.html#ga1cfe472811bbb403051a914f985b1c8d">LPC_INT_COUNT_COMP</a>) == <a class="code" href="group__x3e___r_t_l876x___exported__types.html#gga89136caac2e14c55151f527ac02daaffab44c8101cc294c074709ec1b14211792">SET</a>)</div><div class="line">    {</div><div class="line">        IO_PRINT_INFO1(<span class="stringliteral">&quot;lpc_handler: lpc_counter_value %d&quot;</span>, <a class="code" href="group___l_p_c___exported___functions.html#ga314732fd430bc086f7b1a0b0ceb87fcd">LPC_ReadCounter</a>());</div><div class="line">        <a class="code" href="group___l_p_c___exported___functions.html#gace4f0d02ae7ebad93943d2e66fb2e013">LPC_CounterReset</a>();</div><div class="line">        <a class="code" href="group___l_p_c___exported___functions.html#ga18a5dae3ccc9068d22c06585f3ba37a0">LPC_ClearINTPendingBit</a>(<a class="code" href="group___l_p_c__interrupts__definition.html#ga1cfe472811bbb403051a914f985b1c8d">LPC_INT_COUNT_COMP</a>);<span class="comment">//Add Application code here</span></div><div class="line">        <span class="comment">//Add Application code here</span></div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><div style="page-break-after: always;"></div><h2><a class="anchor" id="SPI3wire"></a>
14  3-Wire SPI</h2>
<h3><a class="anchor" id="SPI3wire_Demo_Code_Support_List"></a>
14.1 3-Wire SPI Demo Code Support List</h3>
<center><div id="table_14_1"><b>Table 14-1 3-Wire SPI Sample Code 1 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 1  </th><th class="markdownTableHeadNone">spi3wire_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:180px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:670px">Demonstrate how 3-wire SPI single write and read data.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Brief Introduction  </td><td class="markdownTableBodyNone">Use 3-wire SPI for data transmission with PMW3610DM-SUDU mouse sensor. <br />
Obtain PMW3610DM-SUDU ID, check whether ID is correct, and print <br />
corresponding information in DebugAnalyzer.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\spi3w\polling\spi3wire_demo.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">spi3wire_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">CS PIN  </td><td class="markdownTableBodyNone">#define SPI_3WIRE_CS_PIN P0_2   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">DIO PIN  </td><td class="markdownTableBodyNone">#define SPI_3WIRE_DATA_PIN P0_1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">SCLK PIN  </td><td class="markdownTableBodyNone">#define SPI_3WIRE_CLK_PIN P0_0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Speed  </td><td class="markdownTableBodyNone">800KHz   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Read Delay Time  </td><td class="markdownTableBodyNone">2.5us   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">As shown in Figure 14-1. Connect M0_0 of EVB to SCLK of sensor, connect M0_1 <br />
of EVB to SDIO of sensor, connect M0_2 of EVB to NCS of sensor, connect GND of EVB to GND of sensor, connect U_5V_FT of EVB to 5V of sensor.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">Press RESET on the EVB, if the data transmission is successful, string <br />
"spi3wire_demo: Read mouse sensor ID success" will be printed in DebugAnalyzer, <br />
otherwise, string "spi3wire_demo: Read mouse sensor ID error" will be printed <br />
in DebugAnalyzer.   </td></tr>
</table>
<div class="image">
<img src="3-Wire_SPI_Demo_Hardware_Connection_Diagram.jpg" alt="3-Wire_SPI_Demo_Hardware_Connection_Diagram.jpg"/>
</div>
 <center><div id="figure_14_1"><b>Figure 14-1 3-Wire SPI Demo Hardware Connection Diagram</b></div></center><h3><a class="anchor" id="SPI3wire_Function_Description"></a>
14.2  Function Description</h3>
<p>3-Wire SPI is used to connect 3-wire SPI interfaces such as CS/DIO/SCLK and has single wire, single/burst read function. It is also possible to adjust the desired delay timing between read/write.</p>
<h3><a class="anchor" id="SPI3wire_Feature_List"></a>
14.3  Feature List</h3>
<ul>
<li>Support 2-wire and 3-wire communication</li>
<li>Support single write/read</li>
<li>Support burst read</li>
<li>Configurable delay between read/write</li>
</ul>
<h3><a class="anchor" id="SPI3wire_data_format"></a>
14.4  3-Wire SPI data format</h3>
<p>The data contains two bytes, the first byte is the address bit, the highest bit is the read-write control bit, and the second byte is the data byte. As shown below.</p>
<div class="image">
<img src="3-Wire_SPI_Data_Format.jpg" alt="3-Wire_SPI_Data_Format.jpg"/>
</div>
 <center><div id="figure_14_2"><b>Figure 14-2 3-Wire SPI Data Format</b></div></center><h3><a class="anchor" id="SPI3wire_Write_Operation"></a>
14.5  3-Wire SPI Write Operation</h3>
<p>Write data from the controller to the sensor, only supports single write mode, as shown in the figure below. No delay needs to be added between the address byte and the data byte.</p>
<div class="image">
<img src="Schematic_Diagram_of_3-Wire_SPI_Write_Operation_Frame_Format.jpg" alt="Schematic_Diagram_of_3-Wire_SPI_Write_Operation_Frame_Format.jpg"/>
</div>
 <center><div id="figure_14_3"><b>Figure 14-3 Schematic Diagram of 3-Wire SPI Write Operation Frame Format</b></div></center><h3><a class="anchor" id="SPI3wire_Read_Operation"></a>
14.6  3-Wire SPI Read Operation</h3>
<h4><a class="anchor" id="SPI3wire_Single_Read_Mode"></a>
14.6.1  Single Read Mode</h4>
<p>Between the first byte (address byte) and the second byte (data byte), a delay of T-hold needs to be added. This delay is configured by <b>SPI3WIRE_ReadDelay</b>.</p>
<div class="image">
<img src="Schematic_Diagram_of_3-Wire_SPI_Read_Operation_Frame_Format.jpg" alt="Schematic_Diagram_of_3-Wire_SPI_Read_Operation_Frame_Format.jpg"/>
</div>
 <center><div id="figure_14_4"><b>Figure 14-4 Schematic Diagram of 3-Wire SPI Read Operation Frame Format</b></div></center><h4><a class="anchor" id="SPI3wire_Burst_Read_Mode"></a>
14.6.2  Burst Read Mode</h4>
<p>In burst read mode, SPI can continuously read multiple bytes of data. Between the first byte (address byte) and the second byte (data byte 0), a delay of T-hold needs to be added. This delay is configured by <b>SPI3WIRE_ReadDelay</b>. There is no delay between the third byte (data byte 1) and the second byte (data byte 0) until the end of a Burst read.</p>
<h3><a class="anchor" id="SPI3wire_Initialization_Operation_Flow"></a>
14.7  Initialization Operation Flow</h3>
<p>3-Wire SPI initialization flow is shown in Figure 14-5.</p>
<div class="image">
<img src="3-wire_SPI_Initialization_Flow_Chart.jpg" alt="3-wire_SPI_Initialization_Flow_Chart.jpg"/>
</div>
 <center><div id="figure_14_5"><b>Figure 14-5 3-Wire SPI Initialization Flow Chart</b></div></center><p>The codes below show 3-wire SPI initialization flow. </p><div class="fragment"><div class="line"><span class="comment">/* Enable SPI3WIRE clock */</span></div><div class="line"><a class="code" href="group__x3e___r_c_c___exported___functions.html#ga0ff78e34dcddb1ed9a215ee66ccb2d1b">RCC_PeriphClockCmd</a>(<a class="code" href="group___a_p_b___peripheral___define.html#ga8d9ba981a07bd32342b7c512b5ea9b2e">APBPeriph_SPI2W</a>, <a class="code" href="group___r_c_c___peripheral___clock.html#ga93cd79ebf28927a1a053ba773e5f631a">APBPeriph_SPI2W_CLOCK</a>, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line"></div><div class="line"><span class="comment">/* Initialize SPI3WIRE */</span></div><div class="line"><a class="code" href="struct_s_p_i3_w_i_r_e___init_type_def.html">SPI3WIRE_InitTypeDef</a> SPI3WIRE_InitStruct;</div><div class="line"><a class="code" href="group___t_h_r_e_e___w_i_r_e___s_p_i___exported___functions.html#ga527ada2108cd29c547c295b7a89f54af">SPI3WIRE_StructInit</a>(&amp;SPI3WIRE_InitStruct);</div><div class="line"></div><div class="line">SPI3WIRE_InitStruct.<a class="code" href="struct_s_p_i3_w_i_r_e___init_type_def.html#a107257b9505e1b0ba10d2a7d17362983">SPI3WIRE_SysClock</a>       = 20000000;</div><div class="line">SPI3WIRE_InitStruct.<a class="code" href="struct_s_p_i3_w_i_r_e___init_type_def.html#a50b7146b040654dda7fc08d1ea04d871">SPI3WIRE_Speed</a>          = 800000;</div><div class="line">SPI3WIRE_InitStruct.<a class="code" href="struct_s_p_i3_w_i_r_e___init_type_def.html#a37b7bc5930e1dd2638acf5299a1c4958">SPI3WIRE_Mode</a>           = <a class="code" href="group___t_h_r_e_e___w_i_r_e___s_p_i__mode.html#gafe6b1bc47dcd724671142c56df926772">SPI3WIRE_3WIRE_MODE</a>;</div><div class="line"><span class="comment">/* delay time = (SPI3WIRE_ReadDelay +1)/(2*SPI3WIRE_Speed). The delay time from the end of address phase to the start of read data phase */</span></div><div class="line"><span class="comment">//delay time = (0x03 + 1)/(2 * speed) = 2.5us</span></div><div class="line">SPI3WIRE_InitStruct.<a class="code" href="struct_s_p_i3_w_i_r_e___init_type_def.html#ae44f9789f5a6656320cda5938c2d551f">SPI3WIRE_ReadDelay</a>      = 0x3;</div><div class="line">SPI3WIRE_InitStruct.<a class="code" href="struct_s_p_i3_w_i_r_e___init_type_def.html#a6d79b8b800740dc31168dbdbf0b4d44c">SPI3WIRE_OutputDelay</a>    = <a class="code" href="group___t_h_r_e_e___w_i_r_e___s_p_i___o_e__delay__config.html#gaff78b1ee8206c8c3382d3ba187d002bb">SPI3WIRE_OE_DELAY_NONE</a>;</div><div class="line">SPI3WIRE_InitStruct.<a class="code" href="struct_s_p_i3_w_i_r_e___init_type_def.html#a55336cf49ac1cd44f409303c65c2f7bc">SPI3WIRE_ExtMode</a>        = <a class="code" href="group___t_h_r_e_e___w_i_r_e___s_p_i__end__extend__mode.html#gac952e41e978e21bc6eb741b3e764d4df">SPI3WIRE_NORMAL_MODE</a>;</div><div class="line"><a class="code" href="group___t_h_r_e_e___w_i_r_e___s_p_i___exported___functions.html#ga998c2ed17548f6cc2c8e3dd878e0dd77">SPI3WIRE_Init</a>(&amp;SPI3WIRE_InitStruct);</div></div><!-- fragment --><h3><a class="anchor" id="SPI3wire_Send_Data_Operation_Flow"></a>
14.8  Send Data Operation Flow</h3>
<p>3-Wire SPI sends data operation flow is shown in Figure 14-6.</p>
<div class="image">
<img src="3-wire_SPI_Send_Data_Operation_Flow_Chart.jpg" alt="3-wire_SPI_Send_Data_Operation_Flow_Chart.jpg"/>
</div>
 <center><div id="figure_14_6"><b>Figure 14-6 3-Wire SPI Send Data Operation Flow Chart</b></div></center><div style="page-break-after: always;"></div><p>The codes below show 3-wire SPI send data operation flow. </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> Mouse_SingleWrite(uint8_t address, uint8_t data)</div><div class="line">{</div><div class="line">    uint32_t timeout = 0;</div><div class="line"></div><div class="line">    <span class="comment">/* Check SPI busy or not */</span></div><div class="line">    <span class="keywordflow">while</span> (<a class="code" href="group___t_h_r_e_e___w_i_r_e___s_p_i___exported___functions.html#ga1e2f51b6e0a6df361215a5c740af9ac0">SPI3WIRE_GetFlagStatus</a>(<a class="code" href="group___t_h_r_e_e___w_i_r_e___s_p_i___f_l_a_g.html#gad5eabcf0a97196ac4bda8e189e49e441">SPI3WIRE_FLAG_BUSY</a>) == <a class="code" href="group__x3e___r_t_l876x___exported__types.html#gga89136caac2e14c55151f527ac02daaffab44c8101cc294c074709ec1b14211792">SET</a>)</div><div class="line">    {</div><div class="line">        timeout++;</div><div class="line">        <span class="keywordflow">if</span> (timeout &gt; 0x1ffff)</div><div class="line">        {</div><div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Write data */</span></div><div class="line">    <a class="code" href="group___t_h_r_e_e___w_i_r_e___s_p_i___exported___functions.html#gae8f22e235cf3377b7ec32250ac07b01a">SPI3WIRE_StartWrite</a>(address, data);</div><div class="line"></div><div class="line">    timeout = 0;</div><div class="line">    <span class="comment">/* Wait for communication to end */</span></div><div class="line">    <span class="keywordflow">while</span> (<a class="code" href="group___t_h_r_e_e___w_i_r_e___s_p_i___exported___functions.html#ga1e2f51b6e0a6df361215a5c740af9ac0">SPI3WIRE_GetFlagStatus</a>(<a class="code" href="group___t_h_r_e_e___w_i_r_e___s_p_i___f_l_a_g.html#gad5eabcf0a97196ac4bda8e189e49e441">SPI3WIRE_FLAG_BUSY</a>) == <a class="code" href="group__x3e___r_t_l876x___exported__types.html#gga89136caac2e14c55151f527ac02daaffab44c8101cc294c074709ec1b14211792">SET</a>)</div><div class="line">    {</div><div class="line">        timeout++;</div><div class="line">        <span class="keywordflow">if</span> (timeout &gt; 0x1ffff)</div><div class="line">        {</div><div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="SPI3wire_Receive_Data_Operation_Flow"></a>
14.9  Receive Data Operation Flow</h3>
<p>3-Wire SPI receives data operation flow as shown in Figure 14-7.</p>
<div class="image">
<img src="3-wire_SPI_Receive_Data_Operation_Flow_Chart.jpg" alt="3-wire_SPI_Receive_Data_Operation_Flow_Chart.jpg"/>
</div>
 <center><div id="figure_14_7"><b>Figure 14-7 3-Wire SPI Receive Data Operation Flow Chart</b></div></center><div style="page-break-after: always;"></div><p>The codes below show that 3-wire SPI receives data operation flow. </p><div class="fragment"><div class="line">uint8_t Mouse_SingleRead(uint8_t address)</div><div class="line">{</div><div class="line">    uint8_t reg_value = 0;</div><div class="line">    uint32_t timeout = 0;</div><div class="line"></div><div class="line">    <span class="comment">/* Check SPI busy or not */</span></div><div class="line">    <span class="keywordflow">while</span> (<a class="code" href="group___t_h_r_e_e___w_i_r_e___s_p_i___exported___functions.html#ga1e2f51b6e0a6df361215a5c740af9ac0">SPI3WIRE_GetFlagStatus</a>(<a class="code" href="group___t_h_r_e_e___w_i_r_e___s_p_i___f_l_a_g.html#gad5eabcf0a97196ac4bda8e189e49e441">SPI3WIRE_FLAG_BUSY</a>) == <a class="code" href="group__x3e___r_t_l876x___exported__types.html#gga89136caac2e14c55151f527ac02daaffab44c8101cc294c074709ec1b14211792">SET</a>)</div><div class="line">    {</div><div class="line">        timeout++;</div><div class="line">        <span class="keywordflow">if</span> (timeout &gt; 0x1ffff)</div><div class="line">        {</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Clear Receive data length */</span></div><div class="line">    <a class="code" href="group___t_h_r_e_e___w_i_r_e___s_p_i___exported___functions.html#gabd74069dc6a8e59ca4616f3f25d0838d">SPI3WIRE_ClearRxDataLen</a>();</div><div class="line">    <a class="code" href="group___t_h_r_e_e___w_i_r_e___s_p_i___exported___functions.html#ga18f1c2f9467e0567521436d9a5003329">SPI3WIRE_StartRead</a>(address, 1);</div><div class="line"></div><div class="line">    timeout = 0;</div><div class="line">    <span class="comment">/* Wait for the end of communication */</span></div><div class="line">    <span class="keywordflow">while</span> (<a class="code" href="group___t_h_r_e_e___w_i_r_e___s_p_i___exported___functions.html#ga1e2f51b6e0a6df361215a5c740af9ac0">SPI3WIRE_GetFlagStatus</a>(<a class="code" href="group___t_h_r_e_e___w_i_r_e___s_p_i___f_l_a_g.html#gad5eabcf0a97196ac4bda8e189e49e441">SPI3WIRE_FLAG_BUSY</a>) == <a class="code" href="group__x3e___r_t_l876x___exported__types.html#gga89136caac2e14c55151f527ac02daaffab44c8101cc294c074709ec1b14211792">SET</a>)</div><div class="line">    {</div><div class="line">        timeout++;</div><div class="line">        <span class="keywordflow">if</span> (timeout &gt; 0x1ffff)</div><div class="line">        {</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Get the length of received data */</span></div><div class="line">    <span class="keywordflow">while</span> (<a class="code" href="group___t_h_r_e_e___w_i_r_e___s_p_i___exported___functions.html#gacea53bfc99dafc81bf2831b891ff90f0">SPI3WIRE_GetRxDataLen</a>() == 0);</div><div class="line">    <span class="comment">/* Read data */</span></div><div class="line">    <a class="code" href="group___t_h_r_e_e___w_i_r_e___s_p_i___exported___functions.html#ga118230c5ee44191331ccdcaf3dc878f4">SPI3WIRE_ReadBuf</a>(&amp;reg_value, 1);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> reg_value;</div><div class="line">}</div></div><!-- fragment --><div style="page-break-after: always;"></div><h2><a class="anchor" id="IO_Demo_CapTouch"></a>
15  CapTouch</h2>
<h3><a class="anchor" id="CapTouch_Demo_Code_Support_List"></a>
15.1 CapTouch Demo Code Support List</h3>
<center><div id="table_15_1"><b>Table 15-1 CapTouch Sample Code 1 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 1  </th><th class="markdownTableHeadNone">cap_touch_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:180px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:670px">Demonstrates Captouch how to detect finger touch and proximity by interrupt.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Brief Introduction  </td><td class="markdownTableBodyNone">This sample code demonstrates the Captouch detection of finger touch and proximity through interrupt. In CapTouch Handler, 4 channels can be detected, whether there is finger press/release/false touch/over noise threshold.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\captouch\cap_touch_demo.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">cap_touch_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Channel pin location  </td><td class="markdownTableBodyNone">Channel 0~3: ADC0~ADC3.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">None.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">Press RESET on the EVB. When channel pin is pressed/released, the interrupt status will be printed in DebugAnalyzer.   </td></tr>
</table>
<h3><a class="anchor" id="CapTouch_Function_Description"></a>
15.2  Function Description</h3>
<p>Capacitive touch controller uses a single pin and measures the capacitance between the capacitive sensor pin and ground. Capacitive touch controller uses changes in capacitance to detect the presence of a finger on or near a touch surface.</p>
<div class="image">
<img src="CapTouch_Detect_Theory.jpg" alt="CapTouch_Detect_Theory.jpg"/>
</div>
 <center><div id="figure_15_1"><b>Figure 15-1 CapTouch Detect Theory</b></div></center><p><br />
The sensor parasitic capacitance is called CP. When fingers touch or approach the sensor's surface, it forms a simple parallel plate capacitor with the sensor pad through the overlay. The result is called finger capacitance CF, it increases the measured capacitance CS: CS = CP + CF. <br />
In the initial state, an amount of charge is built-up on an untouched sensor to set the sensor's reference level, CS=CP. As the finger makes contact with the sensor, it couples with the electric field of the sensor. This results in a drop of that sensor's charge - since a portion of that charge is drained off through the finger to ground. Further charge transfers (conversions) from that sensor result in a reduced signal level compared to the untouched state. <br />
Capacitive touch controller as Figure 15-2 shows is implemented by oversampling a high sensitivity ADC which only requires 1-pin per channel. The ADC will capture the voltage of both the reference level (baseline) and the signal level and transform them into digital raw data. If the difference between the reference level and the signal level is greater than the user-determined finger touch threshold, a touch is detected, and at the same time, a touch interrupt will be sent to the MCU to wake up the top system or other operations.</p>
<div class="image">
<img src="CapTouch_System.jpg" alt="CapTouch_System.jpg"/>
</div>
 <center><div id="figure_15_2"><b>Figure 15-2 CapTouch System</b></div></center><p>Capacitive touch controller supports up to 4 capacitive sensing inputs, which offers a wide detection range of capacitance, and best-in-class liquid tolerance. With the smart calibration function enabled, all channels' sensitivity or thresholds could be adjusted individually according to different noise environments. Both of baseline value and the absolute finger touch threshold value will be calibrated automatically to adapt to environmental variation. Capacitive controller offers an adjustable scan period, resulting in lower power consumption. <br />
 <b>Note:</b> RTL87X3E and RTL87X3G support CapTouch, RTL87X3D doesn't support CapTouch.</p>
<h3><a class="anchor" id="CapTouch_Feature_List"></a>
15.3  Feature List</h3>
<ul>
<li>Support 4 capacitive sensor channels</li>
<li>Support wide parasitic capacitance range for each channel: 5~45pF (@ 5uA sensitivity)</li>
<li>Support both finger touch detection and proximity detection</li>
<li>Programmable enable/disable for each channel</li>
<li>Adjustable sensitivity for each channel: 0.25uA~15.75uA</li>
<li>Adjustable baseline and touch threshold(both difference and absolute value) for each channel</li>
<li>Support liquid tolerance: Guard sensor</li>
<li>Programmable channel scan mode</li>
<li>Auto scan mode: hardware automatically scan every enabled channel in sequence</li>
<li>Automatic environment sensor capacitance tracking and calibration (ETC)</li>
<li>Support interrupt control</li>
<li>Low power consumption</li>
</ul>
<h3><a class="anchor" id="CapTouch_Channel_Pin_Location"></a>
15.4  CapTouch Channel Pin Location</h3>
<ul>
<li>Channel 0: P0_0</li>
<li>Channel 1: P0_1</li>
<li>Channel 2: P0_2</li>
<li>Channel 3: P0_3</li>
</ul>
<h3><a class="anchor" id="CapTouch_Sample_Range"></a>
15.5  Sample Range</h3>
<p>CTC sample range is related to channel sensitivity, the more sensitive the channel, the shorter the sample range. The sensitivity parameter is used to increase or decrease the strength of the sensor signal (difference count), which means different counts for the same capacitance change. A higher value of sensitivity setting(bias current) leads to a stronger signal from the sensors(more difference count for the same capacitance change), and also causes the decrease of the sample range. The typical sample range of CTC is 5~45pF when channel sensitivity is 5uA.</p>
<h3><a class="anchor" id="CapTouch_ETC"></a>
15.6  Environment Tracking and Calibration (ETC)</h3>
<p>Sensor capacitance changes all the time according to environmental variations, such as temperature, moisture, overlay changes, or other slight environmental noise. ETC module is built for tracking and calibration with environmental variation. ETC function operates all the time during low power mode. The ETC system tracks the sensor capacitance change by period and updates the baseline and touch threshold based on the ETC automatic update algorithm. <br />
There is no need for an extra scan operation except active mode scan operation. ETC auto tuning all the parameters of ETC module, it works by capturing and comparing the data of scan operation, and making a decision to update the baseline and absolute threshold or not. <br />
Manual tuning of ETC parameters is also supported to meet different noise environments or special applications.</p>
<h3><a class="anchor" id="CapTouch_Touch_Judgement_Mode"></a>
15.7  Touch Judgement Mode (With ETC Function Enable)</h3>
<p>After ADC finishes data processing, decision logic will finish the flowing operations:</p><ol type="1">
<li>Data average operation.</li>
<li>Make subtraction operations of the average sample data and baseline.</li>
<li>Compare difference data with difference threshold.</li>
<li>If the difference data is larger than difference threshold, touch or proximity is detected.</li>
</ol>
<h3><a class="anchor" id="CapTouch_Auto_Scan_Mode"></a>
15.8  Auto Scan Mode</h3>
<p>Hardware will scan every enabled channel in sequence during one scan period. For example, if channel 2 is disabled, then hardware will scan channel 0-&gt;1-&gt;3 once each scan period. The auto scan mode flow as Figure 15-3 shows.</p>
<div class="image">
<img src="Auto_Scan_Mode_Flow_Chart.jpg" alt="Auto_Scan_Mode_Flow_Chart.jpg"/>
</div>
 <center><div id="figure_15_3"><b>Figure 15-3 Auto Scan Mode Flow Chart</b></div></center><h3><a class="anchor" id="CapTouch_Scan_Period"></a>
15.9  Scan Period</h3>
<p>The CTC scan period consists of active time and sleep time. Both the active and the sleep time can be set individually for different applications. The scan period as Figure 15-4 shows.</p>
<div class="image">
<img src="Schematic_Diagram_of_Scan_Period.jpg" alt="Schematic_Diagram_of_Scan_Period.jpg"/>
</div>
 <center><div id="figure_15_4"><b>Figure 15-4 Schematic Diagram of Scan Period</b></div></center><h4><a class="anchor" id="Active_Time"></a>
15.9.1  Active Time</h4>
<p>The active time of cap touch is defined by ADC scan sample number. Cap touch controller (CTC) averages the sample raw data of capture ADC for best accuracy and noise immunity.</p>
<h4><a class="anchor" id="Sleep_Time"></a>
15.9.2  Sleep Time</h4>
<p>After all of these operations for each channel, the channel enters sleep period, and another channel begins to scan and data process. After 4 channels of scanning and data processing are finished, capture ADC power is off, and the cap touch system enters an ultra-low power state until the next cycle of sensor scanning. During sleep period, all channels are still enabled, and PMC uses clock gating to save power. Each channel could be disabled while sensor error is detected or other situations.</p>
<h3><a class="anchor" id="CapTouch_Baseline_Auto-Initialization"></a>
15.10  Baseline Auto-Initialization</h3>
<p>The baseline initial value is 0x0 when CTC function enables, CTC will initialize baseline value automatically with ETC function and baseline initial function both are enabled. Hardware will set the baseline with average of ADC raw code. After that, hardware will enter normal scan mode (ETC scan and judge operation).</p>
<h3><a class="anchor" id="CapTouch_Noise_Threshold"></a>
15.11  Noise Threshold</h3>
<p>The environmental negative noise threshold means the maximum capacitance change of raw data that is still considered an environmental change. CTC system support 2 noise threshold positive noise threshold and negative noise threshold for optimal calibration. Both of the two noise thresholds are individually adjustable for each channel. <br />
Environmental noise usually changes slightly and slowly, most of the noise average data ranges from 0~50, less than 40%*Touch threshold even when WIFI, BT, GSM, or other RF transmission occurs beside the CTC device. The recommended value of noise threshold is 40%*touch threshold. <br />
Specify operations take place while signal changes significantly which is larger than noise threshold. For example, when finger touches the sensor surface, glass or plastic overlay causes the difference data (baseline - signal) larger than the negative noise threshold. Glass or plastic being removed from sensor surface or finger released after CTC initial, both cause the difference data (signal - baseline) larger than the positive noise threshold. All of these operations are not normal environment noise variations. <br />
CTC sends P_ENT interrupt to host while difference (signal - baseline) is larger than positive noise threshold. Host needs to initialize the baseline when P_ENT is detected. CTC instructs ETC module to ignore ETC update operation automatically when difference data (baseline - signal) is larger than negative noise threshold. <br />
Users need to tune both the two noise thresholds for different applications and different noise environments.</p>
<h3><a class="anchor" id="CapTouch_Fast_Mode"></a>
15.12  Fast Mode</h3>
<p>To improve response time, the scan period can become smaller after detecting ADC raw data lower than threshold. The smaller interval makes for faster response time and higher power consumption.</p>
<h4><a class="anchor" id="Channel_False_Alarm"></a>
15.12.1  Channel False Alarm/Release Active Counter</h4>
<p>Fs match counter: In idle mode, count how many scans meet the threshold condition. When fs_match_cnt meets setting, scan interval changes from slow mode to fast mode. When setting fs_match_cnt = 0, it will always be in slow mode. <br />
False alarm counter: Counting for false alarm. When fs_match_cnt meets and debounce_cnt doesn't meet, false alarm counter will count the scans in fast mode. After false alarm counter meets, it returns to idle state (slow interval). <br />
Release active counter: Counting for release active (trigger by release active event). After the release active event, counting scans in fast mode. After releasing active counter meets, it returns to idle state (slow mode).</p>
<h4><a class="anchor" id="Channel_Press_Counter"></a>
15.12.2  Channel Press Counter</h4>
<p>False touch counter: Counter for false touch. It starts after debounce counter meets setting. After false touch counter triggers, it is forced to return idle state to prevent extra power consumption. <br />
Fast touch counter: Counting how many scans meet threshold conditions in fast mode. You can calculate the press time according to this counter.</p>
<div class="image">
<img src="Fast_Mode_Control_Flow_Chart.jpg" alt="Fast_Mode_Control_Flow_Chart.jpg"/>
</div>
 <center><div id="figure_15_5"><b>Figure 15-5 Fast Mode Control Flow Chart</b></div></center><h3><a class="anchor" id="CapTouch_Operation_Flow"></a>
15.13  CapTouch Operation Flow</h3>
<p>CapTouch initialization flow is shown in Figure 15-6.</p>
<div class="image">
<img src="CapTouch_Initialization_Flow.jpg" alt="CapTouch_Initialization_Flow.jpg"/>
</div>
 <center><div id="figure_15_6"><b>Figure 15-6 CapTouch Initialization Flow Chart</b></div></center><div style="page-break-after: always;"></div><p>The codes below show CapTouch initialization flow. </p><div class="fragment"><div class="line"><span class="comment">/* Enable CapTouch function */</span></div><div class="line">CapTouch_SystemEnable(<span class="keyword">true</span>);</div><div class="line"></div><div class="line"><span class="comment">/* Reset CapTouch system and clear all settings */</span></div><div class="line">CapTouch_SysReset();</div><div class="line"></div><div class="line">IO_PRINT_INFO2(<span class="stringliteral">&quot;cap_touch_demo: Start, max_channel %d, cap_touch_enable %d&quot;</span>,</div><div class="line">                   CapTouch_GetMaxChannel(), CapTouch_IsSystemEnable());</div><div class="line"></div><div class="line"><span class="comment">/* Register new interrupt handler to vector table */</span></div><div class="line"><a class="code" href="group___h_a_l___vector_table.html#ga1ddcc6c785e2655f5de7b7edf1f4302d">RamVectorTableUpdate</a>(TOUCH_VECTORn, (IRQ_Fun)CapTouch_Handler);</div><div class="line"></div><div class="line"><span class="comment">/* Enable specified channel */</span></div><div class="line">CapTouch_ChCmd(CTC_CH0, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line">CapTouch_ChCmd(CTC_CH1, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line">CapTouch_ChCmd(CTC_CH2, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line">CapTouch_ChCmd(CTC_CH3, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line"></div><div class="line"><span class="comment">/* Enable the specified CapTouch interrupts of specified channel */</span></div><div class="line">CapTouch_ChINTConfig(CTC_CH0, (CTC_CH_INT_TYPE)(CTC_TOUCH_PRESS_INT | CTC_TOUCH_RELEASE_INT |</div><div class="line">                                                    CTC_FALSE_TOUCH_INT), <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line">CapTouch_ChINTConfig(CTC_CH1, (CTC_CH_INT_TYPE)(CTC_TOUCH_PRESS_INT | CTC_TOUCH_RELEASE_INT |</div><div class="line">                                                    CTC_FALSE_TOUCH_INT), <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line">CapTouch_ChINTConfig(CTC_CH2, (CTC_CH_INT_TYPE)(CTC_TOUCH_PRESS_INT | CTC_TOUCH_RELEASE_INT |</div><div class="line">                                                    CTC_FALSE_TOUCH_INT), <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line">CapTouch_ChINTConfig(CTC_CH3, (CTC_CH_INT_TYPE)(CTC_TOUCH_PRESS_INT | CTC_TOUCH_RELEASE_INT |</div><div class="line">                                                    CTC_FALSE_TOUCH_INT), <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line"></div><div class="line"><span class="comment">/* Enable the specified CapTouch noise interrupts */</span></div><div class="line">CapTouch_NoiseINTConfig(CTC_OVER_P_NOISE_INT, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line"></div><div class="line"><span class="comment">/* Set scan interval */</span></div><div class="line"><span class="keywordflow">if</span> (!CapTouch_SetScanInterval(0x3B, CTC_SLOW_MODE))</div><div class="line">{</div><div class="line">    IO_PRINT_WARN0(<span class="stringliteral">&quot;cap_touch_demo: Slow mode scan interval overange&quot;</span>);</div><div class="line">}</div><div class="line"><span class="keywordflow">if</span> (!CapTouch_SetScanInterval(0x1D, CTC_FAST_MODE))</div><div class="line">{</div><div class="line">    IO_PRINT_WARN0(<span class="stringliteral">&quot;cap_touch_demo: Fast mode scan interval overange&quot;</span>);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* Enable touch wakeup from DLPS, PowerDown */</span></div><div class="line">CapTouch_ChWakeupCmd(CTC_CH0, (<a class="code" href="group__x3d___r_t_l876x___exported__types.html#gac9a7e9a35d2513ec15c3b537aaa4fba1">FunctionalState</a>)<a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line">CapTouch_ChWakeupCmd(CTC_CH1, (<a class="code" href="group__x3d___r_t_l876x___exported__types.html#gac9a7e9a35d2513ec15c3b537aaa4fba1">FunctionalState</a>)<a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line">CapTouch_ChWakeupCmd(CTC_CH2, (<a class="code" href="group__x3d___r_t_l876x___exported__types.html#gac9a7e9a35d2513ec15c3b537aaa4fba1">FunctionalState</a>)<a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line">CapTouch_ChWakeupCmd(CTC_CH3, (<a class="code" href="group__x3d___r_t_l876x___exported__types.html#gac9a7e9a35d2513ec15c3b537aaa4fba1">FunctionalState</a>)<a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line"></div><div class="line"><span class="comment">/*Should keep 32k clk if enable wakeup from power down mode*/</span></div><div class="line">pmu_set_clk_32k_power_in_powerdown(<span class="keyword">true</span>);</div><div class="line"></div><div class="line"><span class="comment">/* Cap Touch start start after 3s later */</span></div><div class="line">CapTouch_Cmd(<a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div></div><!-- fragment --><p>CapTouch interrupt handle flow is shown in Figure 15-7.</p>
<div class="image">
<img src="CapTouch_interrupt_handle_flow.jpg" alt="CapTouch_interrupt_handle_flow.jpg"/>
</div>
 <center><div id="figure_15_7"><b>Figure 15-7 CapTouch Interrupt Handle Flow Chart</b></div></center><p>The codes below show CapTouch interrupt handle flow. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> captouch_handler(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    uint32_t int_status = 0;</div><div class="line">    int_status = CapTouch_GetINTStatus();</div><div class="line">    IO_PRINT_INFO1(<span class="stringliteral">&quot;captouch_handler: int_status 0x%x&quot;</span>, int_status);</div><div class="line">    <span class="comment">/* Channel 0 interrupts */</span></div><div class="line">    <span class="keywordflow">if</span> (CapTouch_IsChINTTriggered(int_status, CTC_CH0, CTC_TOUCH_PRESS_INT))</div><div class="line">    {</div><div class="line">        <span class="comment">/* do something */</span></div><div class="line">        CapTouch_ChINTClearPendingBit(CTC_CH0, CTC_TOUCH_PRESS_INT);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">if</span> (CapTouch_IsChINTTriggered(int_status, CTC_CH0, CTC_TOUCH_RELEASE_INT))</div><div class="line">    {</div><div class="line">        <span class="comment">/* do something */</span></div><div class="line">        CapTouch_ChINTClearPendingBit(CTC_CH0, CTC_TOUCH_RELEASE_INT);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">if</span> (CapTouch_IsChINTTriggered(int_status, CTC_CH0, CTC_FALSE_TOUCH_INT))</div><div class="line">    {</div><div class="line">        <span class="comment">/* do something */</span></div><div class="line">        CapTouch_ChINTClearPendingBit(CTC_CH0, CTC_FALSE_TOUCH_INT);</div><div class="line">    }</div><div class="line">    <span class="comment">/* Channel 1 interrupts */</span></div><div class="line">    <span class="keywordflow">if</span> (CapTouch_IsChINTTriggered(int_status, CTC_CH1, CTC_TOUCH_PRESS_INT))</div><div class="line">    {</div><div class="line">        <span class="comment">/* do something */</span></div><div class="line">        CapTouch_ChINTClearPendingBit(CTC_CH1, CTC_TOUCH_PRESS_INT);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">if</span> (CapTouch_IsChINTTriggered(int_status, CTC_CH1, CTC_TOUCH_RELEASE_INT))</div><div class="line">    {</div><div class="line">        <span class="comment">/* do something */</span></div><div class="line">        CapTouch_ChINTClearPendingBit(CTC_CH1, CTC_TOUCH_RELEASE_INT);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">if</span> (CapTouch_IsChINTTriggered(int_status, CTC_CH1, CTC_FALSE_TOUCH_INT))</div><div class="line">    {</div><div class="line">        <span class="comment">/* do something */</span></div><div class="line">        CapTouch_ChINTClearPendingBit(CTC_CH1, CTC_FALSE_TOUCH_INT);</div><div class="line">    }</div><div class="line">    <span class="comment">/* Channel 2 interrupts */</span></div><div class="line">    <span class="keywordflow">if</span> (CapTouch_IsChINTTriggered(int_status, CTC_CH2, CTC_TOUCH_PRESS_INT))</div><div class="line">    {</div><div class="line">        <span class="comment">/* do something */</span></div><div class="line">        CapTouch_ChINTClearPendingBit(CTC_CH2, CTC_TOUCH_PRESS_INT);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">if</span> (CapTouch_IsChINTTriggered(int_status, CTC_CH2, CTC_TOUCH_RELEASE_INT))</div><div class="line">    {</div><div class="line">        <span class="comment">/* do something */</span></div><div class="line">        CapTouch_ChINTClearPendingBit(CTC_CH2, CTC_TOUCH_RELEASE_INT);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">if</span> (CapTouch_IsChINTTriggered(int_status, CTC_CH2, CTC_FALSE_TOUCH_INT))</div><div class="line">    {</div><div class="line">        <span class="comment">/* do something */</span></div><div class="line">        CapTouch_ChINTClearPendingBit(CTC_CH2, CTC_FALSE_TOUCH_INT);</div><div class="line">    }</div><div class="line">    <span class="comment">/* Channel 3 interrupts */</span></div><div class="line">    <span class="keywordflow">if</span> (CapTouch_IsChINTTriggered(int_status, CTC_CH3, CTC_TOUCH_PRESS_INT))</div><div class="line">    {</div><div class="line">        <span class="comment">/* do something */</span></div><div class="line">        CapTouch_ChINTClearPendingBit(CTC_CH3, CTC_TOUCH_PRESS_INT);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">if</span> (CapTouch_IsChINTTriggered(int_status, CTC_CH3, CTC_TOUCH_RELEASE_INT))</div><div class="line">    {</div><div class="line">        <span class="comment">/* do something */</span></div><div class="line">        CapTouch_ChINTClearPendingBit(CTC_CH3, CTC_TOUCH_RELEASE_INT);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">if</span> (CapTouch_IsChINTTriggered(int_status, CTC_CH3, CTC_FALSE_TOUCH_INT))</div><div class="line">    {</div><div class="line">        <span class="comment">/* do something */</span></div><div class="line">        CapTouch_ChINTClearPendingBit(CTC_CH3, CTC_FALSE_TOUCH_INT);</div><div class="line">    }</div><div class="line">    <span class="comment">/* Noise Interrupt */</span></div><div class="line">    <span class="keywordflow">if</span> (CapTouch_IsNoiseINTTriggered(int_status, CTC_OVER_N_NOISE_INT))</div><div class="line">    {</div><div class="line">        <span class="comment">/* do something */</span></div><div class="line">        CapTouch_NoiseINTClearPendingBit(CTC_OVER_N_NOISE_INT);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">if</span> (CapTouch_IsNoiseINTTriggered(int_status, CTC_OVER_P_NOISE_INT))</div><div class="line">    {</div><div class="line">        IO_PRINT_ERROR0(<span class="stringliteral">&quot;captouch_handler: OVER_P_NOISE_INT baseline error, need to reset Cap-touch system&quot;</span>);</div><div class="line">        CapTouch_NoiseINTClearPendingBit(CTC_OVER_P_NOISE_INT);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><div style="page-break-after: always;"></div><h2><a class="anchor" id="ADC"></a>
16  ADC</h2>
<h3><a class="anchor" id="ADC_Demo_Code_Support_List"></a>
16.1 ADC Demo Code Support List</h3>
<center><div id="table_16_1"><b>Table 16-1 ADC Sample Code 1 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 1  </th><th class="markdownTableHeadNone">adc_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:250px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:600px">Demonstrate how ADC samples data by interrupt mode in one-shot mode.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Brief Introduction  </td><td class="markdownTableBodyNone">Use one-shot mode of ADC peripheral to measure voltage on P0_0, P0_1, <br />
VBAT and VADPIN by interrupt. Print voltage values in DebugAnalyzer.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\adc\one-shot\adc_demo.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">adc_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Pre-Condition  </td><td class="markdownTableBodyNone">Turn off Charger auto enable and Battery detection support on the <br />
McuConfig Tool.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Channel  </td><td class="markdownTableBodyNone">ADC0<br />
ADC1<br />
VBAT<br />
VADPIN   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">External Channel Input Mode  </td><td class="markdownTableBodyNone">ADC0 is divide mode and ADC1 is bypass mode.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">As shown in Figure 16-1.<br />
1. Connect M0_0 and M0_1 of EVB to external DC voltage source. Input <br />
voltage of M0_0 must range from 0 to 3.3V, and input voltage of M0_1 must <br />
range from 0 to 0.9V.<br />
2. Connect VBAT to BAT+ and connect Li-ion battery to BAT socket. <br />
3. Connect VADP to U_5V_FT.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">Print voltage on P0_0, P0_1, VBAT and VADPIN in DebugAnalyzer every <br />
1000ms.   </td></tr>
</table>
<center><div id="table_16_2"><b>Table 16-2 ADC Sample Code 2 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 2  </th><th class="markdownTableHeadNone">adc_polling_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:250px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:600px">Demonstrate how ADC samples data by polling mode in one-shot mode.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Brief Introduction  </td><td class="markdownTableBodyNone">Use one-shot mode of ADC peripheral to measure voltage on P0_1, VBAT, <br />
and VADPIN by polling. Print voltage values in DebugAnalyzer.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\adc\one-shot\adc_polling_demo.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">adc_polling_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Pre-Condition  </td><td class="markdownTableBodyNone">Turn off Charger auto enable and Battery detection support on the <br />
McuConfig Tool.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Channel  </td><td class="markdownTableBodyNone">ADC1<br />
VBAT<br />
VADPIN   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">External Channel Input Mode  </td><td class="markdownTableBodyNone">ADC1 is divide mode.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">1. Connect M0_1 of EVB to external DC voltage source and input voltage of M0_1 must range from 0 to 3.3V.<br />
2. Connect VBAT to BAT+ and connect Li-ion battery to BAT socket.<br />
3. Connect VADP to U_5V_FT.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">Print voltage on P0_1, VBAT and VADPIN in DebugAnalyzer.   </td></tr>
</table>
<div style="page-break-after: always;"></div><center><div id="table_16_3"><b>Table 16-3 ADC Sample Code 3 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 3  </th><th class="markdownTableHeadNone">adc_hw_average_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:250px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:600px">Demonstrate how ADC samples data with hardware average function.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Brief Introduction  </td><td class="markdownTableBodyNone">Use hardware average function of ADC peripheral to measure voltage on <br />
P0_1 and print voltage values in DebugAnalyzer.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\adc\adc_hw_average\adc_hw_average_demo.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">adc_hw_average_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Pre-Condition  </td><td class="markdownTableBodyNone">Turn off Charger auto enable and Battery detection support on the <br />
McuConfig Tool.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Channel  </td><td class="markdownTableBodyNone">ADC1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">External Channel Input Mode  </td><td class="markdownTableBodyNone">ADC1 is divide mode.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">Connect M0_1 of EVB to external DC voltage source. Input voltage of <br />
M0_1 must range from 0 to 3.3V.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">Print voltage on P0_1 in DebugAnalyzer.   </td></tr>
</table>
<center><div id="table_16_4"><b>Table 16-4 ADC Sample Code 4 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 4  </th><th class="markdownTableHeadNone">adc_manager_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:180px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:670px">Demonstrate how ADC samples data by adc manager.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Brief Introduction  </td><td class="markdownTableBodyNone">Use one-shot mode of ADC peripheral to measure voltage on VBAT and VADPIN by adc manager. Print sample raw data in DebugAnalyzer.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\adc\adc_manger\adc_manager_demo.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">adc_manager_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Channel  </td><td class="markdownTableBodyNone">VBAT<br />
VADPIN   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">1. Connect VBAT to BAT+ and connect Li-ion battery to BAT socket.<br />
2. Connect VADP to U_5V_FT.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">Print sample raw data in DebugAnalyzer.   </td></tr>
</table>
<div style="page-break-after: always;"></div><center><div id="table_16_5"><b>Table 16-5 ADC Sample Code 5 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 5  </th><th class="markdownTableHeadNone">adc_continuous_mode_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:250px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:680px">Demonstrate how ADC samples data in continuous mode with charger and <br />
discharger enabled.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Brief Introduction  </td><td class="markdownTableBodyNone">Use continuous mode of ADC peripheral to measure voltage on P0_0 with charger <br />
and discharger enabled. Print sample raw data and voltage in DebugAnalyzer.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\adc\adc_continuous_mode\adc_continuous_mode_demo.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">adc_continuous_mode_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Pre-Condition  </td><td class="markdownTableBodyNone">Turn on Charger auto enable and Battery detection support on the McuConfig Tool.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Channel  </td><td class="markdownTableBodyNone">ADC0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">External Channel Input Mode  </td><td class="markdownTableBodyNone">ADC0 is divide mode.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">Connect M0_0 of EVB to external DC voltage source. Input voltage of M0_0 must <br />
range from 0 to 3.3V.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">When VADP and U_5V_FT are connected, ADC stops continuous sampling, when VADP and U_5V_FT are disconnected, ADC starts continuous sampling and <br />
prints sample raw data and voltage on P0_0 in DebugAnalyzer.   </td></tr>
</table>
<center><div id="table_16_6"><b>Table 16-6 ADC Sample Code 6 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 6  </th><th class="markdownTableHeadNone">adc_charger_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:250px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:600px">Demonstrate how ADC samples NTC and VBAT voltage.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Brief Introduction  </td><td class="markdownTableBodyNone">Use one-shot mode of ADC peripheral to measure voltage on VBAT and <br />
NTC by adc manager. Print voltage values in DebugAnalyzer.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\adc\adc_charger_demo\adc_charger_demo.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">adc_charger_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Channel  </td><td class="markdownTableBodyNone">ADC0<br />
ADC1<br />
VBAT   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">External Channel Input Mode  </td><td class="markdownTableBodyNone">ADC0 and ADC1 is bypass mode.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">1. Connect M0_0 and M0_1 of EVB to external DC voltage source and input voltage must range from 0 to 0.9V.<br />
2. Connect VBAT to BAT+ and connect Li-ion battery to BAT socket.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">Print voltage on VBAT and NTC in DebugAnalyzer every 500ms.   </td></tr>
</table>
<div class="image">
<img src="ADC_Demo_Hardware_Connection_Diagrame.jpg" alt="ADC_Demo_Hardware_Connection_Diagrame.jpg"/>
</div>
 <center><div id="figure_16_1"><b>Figure 16-1 ADC Demo Hardware Connection Diagrame</b></div></center><h3><a class="anchor" id="ADC_Feature_List"></a>
16.2  Feature List</h3>
<ul>
<li>Up to 8 external channel</li>
<li>VBAT and VADPIN internal channel</li>
<li>Two external channel input modes: bypass mode and divide mode</li>
<li>Support single-ended mode</li>
<li>Two work modes: one-shot mode and continuous mode</li>
<li>16 index schedule table</li>
<li>Timer7 trigger ADC one-shot mode sampling</li>
<li>32 depth FIFO for continuous mode</li>
<li>Support hardware average function</li>
</ul>
<p><b>Note:</b> RTL87X3D supports 8 external channels. RTL87X3E and RTL87X3G support 4 external channels.</p>
<h3><a class="anchor" id="ADC_Pin"></a>
16.3  ADC Pin</h3>
<ul>
<li>RTL87X3D supports 8 external channels: external channel 0 ~ 7 correspond to Pin P0_0 ~ P0_7.</li>
<li>RTL87X3E and RTL87X3G support 4 external channels: external channel 0 ~ 3 correspond to Pin P0_0 ~ P0_3.</li>
</ul>
<h3><a class="anchor" id="ADC_Channel_Mode"></a>
16.4  Channel Mode</h3>
<h4><a class="anchor" id="Single-Ended_Mode"></a>
16.4.1  Single-Ended Mode</h4>
<p>Single-Ended mode occupies one channel and uses only one pin for sampling. </p>
<h4><a class="anchor" id="Internal_VBAT_Mode"></a>
16.4.2  Internal VBAT/VADPIN Mode</h4>
<p>Internal VBAT mode is used to measure VBAT voltage. Internal VADPIN mode is used to measure VADPIN voltage.</p>
<h3><a class="anchor" id="ADC_External_Channel_Input_Mode"></a>
16.5  External Channel Input Mode</h3>
<h4><a class="anchor" id="Bypass_Mode"></a>
16.5.1  Bypass Mode</h4>
<ul>
<li>The input range of ADC bypass mode is 0 to 0.9V.</li>
</ul>
<h4><a class="anchor" id="Divide_Mode"></a>
16.5.2  Divide Mode</h4>
<ul>
<li>The input range of ADC divide mode is 0 to 3.3V.</li>
</ul>
<h3><a class="anchor" id="ADC_Work_Mode"></a>
16.6  Work Mode</h3>
<h4><a class="anchor" id="One_Shot_Mode"></a>
16.6.1  One Shot Mode</h4>
<ul>
<li>After ADC is enabled, only one sampling is performed. If sampling again, the user needs to manually restart sampling.</li>
<li>It can cooperate with TIM7 peripheral to realize timing continuous sampling. </li>
</ul>
<h4><a class="anchor" id="Continuous_Mode"></a>
16.6.2  Continuous Mode</h4>
<ul>
<li>After ADC is enabled, sampling continues until ADC is disabled.</li>
<li>It can cooperate with GDMA continuous sampling.</li>
</ul>
<h3><a class="anchor" id="ADC_Schedule_Table_Index"></a>
16.7  ADC Schedule Table Index</h3>
<ol type="1">
<li>ADC has 16 schedule tables. Write the parameters in the table below into schIndex[0] ~ schIndex[15] to set channel mode and channel number.</li>
<li>Then set bitmap, schIndex[0] ~ schIndex[15] corresponding to bit0 ~ bit15 of bitmap. If the specific bit of bitmap is set to 1, it means that the schedule table corresponding to this bit is enabled. For example, if config schIndex[0] and schIndex [1], then bitmap is 0000 0000 0011 (that is, 0x0003), if config schIndex [0] and schIndex [2], then bitmap is 0000 0000 0101 (that is, 0x0005).</li>
<li>After ADC is enabled, ADC will sample successively according to the mode configured in the enabled schedule table.</li>
</ol>
<center><div id="table_16_7"><b>Table 16-7 ADC Schedule Table</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">schIndex  </th><th class="markdownTableHeadCenter">description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:255px"><a class="el" href="group__x3e___a_d_c__schedule__table.html#ga056869deda8f3480fd27e806f2e7799a">EXT_SINGLE_ENDED(0)</a></div>  </td><td class="markdownTableBodyCenter"><div style="width:600px">single-ended mode, the input is external channel 0</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><a class="el" href="group__x3e___a_d_c__schedule__table.html#ga056869deda8f3480fd27e806f2e7799a">EXT_SINGLE_ENDED(1)</a>  </td><td class="markdownTableBodyCenter">single-ended mode, the input is external channel 1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><a class="el" href="group__x3e___a_d_c__schedule__table.html#ga056869deda8f3480fd27e806f2e7799a">EXT_SINGLE_ENDED(2)</a>  </td><td class="markdownTableBodyCenter">single-ended mode, the input is external channel 2   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><a class="el" href="group__x3e___a_d_c__schedule__table.html#ga056869deda8f3480fd27e806f2e7799a">EXT_SINGLE_ENDED(3)</a>  </td><td class="markdownTableBodyCenter">single-ended mode, the input is external channel 3   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><a class="el" href="group__x3e___a_d_c__schedule__table.html#ga056869deda8f3480fd27e806f2e7799a">EXT_SINGLE_ENDED(4)</a>  </td><td class="markdownTableBodyCenter">single-ended mode, the input is external channel 4   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><a class="el" href="group__x3e___a_d_c__schedule__table.html#ga056869deda8f3480fd27e806f2e7799a">EXT_SINGLE_ENDED(5)</a>  </td><td class="markdownTableBodyCenter">single-ended mode, the input is external channel 5   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><a class="el" href="group__x3e___a_d_c__schedule__table.html#ga056869deda8f3480fd27e806f2e7799a">EXT_SINGLE_ENDED(6)</a>  </td><td class="markdownTableBodyCenter">single-ended mode, the input is external channel 6   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><a class="el" href="group__x3e___a_d_c__schedule__table.html#ga056869deda8f3480fd27e806f2e7799a">EXT_SINGLE_ENDED(7)</a>  </td><td class="markdownTableBodyCenter">single-ended mode, the input is external channel 7   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">INTERNAL_VBAT_MODE  </td><td class="markdownTableBodyCenter">Internal battery voltage detection channel   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">INTERNAL_VADPIN_MODE  </td><td class="markdownTableBodyCenter">Internal adapter voltage detection channel   </td></tr>
</table>
<div style="page-break-after: always;"></div><h3><a class="anchor" id="ADC_One_Shot_Mode_Operation_Flow"></a>
16.8  ADC One Shot Mode Operation Flow</h3>
<h4><a class="anchor" id="ADC_Polling_Mode"></a>
16.8.1  Polling Mode</h4>
<p>The flow of ADC sampling in one-shot mode by polling is shown in Figure 16-2.</p>
<div class="image">
<img src="ADC_One_Shot_Sampling_by_Polling_Mode.jpg" alt="ADC_One_Shot_Sampling_by_Polling_Mode.jpg"/>
</div>
 <center><div id="figure_16_2"><b>Figure 16-2 ADC One Shot Sampling by Polling Mode</b></div></center><p>The codes below show the flow of ADC sampling in one-shot mode by polling. For details, please refer to src\sample\io_demo\adc\one-shot\adc_polling_demo.c</p>
<p><b>Note:</b> To use the method below, please turn off Charger auto enable and Battery detection support on the McuConfig Tool. As shown in Figure 16-3.</p>
<div style="page-break-after: always;"></div><div class="fragment"><div class="line"><span class="comment">/* Enable ADC clock */</span></div><div class="line"><a class="code" href="group__x3e___r_c_c___exported___functions.html#ga0ff78e34dcddb1ed9a215ee66ccb2d1b">RCC_PeriphClockCmd</a>(<a class="code" href="group___a_p_b___peripheral___define.html#gaca53641683b97825117c40065f54aa41">APBPeriph_ADC</a>, <a class="code" href="group___r_c_c___peripheral___clock.html#ga6098f8487730394fe549a7bc36742e9c">APBPeriph_ADC_CLOCK</a>, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line"></div><div class="line"><a class="code" href="struct_a_d_c___init_type_def.html">ADC_InitTypeDef</a> adc_init_struct;</div><div class="line"><span class="comment">/* Fill each ADC_InitStruct member variable with its default value */</span></div><div class="line"><a class="code" href="group__x3e___a_d_c___exported___functions.html#gae11856cf4a6ae92766f91247c8811cd3">ADC_StructInit</a>(&amp;adc_init_struct);</div><div class="line"></div><div class="line"><span class="comment">/* Write the parameters into schedule table to set channel mode and channel number. */</span></div><div class="line">adc_init_struct.<a class="code" href="struct_a_d_c___init_type_def.html#a056154dd5de8b77c68387fdfcd339ae8">schIndex</a>[0] = <a class="code" href="group___a_d_c__schedule__table.html#ga056869deda8f3480fd27e806f2e7799a">EXT_SINGLE_ENDED</a>(1);</div><div class="line">adc_init_struct.<a class="code" href="struct_a_d_c___init_type_def.html#a056154dd5de8b77c68387fdfcd339ae8">schIndex</a>[1] = <a class="code" href="group___a_d_c__schedule__table.html#gae774ea9d3cd4353fe3517c7caaa437c1">INTERNAL_VBAT_MODE</a>;</div><div class="line">adc_init_struct.<a class="code" href="struct_a_d_c___init_type_def.html#a056154dd5de8b77c68387fdfcd339ae8">schIndex</a>[2] = <a class="code" href="group___a_d_c__schedule__table.html#ga85224f9bb1ff197023bdffa776ff92af">INTERNAL_VADPIN_MODE</a>;</div><div class="line"><span class="comment">/* Set bitmap, schIndex[0] ~ schIndex[15] corresponding to bit0 ~ bit15 of bitmap.</span></div><div class="line"><span class="comment">   If the specific bit of bitmap is set to 1, it means that the schedule table corresponding to this bit is enabled.</span></div><div class="line"><span class="comment">   For example, if config schIndex[0] and schIndex [1], then bitmap is 0000 0000 0011 (that is, 0x0003),</span></div><div class="line"><span class="comment">   if config schIndex [0] and schIndex [2], then bitmap is 0000 0000 0101 (that is, 0x0005).</span></div><div class="line"><span class="comment">   After ADC is enabled, ADC will sample successively according to the mode configured in the enabled schedule table.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">adc_init_struct.<a class="code" href="struct_a_d_c___init_type_def.html#a02b2be7b8ce086893453d390c5fdcf1d">bitmap</a> = 0x07;</div><div class="line"><span class="comment">/* Initialize ADC */</span></div><div class="line"><a class="code" href="group__x3e___a_d_c___exported___functions.html#ga4b79b2802cf9788debd310ffa9bea0db">ADC_Init</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#ga54d148b91f3d356713f7e367a2243bea">ADC</a>, &amp;adc_init_struct);</div><div class="line"></div><div class="line"><span class="comment">/* Enable ADC one shot mode done interrupt */</span></div><div class="line"><a class="code" href="group___a_d_c___exported___functions.html#ga2c6af6a81dc97f93e31fe3c95127bb69">ADC_INTConfig</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#ga54d148b91f3d356713f7e367a2243bea">ADC</a>, <a class="code" href="group___a_d_c___interrupts___definition.html#gafceec649c4add8134490dfc4a775d94d">ADC_INT_ONE_SHOT_DONE</a>, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line"></div><div class="line"><span class="comment">/* Disable NVIC of ADC */</span></div><div class="line"><a class="code" href="struct_n_v_i_c___init_type_def.html">NVIC_InitTypeDef</a> NVIC_InitStruct;</div><div class="line">NVIC_InitStruct.<a class="code" href="struct_n_v_i_c___init_type_def.html#a921af0ab04e071d7d276c003e0048123">NVIC_IRQChannel</a> = <a class="code" href="group__x3e___r_t_l876x___exported__types.html#gga666eb0caeb12ec0e281415592ae89083a4d69175258ae261dd545001e810421b3">ADC_IRQn</a>;</div><div class="line">NVIC_InitStruct.<a class="code" href="struct_n_v_i_c___init_type_def.html#acd582bc2edce30e9d7ab5e0ede400f36">NVIC_IRQChannelPriority</a> = 3;</div><div class="line">NVIC_InitStruct.<a class="code" href="struct_n_v_i_c___init_type_def.html#a3c5567ef024a0489884083c88f17b4d5">NVIC_IRQChannelCmd</a> = <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1ad3a9df141be0ccf10389b640f492b26d">DISABLE</a>;</div><div class="line"><a class="code" href="group__x3e___n_v_i_c___exported___functions.html#ga4e06b4f5c9109d6bc8990adf77e5f8d3">NVIC_Init</a>(&amp;NVIC_InitStruct);</div><div class="line"></div><div class="line"><span class="comment">/* Enable ADC one shot sampling.</span></div><div class="line"><span class="comment">   When ADC is enabled, sampling will be done quickly.</span></div><div class="line"><span class="comment">   After initialization, ADC can be enabled when sampling is needed. */</span></div><div class="line"><a class="code" href="group__x3e___a_d_c___exported___functions.html#ga866ea1f65d482f8d1846a79724caa7b0">ADC_Cmd</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#ga54d148b91f3d356713f7e367a2243bea">ADC</a>, <a class="code" href="group___a_d_c__operation___mode.html#ga3cbe42ba0befbfa2511e0b3fb667632a">ADC_One_Shot_Mode</a>, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line"></div><div class="line"><span class="comment">/* Check ADC_INT_ONE_SHOT_DONE interrupt status flag */</span></div><div class="line"><span class="keywordflow">while</span> (<a class="code" href="group___a_d_c___exported___functions.html#ga81a5a5bf5157fe6e167c217d81b193b8">ADC_GetIntFlagStatus</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#ga54d148b91f3d356713f7e367a2243bea">ADC</a>, <a class="code" href="group___a_d_c___interrupts___definition.html#gafceec649c4add8134490dfc4a775d94d">ADC_INT_ONE_SHOT_DONE</a>) == <a class="code" href="group__x3e___r_t_l876x___exported__types.html#gga89136caac2e14c55151f527ac02daaffa589b7d94a3d91d145720e2fed0eb3a05">RESET</a>);</div><div class="line"></div><div class="line"><span class="comment">/* Clear ADC_INT_ONE_SHOT_DONE interrupt */</span></div><div class="line"><a class="code" href="group___a_d_c___exported___functions.html#gad320b1104b81eea4d97308a2861bbae2">ADC_ClearINTPendingBit</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#ga54d148b91f3d356713f7e367a2243bea">ADC</a>, <a class="code" href="group___a_d_c___interrupts___definition.html#gafceec649c4add8134490dfc4a775d94d">ADC_INT_ONE_SHOT_DONE</a>);</div><div class="line"></div><div class="line"><span class="comment">/* ADC one shot sampling mode, read data from schedule table.</span></div><div class="line"><span class="comment">   The schedule table index which config in ADC init function.</span></div><div class="line"><span class="comment">   The value is 0 ~ 15 */</span></div><div class="line">data[0] = <a class="code" href="group__x3e___a_d_c___exported___functions.html#ga7c956aeecf00f7318272d4e0e2b0d8f6">ADC_Read</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#ga54d148b91f3d356713f7e367a2243bea">ADC</a>, 0);</div><div class="line">data[1] = <a class="code" href="group__x3e___a_d_c___exported___functions.html#ga7c956aeecf00f7318272d4e0e2b0d8f6">ADC_Read</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#ga54d148b91f3d356713f7e367a2243bea">ADC</a>, 1);</div><div class="line">data[2] = <a class="code" href="group__x3e___a_d_c___exported___functions.html#ga7c956aeecf00f7318272d4e0e2b0d8f6">ADC_Read</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#ga54d148b91f3d356713f7e367a2243bea">ADC</a>, 2);</div><div class="line"></div><div class="line"><span class="comment">/* Get conversion results based on data. The unit of the result is mV. */</span></div><div class="line">res[0] = <a class="code" href="group__x3e___a_d_c___exported___functions.html#gaf8ccd45223306ebcbbb314167fae5cfd">ADC_GetRes</a>(data[0], <a class="code" href="group___a_d_c__schedule__table.html#ga056869deda8f3480fd27e806f2e7799a">EXT_SINGLE_ENDED</a>(1));</div><div class="line">res[1] = <a class="code" href="group__x3e___a_d_c___exported___functions.html#gaf8ccd45223306ebcbbb314167fae5cfd">ADC_GetRes</a>(data[1], <a class="code" href="group___a_d_c__schedule__table.html#gae774ea9d3cd4353fe3517c7caaa437c1">INTERNAL_VBAT_MODE</a>);</div><div class="line">res[2] = <a class="code" href="group__x3e___a_d_c___exported___functions.html#gaf8ccd45223306ebcbbb314167fae5cfd">ADC_GetRes</a>(data[2], <a class="code" href="group___a_d_c__schedule__table.html#ga85224f9bb1ff197023bdffa776ff92af">INTERNAL_VADPIN_MODE</a>);</div></div><!-- fragment --><div class="image">
<img src="Turn_Off_Charger_on_the_McuConfig_Tool.jpg" alt="Turn_Off_Charger_on_the_McuConfig_Tool.jpg"/>
</div>
 <center><div id="figure_16_3"><b>Figure 16-3 Turn Off Charger on the McuConfig Tool</b></div></center><h4><a class="anchor" id="ADC_Interrupt_Mode"></a>
16.8.2  Interrupt Mode</h4>
<p>The flow of ADC sampling in one-shot mode by interrupt is shown in Figure 16-4.</p>
<div class="image">
<img src="ADC_One_Shot_Sampling_by_Interrupt_Mode.jpg" alt="ADC_One_Shot_Sampling_by_Interrupt_Mode.jpg"/>
</div>
 <center><div id="figure_16_4"><b>Figure 16-4 ADC One Shot Sampling by Interrupt Mode</b></div></center><p>The codes below show the flow of ADC sampling in one-shot mode by interrupt. For details, please refer to src\sample\io_demo\adc\one-shot\adc_demo.c</p>
<p><b>Note:</b> To use the method below, please turn off Charger auto enable and Battery detection support on the McuConfig Tool.</p>
<div class="fragment"><div class="line"><span class="comment">/* Bypass mode config, please notice that the input voltage of</span></div><div class="line"><span class="comment">   adc channel using bypass mode should not be over 0.9V */</span></div><div class="line"><a class="code" href="group__x3e___a_d_c___exported___functions.html#ga37bbbda47672f70b64cea22c05a01150">ADC_HighBypassCmd</a>(1, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line"></div><div class="line"><span class="comment">/* Enable ADC clock */</span></div><div class="line"><a class="code" href="group__x3e___r_c_c___exported___functions.html#ga0ff78e34dcddb1ed9a215ee66ccb2d1b">RCC_PeriphClockCmd</a>(<a class="code" href="group___a_p_b___peripheral___define.html#gaca53641683b97825117c40065f54aa41">APBPeriph_ADC</a>, <a class="code" href="group___r_c_c___peripheral___clock.html#ga6098f8487730394fe549a7bc36742e9c">APBPeriph_ADC_CLOCK</a>, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line"></div><div class="line"><a class="code" href="struct_a_d_c___init_type_def.html">ADC_InitTypeDef</a> adcInitStruct;</div><div class="line"><span class="comment">/* Fill each ADC_InitStruct member variable with its default value */</span></div><div class="line"><a class="code" href="group__x3e___a_d_c___exported___functions.html#gae11856cf4a6ae92766f91247c8811cd3">ADC_StructInit</a>(&amp;adcInitStruct);</div><div class="line"></div><div class="line"><span class="comment">/* Write the parameters into schedule table to set channel mode and channel number. */</span></div><div class="line">adcInitStruct.<a class="code" href="struct_a_d_c___init_type_def.html#a056154dd5de8b77c68387fdfcd339ae8">schIndex</a>[0] = <a class="code" href="group___a_d_c__schedule__table.html#ga056869deda8f3480fd27e806f2e7799a">EXT_SINGLE_ENDED</a>(0);;</div><div class="line">adcInitStruct.<a class="code" href="struct_a_d_c___init_type_def.html#a056154dd5de8b77c68387fdfcd339ae8">schIndex</a>[1] = <a class="code" href="group___a_d_c__schedule__table.html#ga056869deda8f3480fd27e806f2e7799a">EXT_SINGLE_ENDED</a>(1);</div><div class="line">adcInitStruct.<a class="code" href="struct_a_d_c___init_type_def.html#a056154dd5de8b77c68387fdfcd339ae8">schIndex</a>[2] = <a class="code" href="group___a_d_c__schedule__table.html#gae774ea9d3cd4353fe3517c7caaa437c1">INTERNAL_VBAT_MODE</a>;</div><div class="line">adcInitStruct.<a class="code" href="struct_a_d_c___init_type_def.html#a056154dd5de8b77c68387fdfcd339ae8">schIndex</a>[3] = <a class="code" href="group___a_d_c__schedule__table.html#ga85224f9bb1ff197023bdffa776ff92af">INTERNAL_VADPIN_MODE</a>;</div><div class="line"><span class="comment">/* Set bitmap, schIndex[0] ~ schIndex[15] corresponding to bit0 ~ bit15 of bitmap.</span></div><div class="line"><span class="comment">   If the specific bit of bitmap is set to 1, it means that the schedule table corresponding to this bit is enabled.</span></div><div class="line"><span class="comment">   For example, if config schIndex[0] and schIndex [1], then bitmap is 0000 0000 0011 (that is, 0x0003),</span></div><div class="line"><span class="comment">   if config schIndex [0] and schIndex [2], then bitmap is 0000 0000 0101 (that is, 0x0005).</span></div><div class="line"><span class="comment">   After ADC is enabled, ADC will sample successively according to the mode configured in the enabled schedule table.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">adcInitStruct.<a class="code" href="struct_a_d_c___init_type_def.html#a02b2be7b8ce086893453d390c5fdcf1d">bitmap</a> = 0x0f;</div><div class="line"><span class="comment">/* Initialize ADC */</span></div><div class="line"><a class="code" href="group__x3e___a_d_c___exported___functions.html#ga4b79b2802cf9788debd310ffa9bea0db">ADC_Init</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#ga54d148b91f3d356713f7e367a2243bea">ADC</a>, &amp;adcInitStruct);</div><div class="line"></div><div class="line"><span class="comment">/* Enable ADC one shot mode done interrupt */</span></div><div class="line"><a class="code" href="group___a_d_c___exported___functions.html#ga2c6af6a81dc97f93e31fe3c95127bb69">ADC_INTConfig</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#ga54d148b91f3d356713f7e367a2243bea">ADC</a>, <a class="code" href="group___a_d_c___interrupts___definition.html#gafceec649c4add8134490dfc4a775d94d">ADC_INT_ONE_SHOT_DONE</a>, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line"></div><div class="line"><span class="comment">/* Enable NVIC of ADC */</span></div><div class="line"><a class="code" href="struct_n_v_i_c___init_type_def.html">NVIC_InitTypeDef</a> NVIC_InitStruct;</div><div class="line">NVIC_InitStruct.<a class="code" href="struct_n_v_i_c___init_type_def.html#a921af0ab04e071d7d276c003e0048123">NVIC_IRQChannel</a> = <a class="code" href="group__x3e___r_t_l876x___exported__types.html#gga666eb0caeb12ec0e281415592ae89083a4d69175258ae261dd545001e810421b3">ADC_IRQn</a>;</div><div class="line">NVIC_InitStruct.<a class="code" href="struct_n_v_i_c___init_type_def.html#acd582bc2edce30e9d7ab5e0ede400f36">NVIC_IRQChannelPriority</a> = 2;</div><div class="line">NVIC_InitStruct.<a class="code" href="struct_n_v_i_c___init_type_def.html#a3c5567ef024a0489884083c88f17b4d5">NVIC_IRQChannelCmd</a> = <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>;</div><div class="line"><a class="code" href="group__x3e___n_v_i_c___exported___functions.html#ga4e06b4f5c9109d6bc8990adf77e5f8d3">NVIC_Init</a>(&amp;NVIC_InitStruct);</div><div class="line"></div><div class="line"><span class="comment">/* Enable ADC one shot sampling.</span></div><div class="line"><span class="comment">   When ADC is enabled, sampling will be done quickly and interruption will occur.</span></div><div class="line"><span class="comment">   After initialization, ADC can be enabled when sampling is needed. */</span></div><div class="line"><a class="code" href="group__x3e___a_d_c___exported___functions.html#ga866ea1f65d482f8d1846a79724caa7b0">ADC_Cmd</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#ga54d148b91f3d356713f7e367a2243bea">ADC</a>, <a class="code" href="group___a_d_c__operation___mode.html#ga3cbe42ba0befbfa2511e0b3fb667632a">ADC_One_Shot_Mode</a>, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div></div><!-- fragment --><p>ADC interrupt handle flow is shown in Figure 16-5.</p>
<div class="image">
<img src="ADC_Interrupt_Handle_Flow_1.jpg" alt="ADC_Interrupt_Handle_Flow_1.jpg"/>
</div>
 <center><div id="figure_16_5"><b>Figure 16-5 ADC Interrupt Handle Flow</b></div></center><p>The codes below show ADC interrupt handle flow. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> adc_handler(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    int32_t data[4];</div><div class="line">    int32_t res[4];</div><div class="line"></div><div class="line">    <span class="comment">/* Check ADC_INT_ONE_SHOT_DONE interrupt status flag */</span></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group___a_d_c___exported___functions.html#ga81a5a5bf5157fe6e167c217d81b193b8">ADC_GetIntFlagStatus</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#ga54d148b91f3d356713f7e367a2243bea">ADC</a>, <a class="code" href="group___a_d_c___interrupts___definition.html#gafceec649c4add8134490dfc4a775d94d">ADC_INT_ONE_SHOT_DONE</a>) == <a class="code" href="group__x3e___r_t_l876x___exported__types.html#gga89136caac2e14c55151f527ac02daaffab44c8101cc294c074709ec1b14211792">SET</a>)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Clear ADC_INT_ONE_SHOT_DONE interrupt */</span></div><div class="line">        <a class="code" href="group___a_d_c___exported___functions.html#gad320b1104b81eea4d97308a2861bbae2">ADC_ClearINTPendingBit</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#ga54d148b91f3d356713f7e367a2243bea">ADC</a>, <a class="code" href="group___a_d_c___interrupts___definition.html#gafceec649c4add8134490dfc4a775d94d">ADC_INT_ONE_SHOT_DONE</a>);</div><div class="line">        <span class="comment">/* ADC one shot sampling mode, read data from schedule table.</span></div><div class="line"><span class="comment">           The schedule table index which config in adc init function.</span></div><div class="line"><span class="comment">           The value is 0 ~ 15 */</span></div><div class="line">        data[0] = <a class="code" href="group__x3e___a_d_c___exported___functions.html#ga7c956aeecf00f7318272d4e0e2b0d8f6">ADC_Read</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#ga54d148b91f3d356713f7e367a2243bea">ADC</a>, 0);</div><div class="line">        data[1] = <a class="code" href="group__x3e___a_d_c___exported___functions.html#ga7c956aeecf00f7318272d4e0e2b0d8f6">ADC_Read</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#ga54d148b91f3d356713f7e367a2243bea">ADC</a>, 1);</div><div class="line">        data[2] = <a class="code" href="group__x3e___a_d_c___exported___functions.html#ga7c956aeecf00f7318272d4e0e2b0d8f6">ADC_Read</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#ga54d148b91f3d356713f7e367a2243bea">ADC</a>, 2);</div><div class="line">        data[3] = <a class="code" href="group__x3e___a_d_c___exported___functions.html#ga7c956aeecf00f7318272d4e0e2b0d8f6">ADC_Read</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#ga54d148b91f3d356713f7e367a2243bea">ADC</a>, 3);</div><div class="line">        <span class="comment">/* Get conversion results based on data. The unit of the result is mV. */</span></div><div class="line">        res[0] = <a class="code" href="group__x3e___a_d_c___exported___functions.html#gaf8ccd45223306ebcbbb314167fae5cfd">ADC_GetRes</a>(data[0], <a class="code" href="group___a_d_c__schedule__table.html#ga056869deda8f3480fd27e806f2e7799a">EXT_SINGLE_ENDED</a>(0));</div><div class="line">        res[1] = <a class="code" href="group__x3e___a_d_c___exported___functions.html#gaf80fe38291ff9c94eb5ffb552f164d4e">ADC_GetHighBypassRes</a>(data[1], <a class="code" href="group___a_d_c__schedule__table.html#ga056869deda8f3480fd27e806f2e7799a">EXT_SINGLE_ENDED</a>(1));</div><div class="line">        res[2] = <a class="code" href="group__x3e___a_d_c___exported___functions.html#gaf8ccd45223306ebcbbb314167fae5cfd">ADC_GetRes</a>(data[2], <a class="code" href="group___a_d_c__schedule__table.html#gae774ea9d3cd4353fe3517c7caaa437c1">INTERNAL_VBAT_MODE</a>);</div><div class="line">        res[3] = <a class="code" href="group__x3e___a_d_c___exported___functions.html#gaf8ccd45223306ebcbbb314167fae5cfd">ADC_GetRes</a>(data[3], <a class="code" href="group___a_d_c__schedule__table.html#ga85224f9bb1ff197023bdffa776ff92af">INTERNAL_VADPIN_MODE</a>);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h4><a class="anchor" id="ADC_Hardware_Average_Mode"></a>
16.8.3  Hardware Average Mode</h4>
<p>ADC hardware average function can only be used in one shot mode and only schedule table 0 can be used. For RTL87X3E, it is recommended to use the hardware average function. The flow of ADC sampling in one-shot mode by hardware average is shown in Figure 16-6.</p>
<div class="image">
<img src="ADC_One_Shot_Sampling_by_Hardware_Average_Mode.jpg" alt="ADC_One_Shot_Sampling_by_Hardware_Average_Mode.jpg"/>
</div>
 <center><div id="figure_16_6"><b>Figure 16-6 ADC One Shot Sampling by Hardware Average Mode</b></div></center><p>The codes below show the flow of ADC sampling in one-shot mode by hardware average. For details, please refer to src\sample\io_demo\adc\adc_hw_average\adc_hw_average_demo.c</p>
<p><b>Note:</b> To use the method below, please turn off Charger auto enable and Battery detection support on the McuConfig Tool.</p>
<div style="page-break-after: always;"></div><div class="fragment"><div class="line"><span class="comment">/* Enable ADC clock */</span></div><div class="line"><a class="code" href="group__x3e___r_c_c___exported___functions.html#ga0ff78e34dcddb1ed9a215ee66ccb2d1b">RCC_PeriphClockCmd</a>(<a class="code" href="group___a_p_b___peripheral___define.html#gaca53641683b97825117c40065f54aa41">APBPeriph_ADC</a>, <a class="code" href="group___r_c_c___peripheral___clock.html#ga6098f8487730394fe549a7bc36742e9c">APBPeriph_ADC_CLOCK</a>, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line"></div><div class="line"><a class="code" href="struct_a_d_c___init_type_def.html">ADC_InitTypeDef</a> adc_init_struct;</div><div class="line"><span class="comment">/* Fill each ADC_InitStruct member variable with its default value */</span></div><div class="line"><a class="code" href="group__x3e___a_d_c___exported___functions.html#gae11856cf4a6ae92766f91247c8811cd3">ADC_StructInit</a>(&amp;adc_init_struct);</div><div class="line"></div><div class="line"><span class="comment">/* When hardware average function is enabled, ADC can only use schedule table 0 */</span></div><div class="line">adc_init_struct.<a class="code" href="struct_a_d_c___init_type_def.html#a056154dd5de8b77c68387fdfcd339ae8">schIndex</a>[0] = <a class="code" href="group___a_d_c__schedule__table.html#ga056869deda8f3480fd27e806f2e7799a">EXT_SINGLE_ENDED</a>(1);</div><div class="line">adc_init_struct.<a class="code" href="struct_a_d_c___init_type_def.html#a02b2be7b8ce086893453d390c5fdcf1d">bitmap</a> = 0x01;</div><div class="line"><span class="comment">/* Initialize ADC */</span></div><div class="line"><a class="code" href="group__x3e___a_d_c___exported___functions.html#ga4b79b2802cf9788debd310ffa9bea0db">ADC_Init</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#ga54d148b91f3d356713f7e367a2243bea">ADC</a>, &amp;adc_init_struct);</div><div class="line"></div><div class="line"><span class="comment">/* Enable ADC hardware average function */</span></div><div class="line"><a class="code" href="group___a_d_c___exported___functions.html#gac39fc029def1478f8e7198bce49b6d64">ADC_HwEvgEn</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#ga54d148b91f3d356713f7e367a2243bea">ADC</a>, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line"><span class="comment">/* Set the hardware average number of times */</span></div><div class="line"><a class="code" href="group___a_d_c___exported___functions.html#gae1f481c34030d7d285b5d3395e885858">ADC_HwEvgSel</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#ga54d148b91f3d356713f7e367a2243bea">ADC</a>, <a class="code" href="group__x3e___a_d_c___clock___config.html#gga638f033cfb55912d7726c0c4a8b4b4b0a2c2e69031320206185ad3905f09612af">ADC_DTAT_AVG_SEL_BY32</a>);</div><div class="line"></div><div class="line"><span class="comment">/* Enable ADC one shot mode done interrupt */</span></div><div class="line"><a class="code" href="group___a_d_c___exported___functions.html#ga2c6af6a81dc97f93e31fe3c95127bb69">ADC_INTConfig</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#ga54d148b91f3d356713f7e367a2243bea">ADC</a>, <a class="code" href="group___a_d_c___interrupts___definition.html#gafceec649c4add8134490dfc4a775d94d">ADC_INT_ONE_SHOT_DONE</a>, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line"></div><div class="line"><span class="comment">/* Enable NVIC of ADC */</span></div><div class="line"><a class="code" href="struct_n_v_i_c___init_type_def.html">NVIC_InitTypeDef</a> NVIC_InitStruct;</div><div class="line">NVIC_InitStruct.<a class="code" href="struct_n_v_i_c___init_type_def.html#a921af0ab04e071d7d276c003e0048123">NVIC_IRQChannel</a> = <a class="code" href="group__x3e___r_t_l876x___exported__types.html#gga666eb0caeb12ec0e281415592ae89083a4d69175258ae261dd545001e810421b3">ADC_IRQn</a>;</div><div class="line">NVIC_InitStruct.<a class="code" href="struct_n_v_i_c___init_type_def.html#acd582bc2edce30e9d7ab5e0ede400f36">NVIC_IRQChannelPriority</a> = 3;</div><div class="line">NVIC_InitStruct.<a class="code" href="struct_n_v_i_c___init_type_def.html#a3c5567ef024a0489884083c88f17b4d5">NVIC_IRQChannelCmd</a> = <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>;</div><div class="line"><a class="code" href="group__x3e___n_v_i_c___exported___functions.html#ga4e06b4f5c9109d6bc8990adf77e5f8d3">NVIC_Init</a>(&amp;NVIC_InitStruct);</div><div class="line"></div><div class="line"><span class="comment">/* Enable ADC one shot sampling.</span></div><div class="line"><span class="comment">   When ADC is enabled, sampling will be done quickly and interruption will occur.</span></div><div class="line"><span class="comment">   After initialization, ADC can be enabled when sampling is needed. */</span></div><div class="line"><a class="code" href="group__x3e___a_d_c___exported___functions.html#ga866ea1f65d482f8d1846a79724caa7b0">ADC_Cmd</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#ga54d148b91f3d356713f7e367a2243bea">ADC</a>, <a class="code" href="group___a_d_c__operation___mode.html#ga3cbe42ba0befbfa2511e0b3fb667632a">ADC_One_Shot_Mode</a>, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div></div><!-- fragment --><p>ADC interrupt handle flow is shown in Figure 16-7.</p>
<div class="image">
<img src="ADC_Interrupt_Handle_Flow_2.jpg" alt="ADC_Interrupt_Handle_Flow_2.jpg"/>
</div>
 <center><div id="figure_16_7"><b>Figure 16-7 ADC Interrupt Handle Flow</b></div></center><p>The codes below show ADC interrupt handle flow. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> adc_handler(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    int32_t data;</div><div class="line">    int32_t result;</div><div class="line"></div><div class="line">    <span class="comment">/* Check ADC_INT_ONE_SHOT_DONE interrupt status flag */</span></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group___a_d_c___exported___functions.html#ga81a5a5bf5157fe6e167c217d81b193b8">ADC_GetIntFlagStatus</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#ga54d148b91f3d356713f7e367a2243bea">ADC</a>, <a class="code" href="group___a_d_c___interrupts___definition.html#gafceec649c4add8134490dfc4a775d94d">ADC_INT_ONE_SHOT_DONE</a>) == <a class="code" href="group__x3e___r_t_l876x___exported__types.html#gga89136caac2e14c55151f527ac02daaffab44c8101cc294c074709ec1b14211792">SET</a>)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Clear ADC_INT_ONE_SHOT_DONE interrupt */</span></div><div class="line">        <a class="code" href="group___a_d_c___exported___functions.html#gad320b1104b81eea4d97308a2861bbae2">ADC_ClearINTPendingBit</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#ga54d148b91f3d356713f7e367a2243bea">ADC</a>, <a class="code" href="group___a_d_c___interrupts___definition.html#gafceec649c4add8134490dfc4a775d94d">ADC_INT_ONE_SHOT_DONE</a>);</div><div class="line">        <span class="comment">/* Read ADC data */</span></div><div class="line">        data = <a class="code" href="group___a_d_c___exported___functions.html#ga77a2174cfb13b203b91f182d0fcd7707">ADC_HwEvgRead</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#ga54d148b91f3d356713f7e367a2243bea">ADC</a>);</div><div class="line">        <span class="comment">/* Get conversion results based on data. The unit of the result is mV. */</span></div><div class="line">        result = <a class="code" href="group__x3e___a_d_c___exported___functions.html#gaf8ccd45223306ebcbbb314167fae5cfd">ADC_GetRes</a>(data, <a class="code" href="group___a_d_c__schedule__table.html#ga056869deda8f3480fd27e806f2e7799a">EXT_SINGLE_ENDED</a>(1));</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h4><a class="anchor" id="ADC_Manager_Mode"></a>
16.8.4  ADC Manager Mode</h4>
<p>The flow of ADC sampling in one-shot mode by adc manager is shown in Figure 16-8.</p>
<div class="image">
<img src="ADC_One_Shot_Sampling_by_ADC_Manager_Mode.jpg" alt="ADC_One_Shot_Sampling_by_ADC_Manager_Mode.jpg"/>
</div>
 <center><div id="figure_16_8"><b>Figure 16-8 ADC One Shot Sampling by ADC Manager Mode</b></div></center><p>The codes below show the flow of ADC sampling in one-shot mode by adc manager. For details, please refer to src\sample\io_demo\adc\adc_charger_demo\adc_charger_demo.c and src\sample\io_demo\adc\adc_manger\adc_manager_demo.c</p>
<p><b>Note:</b> To use the method below, please turn on Charger auto enable and Battery detection support on the McuConfig Tool.</p>
<div style="page-break-after: always;"></div><div class="fragment"><div class="line"><span class="comment">/* Bypass mode config, please notice that the input voltage of</span></div><div class="line"><span class="comment">   adc channel using bypass mode should not be over 0.9V */</span></div><div class="line"><a class="code" href="group__x3e___a_d_c___exported___functions.html#ga37bbbda47672f70b64cea22c05a01150">ADC_HighBypassCmd</a>(0, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line"><a class="code" href="group__x3e___a_d_c___exported___functions.html#ga37bbbda47672f70b64cea22c05a01150">ADC_HighBypassCmd</a>(1, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line"></div><div class="line"><a class="code" href="struct_a_d_c___init_type_def.html">ADC_InitTypeDef</a> ADC_InitStruct;</div><div class="line"><span class="comment">/* Fill each ADC_InitStruct member variable with its default value */</span></div><div class="line"><a class="code" href="group__x3e___a_d_c___exported___functions.html#gae11856cf4a6ae92766f91247c8811cd3">ADC_StructInit</a>(&amp;ADC_InitStruct);</div><div class="line"></div><div class="line"><span class="comment">/* Set bitmap, schIndex[0] ~ schIndex[15] corresponding to bit0 ~ bit15 of bitmap. </span></div><div class="line"><span class="comment">   If the specific bit of bitmap is set to 1, it means that the schedule table corresponding to this bit is enabled.</span></div><div class="line"><span class="comment">   For example, if config schIndex[0] and schIndex [1], then bitmap is 0000 0000 0011 (that is, 0x0003),</span></div><div class="line"><span class="comment">   if config schIndex [0] and schIndex [2], then bitmap is 0000 0000 0101 (that is, 0x0005).</span></div><div class="line"><span class="comment">   After ADC is enabled, ADC will sample successively according to the mode configured in the enabled schedule table.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">ADC_InitStruct.<a class="code" href="struct_a_d_c___init_type_def.html#a02b2be7b8ce086893453d390c5fdcf1d">bitmap</a> = 0x0007;</div><div class="line"><span class="comment">/* Write the parameters into schedule table to set channel mode and channel number. */</span></div><div class="line">ADC_InitStruct.<a class="code" href="struct_a_d_c___init_type_def.html#a056154dd5de8b77c68387fdfcd339ae8">schIndex</a>[0] = <a class="code" href="group___a_d_c__schedule__table.html#ga056869deda8f3480fd27e806f2e7799a">EXT_SINGLE_ENDED</a>(0);</div><div class="line">ADC_InitStruct.<a class="code" href="struct_a_d_c___init_type_def.html#a056154dd5de8b77c68387fdfcd339ae8">schIndex</a>[1] = <a class="code" href="group___a_d_c__schedule__table.html#ga056869deda8f3480fd27e806f2e7799a">EXT_SINGLE_ENDED</a>(1);</div><div class="line">ADC_InitStruct.<a class="code" href="struct_a_d_c___init_type_def.html#a056154dd5de8b77c68387fdfcd339ae8">schIndex</a>[2] = <a class="code" href="group___a_d_c__schedule__table.html#gae774ea9d3cd4353fe3517c7caaa437c1">INTERNAL_VBAT_MODE</a>;</div><div class="line"></div><div class="line"><span class="comment">/* Request for a channel in ADC manager */</span></div><div class="line"><span class="keywordflow">if</span> (!<a class="code" href="group__x3e___a_d_c___m_a_n_a_g_e_r___exported___functions.html#ga2be5a7b77f49c65671bf25891c48e6f4">adc_mgr_register_req</a>(&amp;ADC_InitStruct,</div><div class="line">                              (<a class="code" href="group___a_d_c___m_a_n_a_g_e_r___exported___types.html#ga8a66d0cddd729f870ffe7df4d6fc7ce1">adc_callback_function_t</a>)app_adc_vbat_ntc_voltage_read_callback,</div><div class="line">                              &amp;adc_channel_vbat_ntc_voltage))</div><div class="line">{</div><div class="line">    IO_PRINT_ERROR0(<span class="stringliteral">&quot;app_adc_vbat_ntc_voltage_init: adc_mgr_register_req failed&quot;</span>);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* Enable the specific ADC manager channel for sampling */</span></div><div class="line"><a class="code" href="group__x3e___a_d_c___m_a_n_a_g_e_r___exported___functions.html#gaa50b41c4821dcddbae2a2d868ceb7eb9">adc_mgr_enable_req</a>(adc_channel_vbat_ntc_voltage);</div></div><!-- fragment --><p>ADC manager callback handle flow is shown in Figure 16-9.</p>
<div class="image">
<img src="ADC_Manager_Callback_Handle_Flow.jpg" alt="ADC_Manager_Callback_Handle_Flow.jpg"/>
</div>
 <center><div id="figure_16_9"><b>Figure 16-9 ADC Manager Callback Handle Flow</b></div></center><p>The codes below show ADC manager callback handle flow. </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> app_adc_vbat_ntc_voltage_read_callback(<span class="keywordtype">void</span> *pvPara, uint32_t int_status)</div><div class="line">{</div><div class="line">    uint16_t adc_data[3];</div><div class="line">    uint16_t sched_bit_map = 0x0007;</div><div class="line"></div><div class="line">    <span class="comment">/* Read ADC sampling data of the specific ADC manager channel */</span></div><div class="line">    <a class="code" href="group___a_d_c___m_a_n_a_g_e_r___exported___functions.html#ga30c669478504a2ad95d346e736262a97">adc_mgr_read_data_req</a>(adc_channel_vbat_ntc_voltage, adc_data, sched_bit_map);</div><div class="line"></div><div class="line">    <span class="comment">/* Get conversion results based on data. The unit of the result is mV. */</span></div><div class="line">    adc_charger_data_mgr.temperature_battery_1 = <a class="code" href="group__x3e___a_d_c___exported___functions.html#gaf80fe38291ff9c94eb5ffb552f164d4e">ADC_GetHighBypassRes</a>(adc_data[0], <a class="code" href="group___a_d_c__schedule__table.html#ga056869deda8f3480fd27e806f2e7799a">EXT_SINGLE_ENDED</a>(0));</div><div class="line">    adc_charger_data_mgr.temperature_battery_2 = <a class="code" href="group__x3e___a_d_c___exported___functions.html#gaf80fe38291ff9c94eb5ffb552f164d4e">ADC_GetHighBypassRes</a>(adc_data[1], <a class="code" href="group___a_d_c__schedule__table.html#ga056869deda8f3480fd27e806f2e7799a">EXT_SINGLE_ENDED</a>(1));</div><div class="line">    adc_charger_data_mgr.voltage_battery = <a class="code" href="group__x3e___a_d_c___exported___functions.html#gaf8ccd45223306ebcbbb314167fae5cfd">ADC_GetRes</a>(adc_data[2], <a class="code" href="group___a_d_c__schedule__table.html#gae774ea9d3cd4353fe3517c7caaa437c1">INTERNAL_VBAT_MODE</a>);</div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="ADC_Continuous_Mode_Operation_Flow"></a>
16.9  ADC Continuous Mode Operation Flow</h3>
<h4><a class="anchor" id="ADC_DMA_Mode"></a>
16.9.1  DMA Mode</h4>
<p>The flow of ADC sampling in continuous mode by DMA is shown in Figure 16-10.</p>
<div class="image">
<img src="ADC_Continuous_Sampling_by_DMA_Mode.jpg" alt="ADC_Continuous_Sampling_by_DMA_Mode.jpg"/>
</div>
 <center><div id="figure_16_10"><b>Figure 16-10 ADC Continuous Sampling by DMA Mode</b></div></center><p>The codes below show the flow of ADC sampling in continuous mode by DMA. For details, please refer to src\sample\io_demo\gdma\adc_dma\adc_gdma_demo.c</p>
<p><b>Note:</b></p><ol type="1">
<li>To use the method below, please turn off Charger auto enable and Battery detection support on the McuConfig Tool.</li>
<li>Please refer to src\sample\io_demo\adc\adc_continuous_mode\adc_continuous_mode_demo.c for use of internal charger and ADC continuous sampling mode at the same time.</li>
</ol>
<div style="page-break-after: always;"></div><div class="fragment"><div class="line"><span class="comment">/* Enable ADC clock */</span></div><div class="line"><a class="code" href="group__x3e___r_c_c___exported___functions.html#ga0ff78e34dcddb1ed9a215ee66ccb2d1b">RCC_PeriphClockCmd</a>(<a class="code" href="group___a_p_b___peripheral___define.html#gaca53641683b97825117c40065f54aa41">APBPeriph_ADC</a>, <a class="code" href="group___r_c_c___peripheral___clock.html#ga6098f8487730394fe549a7bc36742e9c">APBPeriph_ADC_CLOCK</a>, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line"></div><div class="line"><a class="code" href="struct_a_d_c___init_type_def.html">ADC_InitTypeDef</a> adc_init_struct;</div><div class="line"><span class="comment">/* Fill each ADC_InitStruct member variable with its default value */</span></div><div class="line"><a class="code" href="group__x3e___a_d_c___exported___functions.html#gae11856cf4a6ae92766f91247c8811cd3">ADC_StructInit</a>(&amp;adc_init_struct);</div><div class="line"></div><div class="line"><span class="comment">/* Write the parameters into schedule table to set channel mode and channel number. */</span></div><div class="line">adc_init_struct.<a class="code" href="struct_a_d_c___init_type_def.html#a056154dd5de8b77c68387fdfcd339ae8">schIndex</a>[0] = <a class="code" href="group___a_d_c__schedule__table.html#ga056869deda8f3480fd27e806f2e7799a">EXT_SINGLE_ENDED</a>(0);</div><div class="line"><span class="comment">/* Set bitmap, schIndex[0] ~ schIndex[15] corresponding to bit0 ~ bit15 of bitmap.</span></div><div class="line"><span class="comment">   If the specific bit of bitmap is set to 1, it means that the schedule table corresponding to this bit is enabled.</span></div><div class="line"><span class="comment">   For example, if config schIndex[0] and schIndex [1], then bitmap is 0000 0000 0011 (that is, 0x0003),</span></div><div class="line"><span class="comment">   if config schIndex [0] and schIndex [2], then bitmap is 0000 0000 0101 (that is, 0x0005).</span></div><div class="line"><span class="comment">   After ADC is enabled, ADC will sample successively according to the mode configured in the enabled schedule table.</span></div><div class="line"><span class="comment">    */</span></div><div class="line">adc_init_struct.<a class="code" href="struct_a_d_c___init_type_def.html#a02b2be7b8ce086893453d390c5fdcf1d">bitmap</a> = 0x01;</div><div class="line"><span class="comment">/* Set burst size to trigger DMA request */</span></div><div class="line">adc_init_struct.<a class="code" href="struct_a_d_c___init_type_def.html#a21d921b8a2ba6bd29aa4753b49a3a629">adcBurstSize</a> = 8;</div><div class="line"><span class="comment">/* Initialize ADC */</span></div><div class="line"><a class="code" href="group__x3e___a_d_c___exported___functions.html#ga4b79b2802cf9788debd310ffa9bea0db">ADC_Init</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#ga54d148b91f3d356713f7e367a2243bea">ADC</a>, &amp;adc_init_struct);</div></div><!-- fragment --><div style="page-break-after: always;"></div><h2><a class="anchor" id="SLEEP_LED"></a>
17  SLEEP LED</h2>
<h3><a class="anchor" id="SLEEP_LED_Demo_Code_Support_List"></a>
17.1 SLEEP LED Demo Code Support List</h3>
<center><div id="table_17_1"><b>Table 17-1 SLEEP LED Sample Code 1 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 1  </th><th class="markdownTableHeadNone">sleep_led_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:180px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:670px">Demonstrate SLEEP LED breathe mode.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\led\sleep_led_demo.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">sleep_led_breathe_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Phase0 Parameters  </td><td class="markdownTableBodyNone">Duty update time:10ms; Phase0 output time:500ms;<br />
Initial high level time:0; Duty step time:0.03125ms;<br />
Change direction:increase   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Phase1 Parameters  </td><td class="markdownTableBodyNone">Duty update time:10ms; Phase1 output time:500ms;<br />
Initial high level time:3.125ms; Duty step time:0.0625ms;<br />
Change direction:increase   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Phase2 Parameters  </td><td class="markdownTableBodyNone">Duty update time:10ms; Phase2 output time:500ms;<br />
Initial high level time:6.25ms; Duty step time:0.09375ms;<br />
Change direction:increase   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Phase3 Parameters  </td><td class="markdownTableBodyNone">Duty update time:10ms; Phase3 output time:500ms;<br />
Initial high level time:9.375ms; Duty step time:0.125ms;<br />
Change direction:increase   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Phase4 Parameters  </td><td class="markdownTableBodyNone">Duty update time:10ms; Phase4 output time:500ms;<br />
Initial high level time:9.375ms; Duty step time:0.03125ms;<br />
Change direction:decrease   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Phase5 Parameters  </td><td class="markdownTableBodyNone">Duty update time:10ms; Phase5 output time:500ms;<br />
Initial high level time:6.25ms; Duty step time:0.0625ms;<br />
Change direction:decrease   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Phase6 Parameters  </td><td class="markdownTableBodyNone">Duty update time:10ms; Phase6 output time:500ms;<br />
Initial high level time:3.125ms; Duty step time:0.09375ms;<br />
Change direction:decrease   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Phase7 Parameters  </td><td class="markdownTableBodyNone">Duty update time:10ms; Phase7 output time:500ms;<br />
Initial high level time:0; Duty step time:0;<br />
Change direction:decrease   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">As shown in Figure 17-1. On EVB, connect M0_1 to LED1 and connect M2_1 to <br />
LED2 and connect M2_2 to LED3.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">LEDs turn from dark to bright and then from bright to dark in breathe mode.   </td></tr>
</table>
<div style="page-break-after: always;"></div><center><div id="table_17_2"><b>Table 17-2 SLEEP LED Sample Code 2 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 2  </th><th class="markdownTableHeadNone">sleep_led_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:180px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:670px">Demonstrate SLEEP LED blink mode.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\led\sleep_led_demo.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">sleep_led_blink_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Period Parameters  </td><td class="markdownTableBodyNone">Channel0:period0, period1 and period2 high level time is 200ms, period0, period1 <br />
and period2 low level time is 100ms.<br />
Channel1: period0 and period1 high level time is 200ms, period0 and period1 low <br />
level time is 100ms, period2 high level and low level time are 0.<br />
Channel2: period0 high level time is 200ms, period0 low level time is 100ms, period1 and period2 high level and low level time are 0.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">As shown in Figure 17-1. On EVB, connect M0_1 to LED1 and connect M2_1 to <br />
LED2 and connect M2_2 to LED3.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">LEDs Blink with 200ms on and 100ms off.   </td></tr>
</table>
<div class="image">
<img src="SLEEP_LED_Demo_Hardware_Connection_Diagrame.jpg" alt="SLEEP_LED_Demo_Hardware_Connection_Diagrame.jpg"/>
</div>
 <center><div id="figure_17_1"><b>Figure 17-1 SLEEP LED Demo Hardware Connection Diagrame</b></div></center><h3><a class="anchor" id="SLEEP_LED_Function_Description"></a>
17.2  Function Description</h3>
<p>SLEEP LED is used to control LED to make the effect of blinking light or breathing light.</p>
<h3><a class="anchor" id="SLEEP_LED_Feature_List"></a>
17.3  Feature List</h3>
<ul>
<li>Support three channels</li>
<li>Support blink mode and breathe mode</li>
<li>32KHz clock source</li>
<li>3 periods per channel in blink mode</li>
<li>8 phases per channel in breathe mode</li>
<li>Support output level setting in idle state</li>
<li>Support reverse output function</li>
<li>Support bypass</li>
</ul>
<p><b>Note:</b> If a default pull-up pin (P1_0/P1_1/P2_0/P3_0/P3_1) is set as a high active LED, or any other pull-down pin is set as a low active LED, it will blink when system boots.</p>
<h3><a class="anchor" id="SLEEP_LED_Blink_Mode"></a>
17.4  Blink Mode</h3>
<p>In blink mode, one channel is divided into three periods. As shown in Figure 17-2, it is executed sequentially from period0, and after the end of period2, it goes to period0 to continue the loop execution.</p>
<div style="page-break-after: always;"></div><div class="image">
<img src="Schematic_Diagram_of_SLEEP_LED_Blink_Mode.jpg" alt="Schematic_Diagram_of_SLEEP_LED_Blink_Mode.jpg"/>
</div>
 <center><div id="figure_17_2"><b>Figure 17-2 Schematic Diagram of SLEEP LED Blink Mode</b></div></center><p><b>Note:</b></p><ol type="1">
<li>period_timetick = prescale / 32000</li>
<li>period_x high level time = period_high[x] * period_timetick (x = 0,1,2)</li>
<li>period_x low level time = period_low[x] * period_timetick (x = 0,1,2)</li>
<li>If period_high[x] or period_low[x] is 0, this and subsequent periods are bypassed. For example, if period_high[2] is 0, period2 is bypassed, it is executed sequentially from period0, and after the end of period1, it goes to period0 to continue the loop execution.</li>
</ol>
<h3><a class="anchor" id="SLEEP_LED_Breathe_Mode"></a>
17.5  Breathe Mode</h3>
<p>In breathe mode, one channel is divided into eight phases. As shown in Figure 17-3, it is executed sequentially from phase0, and after the end of phase7, it goes to phase0 to continue the loop execution.</p>
<div class="image">
<img src="Schematic_Diagram_of_SLEEP_LED_Breathe_Mode.jpg" alt="Schematic_Diagram_of_SLEEP_LED_Breathe_Mode.jpg"/>
</div>
 <center><div id="figure_17_3"><b>Figure 17-3 Schematic Diagram of SLEEP LED Breathe Mode</b></div></center><p><b>Note:</b></p><ol type="1">
<li>phase_timetick = prescale / 32000</li>
<li>phase_uptate_rate[x]: duty update time = (phase_uptate_rate[x] + 1) * phase_timetick (x = 0,1,2,...,7)</li>
<li>phase_phase_tick[x]: The duration of the whole phase. phase_x output time = phase_phase_tick[x] * phase_timetick (x = 0,1,2,...,7)</li>
<li>phase_initial_duty[x]: initial high level time = phase_initial_duty[x] / 32000 (x = 0,1,2,...,7)</li>
<li>phase_increase_duty[x]: The direction of each change of duty. 1: increase duty. 0: decrease duty. (x = 0,1,2,...,7)</li>
<li>phase_duty_step[x]: duty step time = phase_duty_step[x] / 32000 (x = 0,1,2,...,7)</li>
<li>After high level time increase to phase_timetick, it remains at phase_timetick.</li>
<li>After high level time decrease to 0, it remains at 0.</li>
<li>Low level time = phase_timetick - high level time</li>
<li>If phase_phase_tick[x] is 0, this and subsequent phases are bypassed. For example, if phase_phase_tick[6] is 0, phase6 and phase7 are bypassed, it is executed sequentially from phase0, and after the end of phase5, it goes to phase0 to continue the loop execution.</li>
</ol>
<h3><a class="anchor" id="SLEEP_LED_Idle_State"></a>
17.6  Idle State</h3>
<p>Call API(SleepLed_SetIdleMode) to set whether the channel outputs high level or low level after the SLEEP LED is disabled.</p>
<h3><a class="anchor" id="SLEEP_LED_Reverse_Output_Function"></a>
17.7  Reverse Output Function</h3>
<p>Each channel of SLEEP LED supports the reverse function. After the reverse function is enabled, the original waveform is reversed and output, the actual waveform is opposite to the set value.</p>
<h3><a class="anchor" id="SLEEP_LED_Blink_Mode_Operation_Flow"></a>
17.8  Blink Mode Operation Flow</h3>
<p>The operation flow of SLEEP LED blink mode is shown in Figure 17-4.</p>
<div class="image">
<img src="SLEEP_LED_Blink_Mode_Flow_Chart.jpg" alt="SLEEP_LED_Blink_Mode_Flow_Chart.jpg"/>
</div>
 <center><div id="figure_17_4"><b>Figure 17-4 SLEEP LED Blink Mode Flow Chart</b></div></center><div style="page-break-after: always;"></div><p>The codes below show SLEEP LED blink mode operation flow. </p><div class="fragment"><div class="line"><span class="comment">/* Clear all the SLEEP LED registers to their default reset values */</span></div><div class="line"><a class="code" href="group___l_e_d___exported___functions.html#gac58735c0af968a6d9ccc5c2ba43b562a">SleepLed_Reset</a>();</div><div class="line"></div><div class="line"><a class="code" href="struct_s_l_e_e_p___l_e_d___init_type_def.html">SLEEP_LED_InitTypeDef</a> Led_Initsturcture;</div><div class="line"><span class="comment">/* Fill each SLEEP_LED_InitTypeDef member variable with its default value */</span></div><div class="line"><a class="code" href="group___l_e_d___exported___functions.html#ga753761bbfd776f9b9d112c30e3031f29">SleepLed_StructInit</a>(&amp;Led_Initsturcture);</div><div class="line"></div><div class="line"><span class="comment">/* Set SLEEP LED mode */</span></div><div class="line">Led_Initsturcture.<a class="code" href="struct_s_l_e_e_p___l_e_d___init_type_def.html#a37e90f5e3bd99fac2021fb3a326607d4">mode</a>                        = <a class="code" href="group___l_e_d__mode.html#ga26962abaee87983f2085b22c780acd73">LED_BLINK_MODE</a>;</div><div class="line"><span class="comment">/* Set reverse output function */</span></div><div class="line">Led_Initsturcture.<a class="code" href="struct_s_l_e_e_p___l_e_d___init_type_def.html#a2916d65ca772240e340b837b6d766cd8">polarity</a>                    = <a class="code" href="group___l_e_d___output__polarity.html#ga63cb03aeb5a92fde3643c2bcbf127790">LED_OUTPUT_NORMAL</a>;</div><div class="line"><span class="comment">/* Set clock division factor */</span></div><div class="line">Led_Initsturcture.<a class="code" href="struct_s_l_e_e_p___l_e_d___init_type_def.html#a45c8a8cc63f06422e161f41f601918db">prescale</a>                    = 32;</div><div class="line"><span class="comment">/* Set period0 high and low count value */</span></div><div class="line">Led_Initsturcture.<a class="code" href="struct_s_l_e_e_p___l_e_d___init_type_def.html#a6600930221a0fbfb3baf72b12932818f">period_high</a>[0]              = 200;</div><div class="line">Led_Initsturcture.<a class="code" href="struct_s_l_e_e_p___l_e_d___init_type_def.html#a92cefe4545a417e6951dac01651c9a05">period_low</a>[0]               = 100;</div><div class="line"><span class="comment">/* Set period1 high and low count value */</span></div><div class="line">Led_Initsturcture.<a class="code" href="struct_s_l_e_e_p___l_e_d___init_type_def.html#a6600930221a0fbfb3baf72b12932818f">period_high</a>[1]              = 200;</div><div class="line">Led_Initsturcture.<a class="code" href="struct_s_l_e_e_p___l_e_d___init_type_def.html#a92cefe4545a417e6951dac01651c9a05">period_low</a>[1]               = 100;</div><div class="line"><span class="comment">/* Set period2 high and low count value */</span></div><div class="line">Led_Initsturcture.<a class="code" href="struct_s_l_e_e_p___l_e_d___init_type_def.html#a6600930221a0fbfb3baf72b12932818f">period_high</a>[2]              = 200;</div><div class="line">Led_Initsturcture.<a class="code" href="struct_s_l_e_e_p___l_e_d___init_type_def.html#a92cefe4545a417e6951dac01651c9a05">period_low</a>[2]               = 100;</div><div class="line"><span class="comment">/* Initialize channel 0 */</span></div><div class="line"><a class="code" href="group___l_e_d___exported___functions.html#ga2d1ef997e7c882e1f8c0c488d7e848cd">SleepLed_Init</a>(<a class="code" href="group___l_e_d___exported___constants.html#gga0c32efc253c8d08276f94c0b57243d85ae34309ef93950bb061fbf0d1feccc19f">LED_CHANNEL_0</a>, &amp;Led_Initsturcture);</div><div class="line"></div><div class="line">Led_Initsturcture.<a class="code" href="struct_s_l_e_e_p___l_e_d___init_type_def.html#a6600930221a0fbfb3baf72b12932818f">period_high</a>[2]              = 0;</div><div class="line">Led_Initsturcture.<a class="code" href="struct_s_l_e_e_p___l_e_d___init_type_def.html#a92cefe4545a417e6951dac01651c9a05">period_low</a>[2]               = 0;</div><div class="line"><span class="comment">/* Initialize channel 1 */</span></div><div class="line"><a class="code" href="group___l_e_d___exported___functions.html#ga2d1ef997e7c882e1f8c0c488d7e848cd">SleepLed_Init</a>(<a class="code" href="group___l_e_d___exported___constants.html#gga0c32efc253c8d08276f94c0b57243d85abbd0cd725f476631275036f05d7b9475">LED_CHANNEL_1</a>, &amp;Led_Initsturcture);</div><div class="line"></div><div class="line">Led_Initsturcture.<a class="code" href="struct_s_l_e_e_p___l_e_d___init_type_def.html#a6600930221a0fbfb3baf72b12932818f">period_high</a>[1]              = 0;</div><div class="line">Led_Initsturcture.<a class="code" href="struct_s_l_e_e_p___l_e_d___init_type_def.html#a92cefe4545a417e6951dac01651c9a05">period_low</a>[1]               = 0;</div><div class="line"><span class="comment">/* Initialize channel 2 */</span></div><div class="line"><a class="code" href="group___l_e_d___exported___functions.html#ga2d1ef997e7c882e1f8c0c488d7e848cd">SleepLed_Init</a>(<a class="code" href="group___l_e_d___exported___constants.html#gga0c32efc253c8d08276f94c0b57243d85a1634c90c66301ab6b8bd1145a4a166e8">LED_CHANNEL_2</a>, &amp;Led_Initsturcture);</div><div class="line"><span class="comment">/* Enable Sleep led */</span></div><div class="line"><a class="code" href="group___l_e_d___exported___functions.html#ga4c3ebc49b46a59fd24ad555c0d107a83">SleepLed_Cmd</a>(<a class="code" href="group___l_e_d___exported___constants.html#gga0c32efc253c8d08276f94c0b57243d85abbd0cd725f476631275036f05d7b9475">LED_CHANNEL_1</a> | <a class="code" href="group___l_e_d___exported___constants.html#gga0c32efc253c8d08276f94c0b57243d85ae34309ef93950bb061fbf0d1feccc19f">LED_CHANNEL_0</a> | <a class="code" href="group___l_e_d___exported___constants.html#gga0c32efc253c8d08276f94c0b57243d85a1634c90c66301ab6b8bd1145a4a166e8">LED_CHANNEL_2</a>, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div></div><!-- fragment --><h3><a class="anchor" id="SLEEP_LED_Breathe_Mode_Operation_Flow"></a>
17.9  Breathe Mode Operation Flow</h3>
<p>The operation flow of SLEEP LED breathe mode is shown in Figure 17-5.</p>
<div class="image">
<img src="SLEEP_LED_Breathe_Mode_Flow_Chart.jpg" alt="SLEEP_LED_Breathe_Mode_Flow_Chart.jpg"/>
</div>
 <center><div id="figure_17_5"><b>Figure 17-5 SLEEP LED Breathe Mode Flow Chart</b></div></center><div style="page-break-after: always;"></div><p>The codes below show SLEEP LED breathe mode operation flow. </p><div class="fragment"><div class="line"><span class="comment">/* Clear all the Sleep LED registers to their default reset values */</span></div><div class="line"><a class="code" href="group___l_e_d___exported___functions.html#gac58735c0af968a6d9ccc5c2ba43b562a">SleepLed_Reset</a>();</div><div class="line"></div><div class="line"><a class="code" href="struct_s_l_e_e_p___l_e_d___init_type_def.html">SLEEP_LED_InitTypeDef</a> Led_Initsturcture;</div><div class="line"><span class="comment">/* Fill each SLEEP_LED_InitTypeDef member variable with its default value */</span></div><div class="line"><a class="code" href="group___l_e_d___exported___functions.html#ga753761bbfd776f9b9d112c30e3031f29">SleepLed_StructInit</a>(&amp;Led_Initsturcture);</div><div class="line"></div><div class="line"><span class="comment">/* Set clock division factor */</span></div><div class="line">Led_Initsturcture.<a class="code" href="struct_s_l_e_e_p___l_e_d___init_type_def.html#a45c8a8cc63f06422e161f41f601918db">prescale</a>                    = 320;</div><div class="line"><span class="comment">/* Set SLEEP LED mode */</span></div><div class="line">Led_Initsturcture.<a class="code" href="struct_s_l_e_e_p___l_e_d___init_type_def.html#a37e90f5e3bd99fac2021fb3a326607d4">mode</a>                        = <a class="code" href="group___l_e_d__mode.html#gab453d1554b7e464ef46d71c41a69feef">LED_BREATHE_MODE</a>;</div><div class="line"><span class="comment">/* Set reverse output function */</span></div><div class="line">Led_Initsturcture.<a class="code" href="struct_s_l_e_e_p___l_e_d___init_type_def.html#a2916d65ca772240e340b837b6d766cd8">polarity</a>                    = <a class="code" href="group___l_e_d___output__polarity.html#ga63cb03aeb5a92fde3643c2bcbf127790">LED_OUTPUT_NORMAL</a>;</div><div class="line"><span class="comment">/* Set duty update time */</span></div><div class="line">Led_Initsturcture.<a class="code" href="struct_s_l_e_e_p___l_e_d___init_type_def.html#af1f571ceb71d6764f33b8b6702d613b7">phase_uptate_rate</a>[0]              = 0;</div><div class="line"><span class="comment">/* Set the duration of the whole phase */</span></div><div class="line">Led_Initsturcture.<a class="code" href="struct_s_l_e_e_p___l_e_d___init_type_def.html#afc324c3d80af17b16e86aa891b1b0924">phase_phase_tick</a>[0]               = 50;</div><div class="line"><span class="comment">/* Set initial high level time */</span></div><div class="line">Led_Initsturcture.<a class="code" href="struct_s_l_e_e_p___l_e_d___init_type_def.html#a65ae26a2a025c66d7d51056ef3a6be16">phase_initial_duty</a>[0]             = 0;</div><div class="line"><span class="comment">/* Set the direction of each change of duty */</span></div><div class="line">Led_Initsturcture.<a class="code" href="struct_s_l_e_e_p___l_e_d___init_type_def.html#a1459db0e698faf337c7b34c60db2f168">phase_increase_duty</a>[0]            = 1;</div><div class="line"><span class="comment">/* Set duty step when duty is updated */</span></div><div class="line">Led_Initsturcture.<a class="code" href="struct_s_l_e_e_p___l_e_d___init_type_def.html#a78e27876a51ccdb5fc15b4f6572c9e78">phase_duty_step</a>[0]                = 1;</div><div class="line"></div><div class="line"><span class="comment">/* Set phase1 parameters */</span></div><div class="line">Led_Initsturcture.<a class="code" href="struct_s_l_e_e_p___l_e_d___init_type_def.html#af1f571ceb71d6764f33b8b6702d613b7">phase_uptate_rate</a>[1]              = 0;</div><div class="line">Led_Initsturcture.<a class="code" href="struct_s_l_e_e_p___l_e_d___init_type_def.html#afc324c3d80af17b16e86aa891b1b0924">phase_phase_tick</a>[1]               = 50;</div><div class="line">Led_Initsturcture.<a class="code" href="struct_s_l_e_e_p___l_e_d___init_type_def.html#a65ae26a2a025c66d7d51056ef3a6be16">phase_initial_duty</a>[1]             = 100;</div><div class="line">Led_Initsturcture.<a class="code" href="struct_s_l_e_e_p___l_e_d___init_type_def.html#a1459db0e698faf337c7b34c60db2f168">phase_increase_duty</a>[1]            = 1;</div><div class="line">Led_Initsturcture.<a class="code" href="struct_s_l_e_e_p___l_e_d___init_type_def.html#a78e27876a51ccdb5fc15b4f6572c9e78">phase_duty_step</a>[1]                = 2;</div><div class="line"></div><div class="line"><span class="comment">/* Set phase2 parameters */</span></div><div class="line">Led_Initsturcture.<a class="code" href="struct_s_l_e_e_p___l_e_d___init_type_def.html#af1f571ceb71d6764f33b8b6702d613b7">phase_uptate_rate</a>[2]              = 0;</div><div class="line">Led_Initsturcture.<a class="code" href="struct_s_l_e_e_p___l_e_d___init_type_def.html#afc324c3d80af17b16e86aa891b1b0924">phase_phase_tick</a>[2]               = 50;</div><div class="line">Led_Initsturcture.<a class="code" href="struct_s_l_e_e_p___l_e_d___init_type_def.html#a65ae26a2a025c66d7d51056ef3a6be16">phase_initial_duty</a>[2]             = 200;</div><div class="line">Led_Initsturcture.<a class="code" href="struct_s_l_e_e_p___l_e_d___init_type_def.html#a1459db0e698faf337c7b34c60db2f168">phase_increase_duty</a>[2]            = 1;</div><div class="line">Led_Initsturcture.<a class="code" href="struct_s_l_e_e_p___l_e_d___init_type_def.html#a78e27876a51ccdb5fc15b4f6572c9e78">phase_duty_step</a>[2]                = 3;</div><div class="line"></div><div class="line"><span class="comment">/* Set phase3 parameters */</span></div><div class="line">Led_Initsturcture.<a class="code" href="struct_s_l_e_e_p___l_e_d___init_type_def.html#af1f571ceb71d6764f33b8b6702d613b7">phase_uptate_rate</a>[3]              = 0;</div><div class="line">Led_Initsturcture.<a class="code" href="struct_s_l_e_e_p___l_e_d___init_type_def.html#afc324c3d80af17b16e86aa891b1b0924">phase_phase_tick</a>[3]               = 50;</div><div class="line">Led_Initsturcture.<a class="code" href="struct_s_l_e_e_p___l_e_d___init_type_def.html#a65ae26a2a025c66d7d51056ef3a6be16">phase_initial_duty</a>[3]             = 300;</div><div class="line">Led_Initsturcture.<a class="code" href="struct_s_l_e_e_p___l_e_d___init_type_def.html#a1459db0e698faf337c7b34c60db2f168">phase_increase_duty</a>[3]            = 1;</div><div class="line">Led_Initsturcture.<a class="code" href="struct_s_l_e_e_p___l_e_d___init_type_def.html#a78e27876a51ccdb5fc15b4f6572c9e78">phase_duty_step</a>[3]                = 4;</div><div class="line"></div><div class="line"><span class="comment">/* Set phase4 parameters */</span></div><div class="line">Led_Initsturcture.<a class="code" href="struct_s_l_e_e_p___l_e_d___init_type_def.html#af1f571ceb71d6764f33b8b6702d613b7">phase_uptate_rate</a>[4]              = 0;</div><div class="line">Led_Initsturcture.<a class="code" href="struct_s_l_e_e_p___l_e_d___init_type_def.html#afc324c3d80af17b16e86aa891b1b0924">phase_phase_tick</a>[4]               = 50;</div><div class="line">Led_Initsturcture.<a class="code" href="struct_s_l_e_e_p___l_e_d___init_type_def.html#a65ae26a2a025c66d7d51056ef3a6be16">phase_initial_duty</a>[4]             = 300;</div><div class="line">Led_Initsturcture.<a class="code" href="struct_s_l_e_e_p___l_e_d___init_type_def.html#a1459db0e698faf337c7b34c60db2f168">phase_increase_duty</a>[4]            = 0;</div><div class="line">Led_Initsturcture.<a class="code" href="struct_s_l_e_e_p___l_e_d___init_type_def.html#a78e27876a51ccdb5fc15b4f6572c9e78">phase_duty_step</a>[4]                = 1;</div><div class="line"></div><div class="line"><span class="comment">/* Set phase5 parameters */</span></div><div class="line">Led_Initsturcture.<a class="code" href="struct_s_l_e_e_p___l_e_d___init_type_def.html#af1f571ceb71d6764f33b8b6702d613b7">phase_uptate_rate</a>[5]              = 0;</div><div class="line">Led_Initsturcture.<a class="code" href="struct_s_l_e_e_p___l_e_d___init_type_def.html#afc324c3d80af17b16e86aa891b1b0924">phase_phase_tick</a>[5]               = 50;</div><div class="line">Led_Initsturcture.<a class="code" href="struct_s_l_e_e_p___l_e_d___init_type_def.html#a65ae26a2a025c66d7d51056ef3a6be16">phase_initial_duty</a>[5]             = 200;</div><div class="line">Led_Initsturcture.<a class="code" href="struct_s_l_e_e_p___l_e_d___init_type_def.html#a1459db0e698faf337c7b34c60db2f168">phase_increase_duty</a>[5]            = 0;</div><div class="line">Led_Initsturcture.<a class="code" href="struct_s_l_e_e_p___l_e_d___init_type_def.html#a78e27876a51ccdb5fc15b4f6572c9e78">phase_duty_step</a>[5]                = 2;</div><div class="line"></div><div class="line"><span class="comment">/* Set phase6 parameters */</span></div><div class="line">Led_Initsturcture.<a class="code" href="struct_s_l_e_e_p___l_e_d___init_type_def.html#af1f571ceb71d6764f33b8b6702d613b7">phase_uptate_rate</a>[6]              = 0;</div><div class="line">Led_Initsturcture.<a class="code" href="struct_s_l_e_e_p___l_e_d___init_type_def.html#afc324c3d80af17b16e86aa891b1b0924">phase_phase_tick</a>[6]               = 50;</div><div class="line">Led_Initsturcture.<a class="code" href="struct_s_l_e_e_p___l_e_d___init_type_def.html#a65ae26a2a025c66d7d51056ef3a6be16">phase_initial_duty</a>[6]             = 100;</div><div class="line">Led_Initsturcture.<a class="code" href="struct_s_l_e_e_p___l_e_d___init_type_def.html#a1459db0e698faf337c7b34c60db2f168">phase_increase_duty</a>[6]            = 0;</div><div class="line">Led_Initsturcture.<a class="code" href="struct_s_l_e_e_p___l_e_d___init_type_def.html#a78e27876a51ccdb5fc15b4f6572c9e78">phase_duty_step</a>[6]                = 3;</div><div class="line"></div><div class="line"><span class="comment">/* Set phase7 parameters */</span></div><div class="line">Led_Initsturcture.<a class="code" href="struct_s_l_e_e_p___l_e_d___init_type_def.html#af1f571ceb71d6764f33b8b6702d613b7">phase_uptate_rate</a>[7]              = 0;</div><div class="line">Led_Initsturcture.<a class="code" href="struct_s_l_e_e_p___l_e_d___init_type_def.html#afc324c3d80af17b16e86aa891b1b0924">phase_phase_tick</a>[7]               = 50;</div><div class="line">Led_Initsturcture.<a class="code" href="struct_s_l_e_e_p___l_e_d___init_type_def.html#a65ae26a2a025c66d7d51056ef3a6be16">phase_initial_duty</a>[7]             = 0;</div><div class="line">Led_Initsturcture.<a class="code" href="struct_s_l_e_e_p___l_e_d___init_type_def.html#a1459db0e698faf337c7b34c60db2f168">phase_increase_duty</a>[7]            = 0;</div><div class="line">Led_Initsturcture.<a class="code" href="struct_s_l_e_e_p___l_e_d___init_type_def.html#a78e27876a51ccdb5fc15b4f6572c9e78">phase_duty_step</a>[7]                = 0;</div><div class="line"><span class="comment">/* Initialize channel 0 */</span></div><div class="line"><a class="code" href="group___l_e_d___exported___functions.html#ga2d1ef997e7c882e1f8c0c488d7e848cd">SleepLed_Init</a>(<a class="code" href="group___l_e_d___exported___constants.html#gga0c32efc253c8d08276f94c0b57243d85ae34309ef93950bb061fbf0d1feccc19f">LED_CHANNEL_0</a>, &amp;Led_Initsturcture);</div><div class="line"><span class="comment">/* Initialize channel 1 */</span></div><div class="line"><a class="code" href="group___l_e_d___exported___functions.html#ga2d1ef997e7c882e1f8c0c488d7e848cd">SleepLed_Init</a>(<a class="code" href="group___l_e_d___exported___constants.html#gga0c32efc253c8d08276f94c0b57243d85abbd0cd725f476631275036f05d7b9475">LED_CHANNEL_1</a>, &amp;Led_Initsturcture);</div><div class="line"><span class="comment">/* Initialize channel 2 */</span></div><div class="line"><a class="code" href="group___l_e_d___exported___functions.html#ga2d1ef997e7c882e1f8c0c488d7e848cd">SleepLed_Init</a>(<a class="code" href="group___l_e_d___exported___constants.html#gga0c32efc253c8d08276f94c0b57243d85a1634c90c66301ab6b8bd1145a4a166e8">LED_CHANNEL_2</a>, &amp;Led_Initsturcture);</div><div class="line"><span class="comment">/* Enable Sleep led */</span></div><div class="line"><a class="code" href="group___l_e_d___exported___functions.html#ga4c3ebc49b46a59fd24ad555c0d107a83">SleepLed_Cmd</a>(<a class="code" href="group___l_e_d___exported___constants.html#gga0c32efc253c8d08276f94c0b57243d85abbd0cd725f476631275036f05d7b9475">LED_CHANNEL_1</a> | <a class="code" href="group___l_e_d___exported___constants.html#gga0c32efc253c8d08276f94c0b57243d85ae34309ef93950bb061fbf0d1feccc19f">LED_CHANNEL_0</a> | <a class="code" href="group___l_e_d___exported___constants.html#gga0c32efc253c8d08276f94c0b57243d85a1634c90c66301ab6b8bd1145a4a166e8">LED_CHANNEL_2</a>, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div></div><!-- fragment --><div style="page-break-after: always;"></div><h2><a class="anchor" id="QDEC"></a>
18  QDEC</h2>
<h3><a class="anchor" id="QDEC_Demo_Code_Support_List"></a>
18.1  QDEC Demo Code Support List</h3>
<center><div id="table_18_1"><b>Table 18-1 QDEC Sample Code 1 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 1  </th><th class="markdownTableHeadNone">qdec_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:180px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:670px">Demonstrate how QDEC works.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Brief Introduction  </td><td class="markdownTableBodyNone">This sample code demonstrates how QDEC works. Chip will detect the direction and count of wheel turns.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\qdec\qdec_demo.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">qdec_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">As shown in Figure 18-1.<br />
On EVB, Connect P1_0 to the PHA of the wheel.<br />
On EVB, Connect P1_1 to the PHB of the wheel.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">QDEC PHA PIN  </td><td class="markdownTableBodyNone">#define QDEC_Y_PHA_PIN P1_0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">QDEC PHB PIN  </td><td class="markdownTableBodyNone">#define QDEC_Y_PHB_PIN P1_1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">QDEC Axial  </td><td class="markdownTableBodyNone">Y   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Scan Clock  </td><td class="markdownTableBodyNone">50Khz   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Debounce Clock  </td><td class="markdownTableBodyNone">5KHz   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Debounce  </td><td class="markdownTableBodyNone">Debounce_Enable   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Debounce Time  </td><td class="markdownTableBodyNone">5ms   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">1. Press RESET on the EVB.<br />
2. When the wheel is turned, the direction is recorded in the variable dir, and the <br />
count is recorded in the variable y_axis   </td></tr>
</table>
<div class="image">
<img src="QDEC_Demo_Hardware_Connection_Diagram.jpg" alt="QDEC_Demo_Hardware_Connection_Diagram.jpg"/>
</div>
 <center><div id="figure_18_1"><b>Figure 18-1 QDEC Demo Hardware Connection Diagram</b></div></center><h3><a class="anchor" id="QDEC_Function_Description"></a>
18.2  Function Description</h3>
<p>As shown in Figure 18-2. QDEC is used to detect the motion state of the rotation-sensing device. When the rotating device moves, it will output two quadrature signals PHA and PHB. QDEC judges the direction of rotation by detecting the phase change of PHA and PHB.</p>
<p><b>Note:</b> RTL87X3G doesn't support QDEC.</p>
<div class="image">
<img src="Schematic_Diagram_of_Two_Quadrature_Signals_of_QDEC.jpg" alt="Schematic_Diagram_of_Two_Quadrature_Signals_of_QDEC.jpg"/>
</div>
 <center><div id="figure_18_2"><b>Figure 18-2 Schematic Diagram of Two Quadrature Signals of QDEC</b></div></center><h3><a class="anchor" id="QDEC_Feature_List"></a>
18.3  Feature List</h3>
<ul>
<li>Support 3 axis</li>
<li>Support hardware debounce, debounce time for each axis can be set independently</li>
<li>Support initial phase setting</li>
<li>Supports illegal phase change detection</li>
<li>16-bit phase change counter</li>
</ul>
<p><b>Note:</b> RTL87X3E cannot disable hardware debounce function. RTL87X3D can disable hardware debounce function.</p>
<h3><a class="anchor" id="QDEC_Direction_Judgment_and_Counting_Method"></a>
18.4  Direction Judgment and Counting Method</h3>
<ol type="1">
<li>PHA and PHB are combined into a 2-bit number. PHA is high bit and PHB is low bit.</li>
<li>The phases are divided into four types: 00, 01, 11, and 10.</li>
<li>As shown in Figure 18-3. Changes in the order of 00, 01, 11, and 10 are defined as positive. When the counter scale is set to 0, the counter will increase by one when the phase changes once. When the counter scale is set to 1, the counter will increase by one when the phase changes twice.</li>
<li>Changes in the order of 00, 10, 11, 01 are defined as negative. When counter scale is set to 0, the counter will decrease by one when the phase changes once. When counter scale is set to 1, the counter will decrease by one when the phase changes twice.</li>
<li>PHA and PHB should only have one signal change at a time. If both signals change at the same time, the state is considered wrong. When this error state occurs, the counter does not count. You can turn on illegal interrupts to detect this error condition.</li>
</ol>
<div class="image">
<img src="Schematic_Diagram_of_QDEC_Direction_Judgment.jpg" alt="Schematic_Diagram_of_QDEC_Direction_Judgment.jpg"/>
</div>
 <center><div id="figure_18_3"><b>Figure 18-3 Schematic Diagram of QDEC Direction Judgment</b></div></center><h3><a class="anchor" id="QDEC_Operation_Flow"></a>
18.5  QDEC Operation Flow</h3>
<p>QDEC operation flow is shown in Figure 18-4.</p>
<div class="image">
<img src="QDEC_Operation_Flow_Chart.jpg" alt="QDEC_Operation_Flow_Chart.jpg"/>
</div>
 <center><div id="figure_18_4"><b>Figure 18-4 QDEC Operation Flow Chart</b></div></center><div style="page-break-after: always;"></div><p>The codes below show QDEC operation flow. </p><div class="fragment"><div class="line"><span class="comment">/* Enable QDEC clock */</span></div><div class="line"><a class="code" href="group__x3e___r_c_c___exported___functions.html#ga0ff78e34dcddb1ed9a215ee66ccb2d1b">RCC_PeriphClockCmd</a>(<a class="code" href="group___a_p_b___peripheral___define.html#ga4493bccbbd592ddb58fd4af530fdf2d2">APBPeriph_QDEC</a>, <a class="code" href="group___r_c_c___peripheral___clock.html#gaaab1246478accb9791d4e1240b9fc1fe">APBPeriph_QDEC_CLOCK</a>, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line"></div><div class="line"><a class="code" href="struct_q_d_e_c___init_type_def.html">QDEC_InitTypeDef</a> qdecInitStruct;</div><div class="line"><span class="comment">/* Fill each QDEC_InitTypeDef member variable with its default value */</span></div><div class="line"><a class="code" href="group___q_d_e_c___exported___functions.html#gaf179052c05265ee8e47bc54a067b38a1">QDEC_StructInit</a>(&amp;qdecInitStruct);</div><div class="line"><span class="comment">/* Enable Y-axis configuration */</span></div><div class="line">qdecInitStruct.<a class="code" href="struct_q_d_e_c___init_type_def.html#a137b165665887def79bc318296635500">axisConfigY</a>       = <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>;</div><div class="line"><span class="comment">/* Enable Y-axis debounce function */</span></div><div class="line">qdecInitStruct.<a class="code" href="struct_q_d_e_c___init_type_def.html#a05b106fa875ab2346da5eaefc9211121">debounceEnableY</a>   = <a class="code" href="group___qdec___debounce.html#ga9686dfbc929dc08d7c4b28dcfccc0d26">Debounce_Enable</a>;</div><div class="line"><span class="comment">/* Initialize QDEC */</span></div><div class="line"><a class="code" href="group___q_d_e_c___exported___functions.html#gade5297f26899ed8d3088456b45fc1775">QDEC_Init</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#ga9acb39c1a508c83bf15e974d62c4a06f">QDEC</a>, &amp;qdecInitStruct);</div><div class="line"><span class="comment">/* Enable Y-axis counter interrupt */</span></div><div class="line"><a class="code" href="group___q_d_e_c___exported___functions.html#gacd994273775ba2eb899ac530aa82a433">QDEC_INTConfig</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#ga9acb39c1a508c83bf15e974d62c4a06f">QDEC</a>, <a class="code" href="group___q_d_e_c___interrupts___definition.html#ga7a3db7c138155ec683950c2f0c7a42ef">QDEC_Y_INT_NEW_DATA</a>, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line"></div><div class="line"><span class="comment">/* Enable NVIC of QDEC */</span></div><div class="line"><a class="code" href="struct_n_v_i_c___init_type_def.html">NVIC_InitTypeDef</a> nvic_init_struct;</div><div class="line">nvic_init_struct.<a class="code" href="struct_n_v_i_c___init_type_def.html#a921af0ab04e071d7d276c003e0048123">NVIC_IRQChannel</a>         = <a class="code" href="group__x3e___r_t_l876x___exported__types.html#gga666eb0caeb12ec0e281415592ae89083a59082da14040ed6cf7410cc2d0909c42">QDEC_IRQn</a>;</div><div class="line">nvic_init_struct.<a class="code" href="struct_n_v_i_c___init_type_def.html#a3c5567ef024a0489884083c88f17b4d5">NVIC_IRQChannelCmd</a>      = (<a class="code" href="group__x3d___r_t_l876x___exported__types.html#gac9a7e9a35d2513ec15c3b537aaa4fba1">FunctionalState</a>)<a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>;</div><div class="line">nvic_init_struct.<a class="code" href="struct_n_v_i_c___init_type_def.html#acd582bc2edce30e9d7ab5e0ede400f36">NVIC_IRQChannelPriority</a> = 3;</div><div class="line"><a class="code" href="group__x3e___n_v_i_c___exported___functions.html#ga4e06b4f5c9109d6bc8990adf77e5f8d3">NVIC_Init</a>(&amp;nvic_init_struct);</div><div class="line"></div><div class="line"><span class="comment">/* Enable QDEC */</span></div><div class="line"><a class="code" href="group___q_d_e_c___exported___functions.html#ga9a87df4e73533150760596ab85c4b707">QDEC_Cmd</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#ga9acb39c1a508c83bf15e974d62c4a06f">QDEC</a>, <a class="code" href="group___q_d_e_c___axis.html#gaa8acf9fe79a8db9b4e39d1ad9f564c55">QDEC_AXIS_Y</a>, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div></div><!-- fragment --><p>QDEC interrupt handle flow is shown in Figure 18-5.</p>
<div class="image">
<img src="QDEC_Interrupt_Handle_Flow_Chart.jpg" alt="QDEC_Interrupt_Handle_Flow_Chart.jpg"/>
</div>
 <center><div id="figure_18_5"><b>Figure 18-5 QDEC Interrupt Handle Flow</b></div></center><p>The codes below show QDEC interrupt handle flow. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> qdec_handler(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* Check Y-axis counter interrupt status flag */</span></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group___q_d_e_c___exported___functions.html#gacc687346250976886fb5b053a597db2b">QDEC_GetFlagState</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#ga9acb39c1a508c83bf15e974d62c4a06f">QDEC</a>, <a class="code" href="group___q_d_e_c___flag.html#ga8a6928392ed43cda6b57045d2d26c838">QDEC_FLAG_NEW_CT_STATUS_Y</a>) == <a class="code" href="group__x3e___r_t_l876x___exported__types.html#gga89136caac2e14c55151f527ac02daaffab44c8101cc294c074709ec1b14211792">SET</a>)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Mask Y-axis counter interrupt */</span></div><div class="line">        <a class="code" href="group___q_d_e_c___exported___functions.html#ga9ebd7591104d9ced9d87da0a02274634">QDEC_INTMask</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#ga9acb39c1a508c83bf15e974d62c4a06f">QDEC</a>, <a class="code" href="group___q_d_e_c___interrupts___mask.html#ga961f4ee009a521c220c462daad2994a0">QDEC_Y_CT_INT_MASK</a>, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line"></div><div class="line">        <span class="comment">/* Read direction */</span></div><div class="line">        dir = <a class="code" href="group___q_d_e_c___exported___functions.html#gabc4e98dccd551bd5d32d554bd5a4379e">QDEC_GetAxisDirection</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#ga9acb39c1a508c83bf15e974d62c4a06f">QDEC</a>, <a class="code" href="group___q_d_e_c___axis.html#gaa8acf9fe79a8db9b4e39d1ad9f564c55">QDEC_AXIS_Y</a>);</div><div class="line">        <span class="comment">/* Read counter count value */</span></div><div class="line">        y_axis = <a class="code" href="group___q_d_e_c___exported___functions.html#gafa4699626001aaa370839adf020a9db5">QDEC_GetAxisCount</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#ga9acb39c1a508c83bf15e974d62c4a06f">QDEC</a>, <a class="code" href="group___q_d_e_c___axis.html#gaa8acf9fe79a8db9b4e39d1ad9f564c55">QDEC_AXIS_Y</a>);</div><div class="line">        IO_PRINT_INFO2(<span class="stringliteral">&quot;qdec_handler: dir %d, y_axis %d&quot;</span>, dir, y_axis);</div><div class="line">        <span class="comment">/* clear Y-axis counter interrupt status flag */</span></div><div class="line">        <a class="code" href="group___q_d_e_c___exported___functions.html#gac8cbb9545e678919a2797597c4d9f25f">QDEC_ClearFlags</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#ga9acb39c1a508c83bf15e974d62c4a06f">QDEC</a>, <a class="code" href="group___q_d_e_c___clr___flag.html#gaf72dedc8836ad8fce9b97d32ce8b7426">QDEC_CLR_NEW_CT_Y</a>);</div><div class="line">        <span class="comment">/* Unmask Y-axis counter interrupt */</span></div><div class="line">        <a class="code" href="group___q_d_e_c___exported___functions.html#ga9ebd7591104d9ced9d87da0a02274634">QDEC_INTMask</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#ga9acb39c1a508c83bf15e974d62c4a06f">QDEC</a>, <a class="code" href="group___q_d_e_c___interrupts___mask.html#ga961f4ee009a521c220c462daad2994a0">QDEC_Y_CT_INT_MASK</a>, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1ad3a9df141be0ccf10389b640f492b26d">DISABLE</a>);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><div style="page-break-after: always;"></div><h2><a class="anchor" id="KEYSCAN"></a>
19  KEYSCAN</h2>
<h3><a class="anchor" id="KEYSCAN_Demo_Code_Support_List"></a>
19.1 KEYSCAN Demo Code Support List</h3>
<center><div id="table_19_1"><b>Table 19-1 KEYSCAN Sample Code 1 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 1  </th><th class="markdownTableHeadNone">keyscan_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:180px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:670px">Demonstrates that keyscan works in active mode.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\keyscan\active\keyscan_demo.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">keyscan_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">As shown in Figure 19-1. EVB is connected to matrix keyboard module: connect <br />
M0_2 to ROW0, M0_3 to ROW1, M0_0 to COLUMN0, and M0_1 to COLUMN1.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">1. When a key is pressed, key information is printed on DebugAnalyser.<br />
2. When all keys are released, string "io_demo_task: All key release" is printed <br />
on DebugAnalyser.   </td></tr>
</table>
<center><div id="table_19_2"><b>Table 19-2 KEYSCAN Sample Code 2 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 2  </th><th class="markdownTableHeadNone">keyscan_demo_dlps.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:180px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:670px">Demonstrates that keyscan works in DLPS mode.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\keyscan\dlps\keyscan_demo_dlps.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">keyscan_demo_dlps()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">As shown in Figure 19-1. EVB is connected to matrix keyboard module: connect <br />
M0_2 to ROW0, M0_3 to ROW1, M0_0 to COLUMN0, and M0_1 to COLUMN1.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">1. Press RESET on the EVB, string "io_dlps_enter" will be printed in DebugAnalyzer and system will enter DLPS mode.<br />
2. When a key is pressed, the system will be woken up and key information is printed on DebugAnalyser<br />
3. When all keys are released, string "keyscan_release_handle: All key release" is <br />
printed on DebugAnalyser and the system will enter DLPS mode.   </td></tr>
</table>
<div class="image">
<img src="KEYSCAN_Hardware_Connection_Diagram.jpg" alt="KEYSCAN_Hardware_Connection_Diagram.jpg"/>
</div>
 <center><div id="figure_19_1"><b>Figure 19-1 KEYSCAN Hardware Connection Diagram</b></div></center><h3><a class="anchor" id="KEYSCAN_Function_Description"></a>
19.2  Function Description</h3>
<p>Keyscan needs to be used with an external key matrix. In the idle state, Row[x] is input, pull high is required, column[y] is output low, and output mode must be open-drain. When any key is pressed, the level of the corresponding row changes from high to low, triggering keyscan hardware scan action. <br />
After the debounce is completed, the first scan starts. When scanning, the column[y] being scanned is output low, and the other columns output high. If row[x] is low at this time, it is considered that row[x] column[y] key is pressed. <br />
Scan order is first column[0] fixed, scan from row[0] to row[x], then column[1] fixed, scan from row[0] to row[x], until column[y].</p>
<p><b>Note:</b> RTL87X3D and RTL87X3E support KEYSCAN, RTL87X3G doesn't support KEYSCAN.</p>
<h3><a class="anchor" id="KEYSCAN_Feature_List"></a>
19.3  Feature List</h3>
<ul>
<li>Support 12(row) * 20(column) matrix scan</li>
<li>Configurable number of rows (1-12), columns (1-20)</li>
<li>Support hardware debounce, configurable debounce time</li>
<li>Configurable scan clock</li>
<li>Support multi-key detection, up to 26 keys can be pressed at the same time</li>
<li>Support periodic scan, configurable scan period</li>
<li>26 bytes FIFO depth</li>
<li>Support auto scan and manual scan</li>
<li>Support all key release hardware detection</li>
</ul>
<h3><a class="anchor" id="KEYSCAN_Clock_Divider"></a>
19.4  Clock Divider</h3>
<p>IO Clock will be divided into 2 channels. <br />
The keyscan scan clock is generated by the frequency division of keyscan_clk_div (11 bits), which can be freely configured in the range of 10KHz-100KHz. <br />
The low-level delay clock is generated by the frequency division of keyscan_delay_div (6bits) for use by the relevant timer.</p>
<div class="image">
<img src="Schematic_Diagram_of_KEYSCAN_Clock_Divider.jpg" alt="Schematic_Diagram_of_KEYSCAN_Clock_Divider.jpg"/>
</div>
 <center><div id="figure_19_2"><b>Figure 19-2 Schematic Diagram of KEYSCAN Clock Divider</b></div></center><h3><a class="anchor" id="KEYSCAN_Auto_Scan_Mode"></a>
19.5  Auto Scan Mode</h3>
<p>The workflow of automatic scanning is shown in the figure below.</p>
<div class="image">
<img src="Auto_Scan_Flow_Chart.jpg" alt="Auto_Scan_Flow_Chart.jpg"/>
</div>
 <center><div id="figure_19_3"><b>Figure 19-3 Auto Scan Flow Chart</b></div></center><h3><a class="anchor" id="KEYSCAN_Interrupt"></a>
19.6  Interrupt</h3>
<p>KEYSCAN_INT_OVER_READ: When there is no data in the FIFO, reading the FIFO will trigger this interrupt to prevent over-reading. <br />
KEYSCAN_INT_SCAN_END: No matter whether the key value is scanned or not, the interrupt will be triggered as long as the scanning action is completed. <br />
KEYSCAN_INT_FIFO_NOT_EMPTY: If there is data in FIFO, the interrupt will be triggered. <br />
KEYSCAN_INT_THRESHOLD: This interrupt is triggered when data in the FIFO reaches the threshold level. <br />
KEYSCAN_INT_ALL_RELEASE: When the release time cnt reaches the set value, if no key is pressed, the interrupt is triggered.</p>
<h3><a class="anchor" id="KEYSCAN_Operation_Flow"></a>
19.7  KEYSCAN Operation Flow</h3>
<p>KEYSCAN initialization flow is shown in Figure 19-4.</p>
<div class="image">
<img src="KEYSCAN_Initialization_Flow_Chart.jpg" alt="KEYSCAN_Initialization_Flow_Chart.jpg"/>
</div>
 <center><div id="figure_19_4"><b>Figure 19-4 KEYSCAN Initialization Flow Chart</b></div></center><p>The codes below show KEYSCAN initialization flow. For details, please refer to src\sample\io_demo\keyscan\active\keyscan_demo.c </p><div class="fragment"><div class="line"><a class="code" href="group__x3e___r_c_c___exported___functions.html#ga0ff78e34dcddb1ed9a215ee66ccb2d1b">RCC_PeriphClockCmd</a>(<a class="code" href="group___a_p_b___peripheral___define.html#ga3427eb4dcd3ded31758ca9fd3e758c4a">APBPeriph_KEYSCAN</a>, <a class="code" href="group___r_c_c___peripheral___clock.html#gad34eae9a59c0f8936c48894586d5a9a1">APBPeriph_KEYSCAN_CLOCK</a>, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line"><a class="code" href="struct_k_e_y_s_c_a_n___init_type_def.html">KEYSCAN_InitTypeDef</a>  KeyScan_InitStruct;</div><div class="line"><a class="code" href="group___keyscan___exported__functions.html#gadb9c58ade69bcf386ebf7fd3246ad1b2">KeyScan_StructInit</a>(&amp;KeyScan_InitStruct);</div><div class="line">KeyScan_InitStruct.<a class="code" href="struct_k_e_y_s_c_a_n___init_type_def.html#afb87b2b09830fbf758984aa63f73977a">colSize</a>         = KEYPAD_COLUMN_SIZE;</div><div class="line">KeyScan_InitStruct.<a class="code" href="struct_k_e_y_s_c_a_n___init_type_def.html#a66d5b195ca6c227bb1744ef5c49087de">rowSize</a>         = KEYPAD_ROW_SIZE;</div><div class="line">KeyScan_InitStruct.<a class="code" href="struct_k_e_y_s_c_a_n___init_type_def.html#a0739a1f06614be7a1bd9e603379f1829">scanInterval</a>    = 0x80;</div><div class="line"><a class="code" href="group___keyscan___exported__functions.html#ga8d5a0d9ba0a24e55dbb3a6fcb4e406ea">KeyScan_Init</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#gab01393036e9d47bbfd0c51d58fa32cfb">KEYSCAN</a>, &amp;KeyScan_InitStruct);</div><div class="line"><a class="code" href="group___keyscan___exported__functions.html#gacb5d8bbca88dac1781b1428c24e26520">KeyScan_INTConfig</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#gab01393036e9d47bbfd0c51d58fa32cfb">KEYSCAN</a>, <a class="code" href="group___keyscan___interrupt___definition.html#ga18e8808447418baf8e70b801da8542df">KEYSCAN_INT_SCAN_END</a> | <a class="code" href="group___keyscan___interrupt___definition.html#ga7d049e1e2bb7255ffd0dc1be07fdf654">KEYSCAN_INT_ALL_RELEASE</a>, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line"></div><div class="line"><a class="code" href="struct_n_v_i_c___init_type_def.html">NVIC_InitTypeDef</a> nvic_init_struct;</div><div class="line">nvic_init_struct.<a class="code" href="struct_n_v_i_c___init_type_def.html#a921af0ab04e071d7d276c003e0048123">NVIC_IRQChannel</a>         = <a class="code" href="group__x3e___r_t_l876x___exported__types.html#gga666eb0caeb12ec0e281415592ae89083aa1bd789646140c7acbbab235b78b3545">KeyScan_IRQn</a>;</div><div class="line">nvic_init_struct.<a class="code" href="struct_n_v_i_c___init_type_def.html#a3c5567ef024a0489884083c88f17b4d5">NVIC_IRQChannelCmd</a>      = (<a class="code" href="group__x3d___r_t_l876x___exported__types.html#gac9a7e9a35d2513ec15c3b537aaa4fba1">FunctionalState</a>)<a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>;</div><div class="line">nvic_init_struct.<a class="code" href="struct_n_v_i_c___init_type_def.html#acd582bc2edce30e9d7ab5e0ede400f36">NVIC_IRQChannelPriority</a> = 3;</div><div class="line"><a class="code" href="group__x3e___n_v_i_c___exported___functions.html#ga4e06b4f5c9109d6bc8990adf77e5f8d3">NVIC_Init</a>(&amp;nvic_init_struct);</div><div class="line"></div><div class="line"><a class="code" href="group___keyscan___exported__functions.html#ga14a5c8b57294fcc03e53906a767526f7">KeyScan_Cmd</a>(<a class="code" href="group__x3d___r_t_l876_x___exported___macros.html#gab01393036e9d47bbfd0c51d58fa32cfb">KEYSCAN</a>, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div></div><!-- fragment --><div style="page-break-after: always;"></div><h2><a class="anchor" id="I2S"></a>
20  I2S</h2>
<h3><a class="anchor" id="I2S_Function_Description"></a>
20.1  Function Description</h3>
<p>I2S interface can support audio protocols such as I2S, Left-Justified, PCM, and TDM. By I2S interface, RTL87X3E and RTL87X3D can bridge to external DSP core (or audio codec/audio amplifier). I2S can be operated in DMA mode or FIFO mode. Set the buffer size according to the amount of transferred data in DMA mode, or access I2S FIFO directly to transmit and receive data in FIFO mode. It's recommended to transfer the audio data via DMA automatically since it can reduce the number of interrupts and improve efficiency.</p>
<h3><a class="anchor" id="I2S_Feature_List"></a>
20.2  Feature List</h3>
<ul>
<li>Up to 4 I2S ports</li>
<li>Configurable BCLK and LRCK clock rate</li>
<li>Support I2S, Left-justified, PCM format</li>
<li>Support 16/ 20/ 24/ 32 bits data resolution (data width)</li>
<li>Support 16/ 20/ 24/ 32 bits word length (channel width)</li>
<li>Support non-TDM (2-ch.), TDM4 (4-ch.), TDM6 (6-ch.) and TDM8 (8-ch.)</li>
<li>Support master and slave mode</li>
<li>Support GDMA handshake operation</li>
</ul>
<p><b>Note:</b></p><ul>
<li>RTL87X3D has 4 ports, RTL87X3E has 2 ports.</li>
<li>RTL87X3D support up to TDM8, RTL87X3E support up to TDM4.</li>
</ul>
<h3><a class="anchor" id="I2S_Initialization_Flow"></a>
20.3  I2S Initialization Flow</h3>
<p>I2S function initialization flow is shown in Figure 20-1. </p><div class="image">
<img src="I2S_Init_Flow.jpg" alt="I2S_Init_Flow.jpg"/>
</div>
 <center><div id="figure_20_1"><b>Figure 20-1 I2S Initialization Flow Chart</b></div></center><p>The codes below show I2S Function Initialization flow.</p>
<p><b>Note:</b> As mentioned in PINMUX and PAD function descriptions. I2S PAD should be configured as software mode and pulled down when I2S disable to prevent PAD from floating during low power mode.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> board_i2s_init(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* set PAD_SW_MODE &amp; PAD_PULL_DOWN when I2S disable to prevent PAD floating in low power mode */</span></div><div class="line">    <a class="code" href="group__x3e___p_i_n_m_u_x___exported___functions.html#ga38de86a8ea4d49c04e681494cc1c69cc">Pad_Config</a>(I2S_BCLK_PIN, <a class="code" href="group__x3e___p_a_d___mode.html#gga2cc156cba11040bcf54db2efeb9cb587a8309999f45f91d480cb6fbb7082efbf3">PAD_PINMUX_MODE</a>, <a class="code" href="group__x3e___p_a_d___power___mode.html#ggac2e804c73a9d287080d1cf1207e6a177a64ef7041a073bac1e848da51333064e0">PAD_IS_PWRON</a>, <a class="code" href="group__x3e___p_a_d___pull___mode.html#ggaed6ddbb1abccbd7d16dd3dcb8319f475ace4bff5003037646cf8dd9c1ee4dc7d1">PAD_PULL_NONE</a>, <a class="code" href="group__x3e___p_a_d___output___config.html#ggacfc9e3ea370eb8401828c4b97c110dd0a4f06d28834349a9bb7138b4beb07cd5e">PAD_OUT_ENABLE</a>, <a class="code" href="group__x3e___p_a_d___output___value.html#gga1bbbfd046e26ccb142c1b42f1d4dccd7a05d2e6f1ea0162d1d61ab077a5e988a5">PAD_OUT_LOW</a>);</div><div class="line">    <a class="code" href="group__x3e___p_i_n_m_u_x___exported___functions.html#ga38de86a8ea4d49c04e681494cc1c69cc">Pad_Config</a>(I2S_LRCK_PIN, <a class="code" href="group__x3e___p_a_d___mode.html#gga2cc156cba11040bcf54db2efeb9cb587a8309999f45f91d480cb6fbb7082efbf3">PAD_PINMUX_MODE</a>, <a class="code" href="group__x3e___p_a_d___power___mode.html#ggac2e804c73a9d287080d1cf1207e6a177a64ef7041a073bac1e848da51333064e0">PAD_IS_PWRON</a>, <a class="code" href="group__x3e___p_a_d___pull___mode.html#ggaed6ddbb1abccbd7d16dd3dcb8319f475ace4bff5003037646cf8dd9c1ee4dc7d1">PAD_PULL_NONE</a>, <a class="code" href="group__x3e___p_a_d___output___config.html#ggacfc9e3ea370eb8401828c4b97c110dd0a4f06d28834349a9bb7138b4beb07cd5e">PAD_OUT_ENABLE</a>, <a class="code" href="group__x3e___p_a_d___output___value.html#gga1bbbfd046e26ccb142c1b42f1d4dccd7a05d2e6f1ea0162d1d61ab077a5e988a5">PAD_OUT_LOW</a>);</div><div class="line">    <a class="code" href="group__x3e___p_i_n_m_u_x___exported___functions.html#ga38de86a8ea4d49c04e681494cc1c69cc">Pad_Config</a>(I2S_SDO_PIN, <a class="code" href="group__x3e___p_a_d___mode.html#gga2cc156cba11040bcf54db2efeb9cb587a8309999f45f91d480cb6fbb7082efbf3">PAD_PINMUX_MODE</a>, <a class="code" href="group__x3e___p_a_d___power___mode.html#ggac2e804c73a9d287080d1cf1207e6a177a64ef7041a073bac1e848da51333064e0">PAD_IS_PWRON</a>, <a class="code" href="group__x3e___p_a_d___pull___mode.html#ggaed6ddbb1abccbd7d16dd3dcb8319f475ace4bff5003037646cf8dd9c1ee4dc7d1">PAD_PULL_NONE</a>, <a class="code" href="group__x3e___p_a_d___output___config.html#ggacfc9e3ea370eb8401828c4b97c110dd0a4f06d28834349a9bb7138b4beb07cd5e">PAD_OUT_ENABLE</a>, <a class="code" href="group__x3e___p_a_d___output___value.html#gga1bbbfd046e26ccb142c1b42f1d4dccd7a05d2e6f1ea0162d1d61ab077a5e988a5">PAD_OUT_LOW</a>);</div><div class="line">    <a class="code" href="group__x3e___p_i_n_m_u_x___exported___functions.html#ga38de86a8ea4d49c04e681494cc1c69cc">Pad_Config</a>(I2S_SDI_PIN, <a class="code" href="group__x3e___p_a_d___mode.html#gga2cc156cba11040bcf54db2efeb9cb587a8309999f45f91d480cb6fbb7082efbf3">PAD_PINMUX_MODE</a>, <a class="code" href="group__x3e___p_a_d___power___mode.html#ggac2e804c73a9d287080d1cf1207e6a177a64ef7041a073bac1e848da51333064e0">PAD_IS_PWRON</a>, <a class="code" href="group__x3e___p_a_d___pull___mode.html#ggaed6ddbb1abccbd7d16dd3dcb8319f475ace4bff5003037646cf8dd9c1ee4dc7d1">PAD_PULL_NONE</a>, <a class="code" href="group__x3e___p_a_d___output___config.html#ggacfc9e3ea370eb8401828c4b97c110dd0a4f06d28834349a9bb7138b4beb07cd5e">PAD_OUT_ENABLE</a>, <a class="code" href="group__x3e___p_a_d___output___value.html#gga1bbbfd046e26ccb142c1b42f1d4dccd7a05d2e6f1ea0162d1d61ab077a5e988a5">PAD_OUT_LOW</a>);</div><div class="line"></div><div class="line">    <a class="code" href="group__x3e___p_i_n_m_u_x___exported___functions.html#ga54f185f00ccea46d0645189f40a4f8d0">Pinmux_Config</a>(I2S_BCLK_PIN, I2S_BCLK_PINMUX);</div><div class="line">    <a class="code" href="group__x3e___p_i_n_m_u_x___exported___functions.html#ga54f185f00ccea46d0645189f40a4f8d0">Pinmux_Config</a>(I2S_LRCK_PIN, I2S_LRCK_PINMUX);</div><div class="line">    <a class="code" href="group__x3e___p_i_n_m_u_x___exported___functions.html#ga54f185f00ccea46d0645189f40a4f8d0">Pinmux_Config</a>(I2S_SDO_PIN, I2S_SDO_PINMUX);</div><div class="line">    <a class="code" href="group__x3e___p_i_n_m_u_x___exported___functions.html#ga54f185f00ccea46d0645189f40a4f8d0">Pinmux_Config</a>(I2S_SDI_PIN, I2S_SDI_PINMUX);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> driver_i2s_init(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="struct_i2_s___init_type_def.html">I2S_InitTypeDef</a> I2S_InitStruct;</div><div class="line"></div><div class="line">    <a class="code" href="group___i2_s___exported___functions.html#ga7470ec1d0759fdeeb42c7fe71a3b41b7">I2S_StructInit</a>(&amp;I2S_InitStruct);</div><div class="line">    I2S_InitStruct.<a class="code" href="struct_i2_s___init_type_def.html#a0224b12cdb7cdd61571a1be7cfac324d">I2S_ClockSource</a>      = <a class="code" href="group___i2_s___clock___source.html#ga0c05ac93269e36301e195bbd8daa8b7a">I2S_CLK_XTAL</a>;</div><div class="line">    <span class="comment">/* BCLK = 40MHz * (I2S_BClockNi / I2S_BClockMi), LRCK = BCLK / (I2S_BClockDiv + 1) */</span></div><div class="line">    I2S_InitStruct.<a class="code" href="struct_i2_s___init_type_def.html#a2da117dcdb3dd09093d5d84dadc59264">I2S_BClockMi</a>         = 0x271;    <span class="comment">/* LRCK = 48KHz */</span></div><div class="line">    I2S_InitStruct.<a class="code" href="struct_i2_s___init_type_def.html#aceb87f2ed4daff4d0b213e22817c5c4e">I2S_BClockNi</a>         = 0x30;     <span class="comment">/* BCLK = 3.072MHz */</span></div><div class="line">    I2S_InitStruct.<a class="code" href="struct_i2_s___init_type_def.html#aa5b2544e7a6231dd3f712509207800cd">I2S_BClockDiv</a>        = 0x3F;</div><div class="line">    I2S_InitStruct.<a class="code" href="struct_i2_s___init_type_def.html#a6bf046ea18202a6a7c17c0b087dd8d88">I2S_DeviceMode</a>       = <a class="code" href="group___i2_s___device___mode.html#gafdeaf585e0a0ab0b214bd9ce065cc358">I2S_DeviceMode_Master</a>;</div><div class="line">    I2S_InitStruct.<a class="code" href="struct_i2_s___init_type_def.html#ad6045b237d35e1df5fc95a274da3583c">I2S_TxChannelType</a>    = <a class="code" href="group___i2_s___channel___type.html#gad18cc42e224d23473f8a0c9fe8e321bc">I2S_Channel_Stereo</a>;</div><div class="line">    I2S_InitStruct.<a class="code" href="struct_i2_s___init_type_def.html#ab61ab47b38c7a7cb3f8ee0a62de2b85d">I2S_TxDataWidth</a>      = <a class="code" href="group___i2_s___data___width.html#gaf9e85880d77eabaee38ae8975c080914">I2S_Width_24Bits</a>;</div><div class="line">    I2S_InitStruct.<a class="code" href="struct_i2_s___init_type_def.html#a9515452ae99f15c17b1afec1e97e0983">I2S_RxDataWidth</a>      = <a class="code" href="group___i2_s___data___width.html#gaf9e85880d77eabaee38ae8975c080914">I2S_Width_24Bits</a>;</div><div class="line">    I2S_InitStruct.<a class="code" href="struct_i2_s___init_type_def.html#a1b92c96c52085d92f77f18b74e00bcd3">I2S_TxChannelWidth</a>   = <a class="code" href="group___i2_s___data___width.html#ga93e24fb61326eb5e3603c1ab6f98ad00">I2S_Width_32Bits</a>;</div><div class="line">    I2S_InitStruct.<a class="code" href="struct_i2_s___init_type_def.html#a0afac113fc12d4506fc730b280349f02">I2S_RxChannelWidth</a>   = <a class="code" href="group___i2_s___data___width.html#ga93e24fb61326eb5e3603c1ab6f98ad00">I2S_Width_32Bits</a>;</div><div class="line">    I2S_InitStruct.<a class="code" href="struct_i2_s___init_type_def.html#a3119890a690bc61ac759ca9485aec57e">I2S_TxDataFormat</a>     = <a class="code" href="group___i2_s___format___mode.html#gab33e04fac1325ca69d8193bff9ca9794">I2S_Mode</a>;</div><div class="line">    I2S_InitStruct.<a class="code" href="struct_i2_s___init_type_def.html#a58d9bc07abea00b33566016a1e2bb258">I2S_RxDataFormat</a>     = <a class="code" href="group___i2_s___format___mode.html#gab33e04fac1325ca69d8193bff9ca9794">I2S_Mode</a>;</div><div class="line">    I2S_InitStruct.<a class="code" href="struct_i2_s___init_type_def.html#a1910f060d0778d6a50975d2570e67e41">I2S_DMACmd</a>           = <a class="code" href="group___i2_s___d_m_a___cmd.html#ga87747a12b8874a9d37419d28af032234">I2S_DMA_DISABLE</a>;</div><div class="line">    <a class="code" href="group___i2_s___exported___functions.html#gaa0f5b598a160e72118bd066f4e215885">I2S_Init</a>(I2S_NUM, &amp;I2S_InitStruct);</div><div class="line"></div><div class="line">    <a class="code" href="group___i2_s___exported___functions.html#ga70b2d4e787d4fbce768b62f07bc2eec5">I2S_Cmd</a>(I2S_NUM, <a class="code" href="group___i2_s___mode.html#gae6766a97d65262bc83ec468e10070203">I2S_MODE_TRX</a>, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="I2S_Clock_Divider"></a>
20.4  Clock Divider</h3>
<p>BCLK fractional divider according to the following equation:</p>
<p><b>BCLK = XTAL 40MHz * (I2S_BClockNi / I2S_BClockMi)</b></p>
<p>Example: For XTAL 40MHz clock source to generate 12.288MHz BCLK case. It's recommended to use the settings of <b>I2S_BClockNi</b> = 192 and <b>I2S_BClockMi</b> = 625.</p>
<p>Note that because clock source comes from XTAL 40MHz, BCLK would be a jittered clock composed of 10MHz and 13.33MHz in practice.</p>
<p>set even-bit integer divider for LRCK according to the following equation:</p>
<p><b>LRCK = BCLK / (I2S_BClockDiv +1)</b></p>
<p>Where <b>I2S_BClockDiv</b> could be calculated by:</p>
<p><b>I2S_BClockDiv = (channel width * channel number) -1</b></p>
<p>The channel number is determined by the TDM (Time Division Multiplexing) mode, 2-channels for without-TDM mode, 4-channels for TDM4 mode, and so on.</p>
<p>The recommended clock divider setting for 2-channels &amp; 32-bits channel width is shown below.</p>
<center><div id="table_20_1"><b>Table 20-1 I2S Clock Divider Table</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">BCLK frequency  </th><th class="markdownTableHeadLeft">Clock source  </th><th class="markdownTableHeadLeft">I2S_BClockNi  </th><th class="markdownTableHeadLeft">I2S_BClockMi  </th><th class="markdownTableHeadLeft">I2S_BClockDiv  </th><th class="markdownTableHeadLeft">Sampling rate   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><div style="width:165px">0.512 MHz</div>  </td><td class="markdownTableBodyLeft"><div style="width:125px">XTAL 40MHz</div>  </td><td class="markdownTableBodyLeft"><div style="width:140px">8</div>  </td><td class="markdownTableBodyLeft"><div style="width:140px">625</div>  </td><td class="markdownTableBodyLeft"><div style="width:150px">63</div>  </td><td class="markdownTableBodyLeft"><div style="width:135px">8 KHz</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft">0.768 MHz  </td><td class="markdownTableBodyLeft">XTAL 40MHz  </td><td class="markdownTableBodyLeft">12  </td><td class="markdownTableBodyLeft">625  </td><td class="markdownTableBodyLeft">63  </td><td class="markdownTableBodyLeft">12 KHz   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">1.024 MHz  </td><td class="markdownTableBodyLeft">XTAL 40MHz  </td><td class="markdownTableBodyLeft">16  </td><td class="markdownTableBodyLeft">625  </td><td class="markdownTableBodyLeft">63  </td><td class="markdownTableBodyLeft">16 KHz   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft">1.536 MHz  </td><td class="markdownTableBodyLeft">XTAL 40MHz  </td><td class="markdownTableBodyLeft">24  </td><td class="markdownTableBodyLeft">625  </td><td class="markdownTableBodyLeft">63  </td><td class="markdownTableBodyLeft">24 KHz   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">2.048 MHz  </td><td class="markdownTableBodyLeft">XTAL 40MHz  </td><td class="markdownTableBodyLeft">32  </td><td class="markdownTableBodyLeft">625  </td><td class="markdownTableBodyLeft">63  </td><td class="markdownTableBodyLeft">32 KHz   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft">3.072 MHz  </td><td class="markdownTableBodyLeft">XTAL 40MHz  </td><td class="markdownTableBodyLeft">48  </td><td class="markdownTableBodyLeft">625  </td><td class="markdownTableBodyLeft">63  </td><td class="markdownTableBodyLeft">48 KHz   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">6.144 MHz  </td><td class="markdownTableBodyLeft">XTAL 40MHz  </td><td class="markdownTableBodyLeft">96  </td><td class="markdownTableBodyLeft">625  </td><td class="markdownTableBodyLeft">63  </td><td class="markdownTableBodyLeft">96 KHz   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft">12.288 MHz  </td><td class="markdownTableBodyLeft">XTAL 40MHz  </td><td class="markdownTableBodyLeft">192  </td><td class="markdownTableBodyLeft">625  </td><td class="markdownTableBodyLeft">63  </td><td class="markdownTableBodyLeft">192 KHz   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">2.8224 MHz  </td><td class="markdownTableBodyLeft">XTAL 40MHz  </td><td class="markdownTableBodyLeft">441  </td><td class="markdownTableBodyLeft">6250  </td><td class="markdownTableBodyLeft">63  </td><td class="markdownTableBodyLeft">44.1 KHz   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft">5.6448 MHz  </td><td class="markdownTableBodyLeft">XTAL 40MHz  </td><td class="markdownTableBodyLeft">441  </td><td class="markdownTableBodyLeft">3125  </td><td class="markdownTableBodyLeft">63  </td><td class="markdownTableBodyLeft">88.2 KHz   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">0.7056 MHz  </td><td class="markdownTableBodyLeft">XTAL 40MHz  </td><td class="markdownTableBodyLeft">441  </td><td class="markdownTableBodyLeft">25000  </td><td class="markdownTableBodyLeft">63  </td><td class="markdownTableBodyLeft">11.025 KHz   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft">1.4112 MHz  </td><td class="markdownTableBodyLeft">XTAL 40MHz  </td><td class="markdownTableBodyLeft">441  </td><td class="markdownTableBodyLeft">12500  </td><td class="markdownTableBodyLeft">63  </td><td class="markdownTableBodyLeft">22.05 KHz   </td></tr>
</table>
<p>As mentioned above, I2S BCLK is a jittered clock composed of two frequencies that are generated from XTAL 40MHz.</p>
<p>The clock jitter percentage generated from XTAL 40MHz is shown in Figure 20-2 and Figure 20-3.</p>
<div class="image">
<img src="I2S_BCLK_Jitter.jpg" alt="I2S_BCLK_Jitter.jpg"/>
</div>
 <center><div id="figure_20_2"><b>Figure 20-2 I2S BCLK clock jitter percentage</b></div></center><div class="image">
<img src="I2S_LRCK_Jitter.jpg" alt="I2S_LRCK_Jitter.jpg"/>
</div>
 <center><div id="figure_20_3"><b>Figure 20-3 I2S LRCK clock jitter percentage</b></div></center><p>clock jitter could be calculated by the following equation:</p>
<p><b>Clock Jitter Percentage = max ( |(T<sub>min period</sub> - T<sub>ideal</sub>) / T<sub>ideal</sub>| , |(T<sub>max period</sub> - T<sub>ideal</sub>) / T<sub>ideal</sub>| ) * 100%</b></p>
<h3><a class="anchor" id="I2S_Operation_Flow"></a>
20.5  I2S Operation Flow</h3>
<h4>I2S TX GDMA Handshake Operation</h4>
<ol type="1">
<li>Turn on the peripheral clock source of the GDMA.</li>
<li>I2S TX and GDMA initialization; Set GDMA handshake with I2S TX.</li>
<li>Enable the GDMA_INT_Transfer interrupt and enable GDMA.</li>
<li>Invoke I2S_Cmd to generate LRCK and start retrieving data from TX FIFO.</li>
<li>Initiate DMA request if TX FIFO water level is lower than TX DMA burst size.</li>
<li>Trigger DMA transfer interrupt and wait for DMA transfer to complete.</li>
<li>Clear GDMA_INT_Transfer interrupt.</li>
</ol>
<p>The flow chart of I2S TX GDMA handshake operation is shown in Figure 20-4.</p>
<div class="image">
<img src="I2S_TX_GDMA_Flow.jpg" alt="I2S_TX_GDMA_Flow.jpg"/>
</div>
 <center><div id="figure_20_4"><b>Figure 20-4 I2S TX GDMA handshake operation</b></div></center><h4>I2S RX GDMA Handshake Operation</h4>
<ol type="1">
<li>Turn on the peripheral clock source of the GDMA.</li>
<li>I2S RX and GDMA initialization; Set GDMA handshake with I2S RX.</li>
<li>Enable the GDMA_INT_Transfer interrupt and enable GDMA.</li>
<li>Invoke I2S_Cmd to generate LRCK and start sending data to RX FIFO.</li>
<li>Wait for RX FIFO data to exceed RX DMA burst size and initiate DMA request.</li>
<li>Trigger DMA transfer interrupt and wait for DMA transfer to complete.</li>
<li>Clear GDMA_INT_Transfer interrupt.</li>
</ol>
<p>The flow chart of I2S RX GDMA handshake operation is shown in Figure 20-5.</p>
<div class="image">
<img src="I2S_RX_GDMA_Flow.jpg" alt="I2S_RX_GDMA_Flow.jpg"/>
</div>
 <center><div id="figure_20_5"><b>Figure 20-5 I2S RX GDMA handshake operation</b></div></center><div style="page-break-after: always;"></div><p>I2S GDMA handshake initialization flow, for example. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> driver_gdma_init(T_I2S_CONFIG_DIR dir)</div><div class="line">{</div><div class="line">    <a class="code" href="struct_g_d_m_a___init_type_def.html">GDMA_InitTypeDef</a> gdma_init;</div><div class="line">    <a class="code" href="struct_n_v_i_c___init_type_def.html">NVIC_InitTypeDef</a> nvic_init;</div><div class="line"></div><div class="line">    <a class="code" href="group__x3e___r_c_c___exported___functions.html#ga0ff78e34dcddb1ed9a215ee66ccb2d1b">RCC_PeriphClockCmd</a>(<a class="code" href="group___a_p_b___peripheral___define.html#gaeb8d35478322d35996e4cce867c0fd6b">APBPeriph_GDMA</a>, <a class="code" href="group___r_c_c___peripheral___clock.html#ga1de13be4bcbae35bede3bf7917aecf68">APBPeriph_GDMA_CLOCK</a>, <a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>);</div><div class="line"></div><div class="line">    <a class="code" href="group___g_d_m_a___exported___functions.html#ga0c4386a76f776a50aba1b2ecb6c665c5">GDMA_StructInit</a>(&amp;gdma_init);</div><div class="line">    gdma_init.<a class="code" href="struct_g_d_m_a___init_type_def.html#a672455687defa33a421d78eea9d8309c">GDMA_BufferSize</a>           = I2S_DMA_BUF_LEN;</div><div class="line">    gdma_init.<a class="code" href="struct_g_d_m_a___init_type_def.html#aa2ab817e5b8f8c9e79f7d07c1afa8069">GDMA_SourceDataSize</a>       = <a class="code" href="group___g_d_m_a__data__size.html#ga7926a7470440308dd929c1034e4e0fb6">GDMA_DataSize_Word</a>;</div><div class="line">    gdma_init.<a class="code" href="struct_g_d_m_a___init_type_def.html#a6e2cad942d5a4b533fec712c06b402e1">GDMA_DestinationDataSize</a>  = <a class="code" href="group___g_d_m_a__data__size.html#ga7926a7470440308dd929c1034e4e0fb6">GDMA_DataSize_Word</a>;</div><div class="line">    gdma_init.<a class="code" href="struct_g_d_m_a___init_type_def.html#aca898ef64b30b1eeca934c1dcfad946b">GDMA_SourceMsize</a>          = <a class="code" href="group___g_d_m_a___msize.html#gaf1924772c342efc86847bde3ffb552c6">GDMA_Msize_4</a>;</div><div class="line">    gdma_init.<a class="code" href="struct_g_d_m_a___init_type_def.html#ab0482d07c0511e055d22a991adce1893">GDMA_DestinationMsize</a>     = <a class="code" href="group___g_d_m_a___msize.html#gaf1924772c342efc86847bde3ffb552c6">GDMA_Msize_4</a>;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (dir == I2S_CONFIG_TX)</div><div class="line">    {</div><div class="line">        gdma_init.<a class="code" href="struct_g_d_m_a___init_type_def.html#afa81d74400498ca459fba1bb20101b74">GDMA_ChannelNum</a>           = I2S_TX_DMA_CHANNEL_NUM;</div><div class="line">        gdma_init.<a class="code" href="struct_g_d_m_a___init_type_def.html#aee96bc8a1d8ef85f2ffc64d02274fe67">GDMA_DIR</a>                  = <a class="code" href="group___g_d_m_a__data__transfer__direction.html#ga257d48aeb412e7914a71e44625467575">GDMA_DIR_MemoryToPeripheral</a>;</div><div class="line">        gdma_init.<a class="code" href="struct_g_d_m_a___init_type_def.html#a32b5468d324eb9b8ea93431393bb0918">GDMA_SourceAddr</a>           = (uint32_t)(i2s_send_buff);</div><div class="line">        gdma_init.<a class="code" href="struct_g_d_m_a___init_type_def.html#a426621ee71bcccf5c85db9678d68a037">GDMA_DestinationAddr</a>      = (uint32_t)I2S_TX_ADDR;</div><div class="line">        gdma_init.<a class="code" href="struct_g_d_m_a___init_type_def.html#ae185e562e3c1d62fb4a533b2a9af2125">GDMA_SourceInc</a>            = <a class="code" href="group___g_d_m_a__source__incremented__mode.html#ga96d0ea1d643d85940bfdd7df670409bd">DMA_SourceInc_Inc</a>;</div><div class="line">        gdma_init.<a class="code" href="struct_g_d_m_a___init_type_def.html#a33ccc00cfcca94735c63e6a85d33735b">GDMA_DestinationInc</a>       = <a class="code" href="group___g_d_m_a__destination__incremented__mode.html#gaad2e94b4db87adb93e92888c9e719359">DMA_DestinationInc_Fix</a>;</div><div class="line">        gdma_init.<a class="code" href="struct_g_d_m_a___init_type_def.html#aa76ac5f0162de6fe56840c2f2594badb">GDMA_DestHandshake</a>        = I2S_TX_DMA_HANDSHAKE;</div><div class="line">        <a class="code" href="group__x3e___g_d_m_a___exported___functions.html#ga1a3498cf6a9b61faecede7c2181e8c93">GDMA_Init</a>(I2S_TX_DMA_CHANNEL, &amp;gdma_init);</div><div class="line"></div><div class="line">        <a class="code" href="group___h_a_l___vector_table.html#ga1ddcc6c785e2655f5de7b7edf1f4302d">RamVectorTableUpdate</a>(I2S_TX_DMA_VECTOR, i2s_tx_dma_handler);</div><div class="line"></div><div class="line">        nvic_init.<a class="code" href="struct_n_v_i_c___init_type_def.html#a921af0ab04e071d7d276c003e0048123">NVIC_IRQChannel</a>           = I2S_TX_DMA_IRQ;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dir == I2S_CONFIG_RX)</div><div class="line">    {</div><div class="line">        gdma_init.<a class="code" href="struct_g_d_m_a___init_type_def.html#afa81d74400498ca459fba1bb20101b74">GDMA_ChannelNum</a>           = I2S_RX_DMA_CHANNEL_NUM;</div><div class="line">        gdma_init.<a class="code" href="struct_g_d_m_a___init_type_def.html#aee96bc8a1d8ef85f2ffc64d02274fe67">GDMA_DIR</a>                  = <a class="code" href="group___g_d_m_a__data__transfer__direction.html#ga98ab5e79de5534ff2f41f3773ce060a1">GDMA_DIR_PeripheralToMemory</a>;</div><div class="line">        gdma_init.<a class="code" href="struct_g_d_m_a___init_type_def.html#a32b5468d324eb9b8ea93431393bb0918">GDMA_SourceAddr</a>           = (uint32_t)I2S_RX_ADDR;</div><div class="line">        gdma_init.<a class="code" href="struct_g_d_m_a___init_type_def.html#a426621ee71bcccf5c85db9678d68a037">GDMA_DestinationAddr</a>      = (uint32_t)(i2s_recv_buff);</div><div class="line">        gdma_init.<a class="code" href="struct_g_d_m_a___init_type_def.html#ae185e562e3c1d62fb4a533b2a9af2125">GDMA_SourceInc</a>            = <a class="code" href="group___g_d_m_a__source__incremented__mode.html#ga7ebc23b20b558d5c91abff9e4e6d889a">DMA_SourceInc_Fix</a>;</div><div class="line">        gdma_init.<a class="code" href="struct_g_d_m_a___init_type_def.html#a33ccc00cfcca94735c63e6a85d33735b">GDMA_DestinationInc</a>       = <a class="code" href="group___g_d_m_a__destination__incremented__mode.html#ga7ef00ff55b0cdf54a0a64087d6fffcd7">DMA_DestinationInc_Inc</a>;</div><div class="line">        gdma_init.<a class="code" href="struct_g_d_m_a___init_type_def.html#a18502a0d95a6ddacad52dbf79e02cde8">GDMA_SourceHandshake</a>      = I2S_RX_DMA_HANDSHAKE;</div><div class="line">        <a class="code" href="group__x3e___g_d_m_a___exported___functions.html#ga1a3498cf6a9b61faecede7c2181e8c93">GDMA_Init</a>(I2S_RX_DMA_CHANNEL, &amp;gdma_init);</div><div class="line"></div><div class="line">        <a class="code" href="group___h_a_l___vector_table.html#ga1ddcc6c785e2655f5de7b7edf1f4302d">RamVectorTableUpdate</a>(I2S_RX_DMA_VECTOR, i2s_rx_dma_handler);</div><div class="line"></div><div class="line">        nvic_init.<a class="code" href="struct_n_v_i_c___init_type_def.html#a921af0ab04e071d7d276c003e0048123">NVIC_IRQChannel</a>           = I2S_RX_DMA_IRQ;</div><div class="line">    }</div><div class="line"></div><div class="line">    nvic_init.<a class="code" href="struct_n_v_i_c___init_type_def.html#a3c5567ef024a0489884083c88f17b4d5">NVIC_IRQChannelCmd</a>        = (<a class="code" href="group__x3d___r_t_l876x___exported__types.html#gac9a7e9a35d2513ec15c3b537aaa4fba1">FunctionalState</a>)<a class="code" href="group__x3e___r_t_l876x___exported__types.html#ggac9a7e9a35d2513ec15c3b537aaa4fba1a7d46875fa3ebd2c34d2756950eda83bf">ENABLE</a>;</div><div class="line">    nvic_init.<a class="code" href="struct_n_v_i_c___init_type_def.html#acd582bc2edce30e9d7ab5e0ede400f36">NVIC_IRQChannelPriority</a>   = 3;</div><div class="line">    <a class="code" href="group__x3e___n_v_i_c___exported___functions.html#ga4e06b4f5c9109d6bc8990adf77e5f8d3">NVIC_Init</a>(&amp;nvic_init);</div><div class="line">}</div></div><!-- fragment --><div style="page-break-after: always;"></div><h2><a class="anchor" id="SDIO"></a>
21  SDIO</h2>
<h3><a class="anchor" id="SDIO_Demo_Code_Support_List"></a>
21.1 SDIO Demo Code Support List</h3>
<center><div id="table_21_1"><b>Table 21-1 SDIO Sample Code 1 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 1  </th><th class="markdownTableHeadNone">sdio_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:180px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:670px">Demonstrates PC how communicates with SD card.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Brief Introduction  </td><td class="markdownTableBodyNone">This sample code demonstrates SD card read and write function. Read the data at the specified address of the SD card, and write the specified data to the SD card.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\sdio\sdcard\sdio_demo.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">sdio_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Supply Voltage  </td><td class="markdownTableBodyNone">3.3V, check rcfg of Voltage Setting   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Group pins  </td><td class="markdownTableBodyNone">The specific group pins are shown in Table 21-4 and Table 21-5.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">Take RTL87X3D Group0 as an example, shown in Figure 21-1. The 6 pins of SD <br />
card are respectively connected with Group0 on EVB, and the VDD and GND pins <br />
of SD card are connected with the VCC and GND pins on EVB.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">Press RESET on the EVB, string "sd_print_binary_data: buf: " will be printed in <br />
DebugAnalyzer. The last print data buf is 0~FF+0~FF (512 bytes).   </td></tr>
</table>
<center><div id="table_21_2"><b>Table 21-2 SDIO Sample Code 2 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 2  </th><th class="markdownTableHeadNone">sdio_fs_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:180px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:670px">Demonstrates PC how communicates with SD card by filesystem.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Brief Introduction  </td><td class="markdownTableBodyNone">This sample code demonstrates SD card read and write function by filesystem.<br />
FatFS_DirectoyDemo can write the data under the specified directory file of the <br />
SD card; FatFS_Demo can write and read data directly to the SD card file.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\sdio\demo\sdio_fs_demo.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">SD_DemoCode()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Supply Voltage  </td><td class="markdownTableBodyNone">3.3V, check rcfg of Voltage Setting   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Group pins  </td><td class="markdownTableBodyNone">The specific group pins are shown in Table 21-4 and Table 21-5.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">Take RTL87X3D Group0 as an example, shown in Figure 21-1. The 6 pins of SD <br />
card are respectively connected with Group0 on EVB, and the VDD and GND pins <br />
of SD card are connected with the VCC and GND pins on EVB.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">File Prepare  </td><td class="markdownTableBodyNone">1. FatFS_DirectoyDemo: The BBpro directory and written files need to be created in the root directory <br />
2. FatFS_Demo: "Data.txt" file needs to be created in the root directory.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">Press RESET on the EVB. <br />
1. FatFS_DirectoyDemo: String "FatFS_DirectoyDemo: write OK!" will be printed <br />
in DebugAnalyzer. And check that the files in the BBpro directory of the sd card <br />
are written data.<br />
2. FatFS_Demo: String "FatFS_Demo: f_read:0x31, 0x32, 0x33, read_len 1024!" <br />
will be printed in DebugAnalyzer. And check that "Test.txt" in the sd card is the <br />
written data.   </td></tr>
</table>
<div style="page-break-after: always;"></div><center><div id="table_21_3"><b>Table 21-3 SDIO Sample Code 3 Description</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Demo 3  </th><th class="markdownTableHeadNone">sdio_card_detect_demo.c   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div style="width:180px">Sample Purpose</div>  </td><td class="markdownTableBodyNone"><div style="width:670px">Demonstrates SD card detection by gpio.</div>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Brief Introduction  </td><td class="markdownTableBodyNone">This sample code demonstrates SD card detection function. Simulate SD card <br />
insertion and removal through gpio.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">File Path  </td><td class="markdownTableBodyNone">sdk\src\sample\io_demo\sdio\sdcard\sdio_card_detect_demo.c   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Function Entry  </td><td class="markdownTableBodyNone">sdio_card_detect_demo()   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Supply Voltage  </td><td class="markdownTableBodyNone">3.3V, check rcfg of Voltage Setting   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Selected CD pin  </td><td class="markdownTableBodyNone">#define SD_CARD_DETECT_PIN P0_3   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Group pins  </td><td class="markdownTableBodyNone">The specific group pins are shown in Table 21-4 and Table 21-5.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Hardware Connection  </td><td class="markdownTableBodyNone">Take RTL87X3D Group0 as an example, shown in Figure 21-1. The 6 pins of SD <br />
card are respectively connected with Group0 on EVB, and the VDD and GND pins <br />
of SD card are connected with the VCC and GND pins on EVB.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Expected Result  </td><td class="markdownTableBodyNone">Connect P0_3 with GND on evb, string "gpio_isr_cb: card insert!" will be printed in <br />
DebugAnalyzer. Remove P0_3 from GND, string "gpio_isr_cb: card remove!" will <br />
be printed in DebugAnalyzer.   </td></tr>
</table>
<div style="page-break-after: always;"></div><center><div id="table_21_4"><b>Table 21-4 SDIO Group Pins in RTL87X3D</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">RTL87X3D  </th><th class="markdownTableHeadCenter">CLK  </th><th class="markdownTableHeadCenter">CMD  </th><th class="markdownTableHeadCenter">DAT0  </th><th class="markdownTableHeadCenter">DAT1  </th><th class="markdownTableHeadCenter">DAT2  </th><th class="markdownTableHeadCenter">DAT3   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Group0 pins  </td><td class="markdownTableBodyCenter">P1_2  </td><td class="markdownTableBodyCenter">P1_3  </td><td class="markdownTableBodyCenter">P1_4  </td><td class="markdownTableBodyCenter">P1_5  </td><td class="markdownTableBodyCenter">P1_6  </td><td class="markdownTableBodyCenter">P1_7   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Group1 pins  </td><td class="markdownTableBodyCenter">P4_2  </td><td class="markdownTableBodyCenter">P4_3  </td><td class="markdownTableBodyCenter">P4_4  </td><td class="markdownTableBodyCenter">P4_5  </td><td class="markdownTableBodyCenter">P4_6  </td><td class="markdownTableBodyCenter">P4_7   </td></tr>
</table>
<center><div id="table_21_5"><b>Table 21-5 SDIO Group Pins in RTL87X3E</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">RTL87X3E  </th><th class="markdownTableHeadCenter">CLK  </th><th class="markdownTableHeadCenter">CMD  </th><th class="markdownTableHeadCenter">DAT0  </th><th class="markdownTableHeadCenter">DAT1  </th><th class="markdownTableHeadCenter">DAT2  </th><th class="markdownTableHeadCenter">DAT3   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Group0 pins  </td><td class="markdownTableBodyCenter">P5_0  </td><td class="markdownTableBodyCenter">P5_1  </td><td class="markdownTableBodyCenter">P5_2  </td><td class="markdownTableBodyCenter">P5_3  </td><td class="markdownTableBodyCenter">P5_4  </td><td class="markdownTableBodyCenter">P5_5   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Group1 pins  </td><td class="markdownTableBodyCenter">P6_0  </td><td class="markdownTableBodyCenter">P6_1  </td><td class="markdownTableBodyCenter">P6_2  </td><td class="markdownTableBodyCenter">P6_3  </td><td class="markdownTableBodyCenter">P6_4  </td><td class="markdownTableBodyCenter">P6_5   </td></tr>
</table>
<div class="image">
<img src="SDIO_Hardware_Connection_Diagram.jpg" alt="SDIO_Hardware_Connection_Diagram.jpg"/>
</div>
 <center><div id="figure_21_1"><b>Figure 21-1 SDIO Hardware Connection Diagram</b></div></center><h3><a class="anchor" id="SDIO_Function_Description"></a>
21.2  Function Description</h3>
<p>SDIO: Secure Digital Input and Output, defines a peripheral interface. SDIO card is an IO device that uses SD bus and SD commands. The shape and interface of the SDIO card are compatible with the SD card, but it not only realizes the storage function, but also realizes other functions, such as Bluetooth, WIFI, etc. <br />
SDHC: SD host controller, the connection of SDHC and SD card is shown in Figure 21-2. The host controls the internal operation of the SD card by reading/writing SDHC internal registers. <br />
SDIO transmission mode: SPI mode, 1-bit mode (single-wire), 4-bit SD mode (four-wire). The pin definitions in different modes are shown in Table 21-6. <br />
SDIO interface definition(4bit SD mode): <br />
CLK: Host to card clock signal <br />
CMD: Bi-directional command/response signal <br />
DAT0-DAT3: 4 Bi-directional data signals</p>
<p><b>Note:</b> RTL87X3D and RTL87X3E support SDIO, RTL87X3G doesn't support SDIO.</p>
<div style="page-break-after: always;"></div><center><div id="table_21_6"><b>Table 21-6 SDIO Pin Definitions in Different Modes</b></div></center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">pins  </th><th class="markdownTableHeadCenter">4-bit mode  </th><th class="markdownTableHeadCenter" colspan="2">1-bit mode   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyCenter">VCC  </td><td class="markdownTableBodyCenter">VCC  </td><td class="markdownTableBodyCenter">VCC   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">2  </td><td class="markdownTableBodyCenter">VSS1  </td><td class="markdownTableBodyCenter">VSS1  </td><td class="markdownTableBodyCenter">VSS1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">3  </td><td class="markdownTableBodyCenter">VSS2  </td><td class="markdownTableBodyCenter">VSS2  </td><td class="markdownTableBodyCenter">VSS2   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">4  </td><td class="markdownTableBodyCenter">CLK  </td><td class="markdownTableBodyCenter">CLK  </td><td class="markdownTableBodyCenter">CLK   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">5  </td><td class="markdownTableBodyCenter">CMD  </td><td class="markdownTableBodyCenter">CMD  </td><td class="markdownTableBodyCenter">CS   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">6  </td><td class="markdownTableBodyCenter">DAT0  </td><td class="markdownTableBodyCenter">DAT0  </td><td class="markdownTableBodyCenter">DAT0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">7  </td><td class="markdownTableBodyCenter">DAT1  </td><td class="markdownTableBodyCenter">RSV  </td><td class="markdownTableBodyCenter">DAT1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">8  </td><td class="markdownTableBodyCenter">DAT2  </td><td class="markdownTableBodyCenter">RSV  </td><td class="markdownTableBodyCenter">RSV   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">9  </td><td class="markdownTableBodyCenter">DAT3/CD  </td><td class="markdownTableBodyCenter">CD  </td><td class="markdownTableBodyCenter">RSV   </td></tr>
</table>
<div class="image">
<img src="SDHC_and_SD_card_Connection_Diagram.jpg" alt="SDHC_and_SD_card_Connection_Diagram.jpg"/>
</div>
 <center><div id="figure_21_2"><b>Figure 21-2 SDHC and SD card Connection Diagram </b></div></center><h3><a class="anchor" id="SDIO_Feature_List"></a>
21.3  Feature List</h3>
<ul>
<li>Support SD Spec V2.0</li>
<li>Support only 2 Group Pins on EVB to communicate with SD card. For specific pins, please refer to Table 21-3 or Table 21-4.</li>
<li>Support 1-bit and 4-bit SD bus width</li>
<li>Support optional bus clock, 40MHz and 80MHz can only support in RTL87X3D</li>
<li>Support multiple block and single block transfer, SDHC max block size is 512 Bytes</li>
<li>High Voltage SD card: operation Voltage 3.3V</li>
<li>Support DMA transfer</li>
<li>Support interrupt control</li>
</ul>
<h3><a class="anchor" id="SDIO_SD_Bus_Protocol"></a>
21.4  SD Bus Protocol</h3>
<ol type="1">
<li>The control on the SD bus is realized through CMD: the host initiates a request, and then SD card responds to the request.</li>
<li>Data transfer format: Start bit 0, first MSB, then LSB, CRC check, end bit 1.</li>
<li>Data is transferred in the form of data blocks. SD Bus block read and write operation, as shown in Figure 21-3 and Figure 21-4. <br />
Take SD Bus multi-block read operation as an example: <br />
(1) host sends a multi-block read command <br />
(2) SD card sends a response <br />
(3) card starts sending data <br />
(4) after each block is sent, return a CRC status <br />
(5) card transmits the next block data <br />
(6) Until the host sends a stop command, the card responds</li>
</ol>
<div style="page-break-after: always;"></div><div class="image">
<img src="SD_BUS_Block_Read_Operation.jpg" alt="SD_BUS_Block_Read_Operation.jpg"/>
</div>
 <center><div id="figure_21_3"><b>Figure 21-3 SD BUS (Multiple)Block Read Operation</b></div></center><div class="image">
<img src="SD_BUS_Block_Write_Operation.jpg" alt="SD_BUS_Block_Write_Operation.jpg"/>
</div>
 <center><div id="figure_21_4"><b>Figure 21-4 SD BUS (Multiple)Block Write Operation</b></div></center><h3><a class="anchor" id="SDIO_Operation_Flow"></a>
21.5  SDIO Operation Flow</h3>
<p>The codes below show SD card initialization flow. </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="struct_t___s_d___c_o_n_f_i_g.html">T_SD_CONFIG</a>    sd_card_cfg =</div><div class="line">{</div><div class="line">    .<a class="code" href="struct_t___s_d___c_o_n_f_i_g.html#a6a921677a966064a96a6721b35e7db97">sd_if_type</a> = <a class="code" href="group__x3e___s_d.html#gga0fb0201959d625bf0433bf2367182b21a7b3fcc351b4e9146905910214d749dec">SD_IF_SD_CARD</a>,</div><div class="line">    .sdh_group = <a class="code" href="group__x3e___s_d.html#ggab13ee3e9bfdee24819e69bf0e9029edfadabdcfa33be2061e4820d52140954ef5">GROUP_0</a>,</div><div class="line">    .sdh_bus_width = <a class="code" href="group__x3e___s_d.html#ggafbbaef2937a459d40ffcdaf84591bcbeaec2bdcbe09372b853de3fd25b50209be">SD_BUS_WIDTH_4B</a>,</div><div class="line">    .sd_bus_clk_sel = <a class="code" href="group__x3e___s_d.html#gga1e60fce566d304077d7878e1744ead3ba5acef7b6164b390d44a530fba44b0d2f">SD_BUS_CLK_20M</a></div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">/* SD config init */</span></div><div class="line"><a class="code" href="group__x3e___s_d.html#ga8761e28519020628929a006a2c5b9b6c">sd_config_init</a>((<a class="code" href="struct_t___s_d___c_o_n_f_i_g.html">T_SD_CONFIG</a> *)&amp;sd_card_cfg);</div><div class="line"><span class="comment">/* Group pins Pinmux &amp; Pad Config */</span></div><div class="line"><a class="code" href="group__x3e___s_d.html#ga0646eb6930865c77322f8f5a23f9cf01">sd_board_init</a>();</div><div class="line"><span class="comment">/* Initialize SD card peripheral */</span></div><div class="line"><a class="code" href="group__x3e___s_d.html#gaa94d91ba2e7766b10307b4f34df3786f">sd_card_init</a>();</div></div><!-- fragment --><div style="page-break-after: always;"></div><p>The codes below show SD card communication flow. For details, please refer to src\sample\io_demo\sdio\sdcard\sdio_demo.c </p><div class="fragment"><div class="line"><span class="keyword">static</span> uint8_t *test_buf = <a class="code" href="group___platform___types___exported___macros.html#ga070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;</div><div class="line">uint32_t sd_status = 0;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> sd_test(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    memset(test_buf, 0, <span class="keyword">sizeof</span>(test_buf));</div><div class="line">    <span class="comment">/* Read the data at the specified address of the SD card */</span></div><div class="line">    sd_status = <a class="code" href="group__x3e___s_d.html#ga3864152f0ee6fbab1d2c766e1d73ad20">sd_read</a>(OPER_SD_CARD_ADDR, (uint32_t)test_buf, SINGLE_BLOCK_SIZE, BLOCK_NUM);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (sd_status != 0)</div><div class="line">    {</div><div class="line">        return ;</div><div class="line">    }</div><div class="line">    <span class="comment">/*SD card print the binary data of test_buf */</span></div><div class="line">    <a class="code" href="group__x3e___s_d.html#ga709d77217bdf8afef0ef24d89a045c21">sd_print_binary_data</a>(test_buf, SINGLE_BLOCK_SIZE * BLOCK_NUM);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; SINGLE_BLOCK_SIZE * BLOCK_NUM; i++)</div><div class="line">    {</div><div class="line">        test_buf[i] = i &amp; 0xff;</div><div class="line">    }</div><div class="line">    <a class="code" href="group__x3e___s_d.html#ga709d77217bdf8afef0ef24d89a045c21">sd_print_binary_data</a>(test_buf, SINGLE_BLOCK_SIZE * BLOCK_NUM);</div><div class="line">    <span class="comment">/* Write the specified test_buf data to the SD card */</span></div><div class="line">    sd_status = <a class="code" href="group__x3e___s_d.html#gadba8345c4f96ec009badced9c12b734c">sd_write</a>(OPER_SD_CARD_ADDR, (uint32_t)test_buf, SINGLE_BLOCK_SIZE, BLOCK_NUM);</div><div class="line">}</div></div><!-- fragment --><div style="page-break-after: always;"></div><p>The codes below show SD card communication flow by filesystem. For details, please refer to src\sample\io_demo\sdio\sdcard\demo\sdio_fs_demo.c </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> FatFS_Demo(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    uint32_t a = 1;</div><div class="line">    uint32_t res = 0;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> driver_num = 0;</div><div class="line"></div><div class="line">    <span class="comment">/* Create workspace */</span></div><div class="line">    res = f_mount(&amp;fs, &amp;driver_num, 1);</div><div class="line"></div><div class="line">    <span class="comment">/* Open file */</span></div><div class="line">    res = f_open(&amp;fdst, <span class="stringliteral">&quot;Test.txt&quot;</span>, FA_CREATE_ALWAYS | FA_WRITE);</div><div class="line">    <span class="keywordflow">if</span> (res != FR_OK)</div><div class="line">    {</div><div class="line">        <span class="comment">//Open file failure, add error handle code here</span></div><div class="line">        f_close(&amp;fdst);</div><div class="line">        return ;</div><div class="line">    }</div><div class="line"></div><div class="line">    res = f_open(&amp;fsrc, <span class="stringliteral">&quot;Data.txt&quot;</span>, FA_OPEN_EXISTING | FA_READ);</div><div class="line">    <span class="keywordflow">if</span> (res != FR_OK)</div><div class="line">    {</div><div class="line">        <span class="comment">//Open file failure, add error handle code here</span></div><div class="line">        f_close(&amp;fsrc);</div><div class="line">        return ;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* File operation */</span></div><div class="line">    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; 1024; i++)</div><div class="line">    {</div><div class="line">        buffer[i] = i % 0x09 + 0x30;</div><div class="line">    }</div><div class="line">    buffer[1021] = 69;</div><div class="line">    buffer[1022] = 69;</div><div class="line">    buffer[1023] = 69;</div><div class="line">    f_write(&amp;fdst, buffer, 1024, &amp;a);</div><div class="line"></div><div class="line">    memset(buffer, 0, 1024);</div><div class="line">    f_read(&amp;fsrc, buffer, 1024, &amp;a);</div><div class="line"></div><div class="line">    <span class="comment">/* Close file */</span></div><div class="line">    f_close(&amp;fsrc);</div><div class="line">    f_close(&amp;fdst);</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->

<HR SIZE=5>
<font size="3" color="black">Copyright(c) 2020, <a href=" http://www.realtek.com.tw/"><font size="3" color="#6FB7B7"><b>Realtek Semiconductor Corporation</b></font></a>. All rights reserved.</font> 
